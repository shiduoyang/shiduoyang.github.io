<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通用型支付服务设计概述</title>
    <link href="/2023/09/08/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/08/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>日前应公司业务发展的要求，对支付逻辑进行了拆分，形成了独立支付服务。本文基于服务拆分的实践，探讨建立独立支付服务的思路。<br>文末的关键编码，为处理后的伪代码，与实际项目无关，特此声明。</p><h4 id="一：什么是独立支付服务"><a href="#一：什么是独立支付服务" class="headerlink" title="一：什么是独立支付服务"></a>一：什么是独立支付服务</h4><p>假设有三个不同的项目A,B,C，都需要接入支付宝H5支付功能。按照以往的开发模式，这三个项目需要分别开发一套与支付宝的对话逻辑，包括下单、支付回调、订单支付状态查询等。<br>假设这三个项目，现在要接入微信H5支付和微信JSAPI支付，那么同理，他们需要分别开发一套与微信方的对话逻辑。<br>如果还需要接入其他的支付方式呢？<br>独立支付服务可以理解为这些支付方式的代理，A,B,C在独立支付服务中注册它们的关键支付参数及商品，独立支付服务提供支付流程的保证和在关键的时间节点（订单创建、订单支付成功等）的通知。<br>有了独立支付服务，不管有多少个项目，大家都不需要关注与微信方等的对话逻辑，只需要关注必要的配置及少数几个通知就可以了。</p><h4 id="二：支付服务应包含哪些功能"><a href="#二：支付服务应包含哪些功能" class="headerlink" title="二：支付服务应包含哪些功能"></a>二：支付服务应包含哪些功能</h4><ul><li>客户管理。提供客户的注册、鉴权、关键支付信息（如微信appid）等的存储。</li><li>商品管理。客户创建商品、修改商品价格、设置各种通知接口。</li><li>支付服务。封装与实际支付服务提供者（微信、支付宝）的交互，提供统一的预下单接口，并在关键的时间节点通知客户。</li><li>查询服务。客户主动查询某订单的支付状态。</li></ul><h4 id="三：支付的整体流程是什么"><a href="#三：支付的整体流程是什么" class="headerlink" title="三：支付的整体流程是什么"></a>三：支付的整体流程是什么</h4><p>假设支付平台的服务器为S，客户的服务器为s，客户的前端（支付按钮所在的地方）为c。<br>假设客户A已经在支付平台注册了商品a，并设置当a创建订单和支付成功的时候，都要通知给s。<br>以支付宝H5支付为例。</p><h5 id="当用户点击支付按钮之后，支付流程应该是这样的："><a href="#当用户点击支付按钮之后，支付流程应该是这样的：" class="headerlink" title="当用户点击支付按钮之后，支付流程应该是这样的："></a>当用户点击支付按钮之后，支付流程应该是这样的：</h5><ul><li>c-&gt;S：用户要支付啦，选的是支付宝H5支付，商品是a，数量是1，用户的唯一标识是“15705420001” ，需要带给s那货的信息是”xxxxxx”;</li><li>S-&gt;c：我和支付宝方沟通过了，订单已创建，你的支付参数是*****，订单标识为12345;</li><li>S-&gt;s：有用户创建订单啦，用户是“15705420001”，商品是a，数量是1，你的客户端托我给你带的话是‘xxxxxx’，订单标识是12345；</li><li>c ：用支付参数一顿操作，唤起了支付，用户付款;</li><li>支付宝-&gt;S：订单12345支付成功啦；</li><li>S-&gt;s:  有用户支付订单啦，用户是“15705420001”，商品是a，数量是1，你的客户端托我给你带的话是‘xxxxxx’，订单标识是12345；</li><li>s：记录用户15705420001，买了1个商品a；</li></ul><h6 id="如果s不相信支付成功的通知呢？"><a href="#如果s不相信支付成功的通知呢？" class="headerlink" title="如果s不相信支付成功的通知呢？"></a>如果s不相信支付成功的通知呢？</h6><ul><li>s-&gt;S： 这个订单12345的，确实支付了吗？你去支付宝问问；</li><li>S-&gt;s：问过支付宝了，支付了；</li><li>s：记录用户15705420001，买了1个商品a；</li></ul><h5 id="c从支付宝的支付页面返回之后"><a href="#c从支付宝的支付页面返回之后" class="headerlink" title="c从支付宝的支付页面返回之后"></a>c从支付宝的支付页面返回之后</h5><ul><li>c-&gt;S：麻烦看下12345支付成功了吗；</li><li>S-&gt;c：问过支付宝了，支付了；</li><li>c：跳转支付成功页面；</li></ul><h4 id="四：关键编码"><a href="#四：关键编码" class="headerlink" title="四：关键编码"></a>四：关键编码</h4><p>笔者实践采用的是koa+mysql+redis技术栈，关键编码依然以支付宝h5支付为例。</p><h6 id="4-1：支付宝h5支付"><a href="#4-1：支付宝h5支付" class="headerlink" title="4.1：支付宝h5支付"></a>4.1：支付宝h5支付</h6><ul><li>获取支付参数时<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">const</span> info = <span class="hljs-keyword">await</span> aliH5PayChannel.<span class="hljs-title function_">unifiedOrder</span>(goodsInfo);<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">notifyOrderCreated</span>(goodsInfo, info);<br></code></pre></td></tr></table></figure></li><li>用户支付成功后</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//支付结果通知逻辑</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">notifyPaySuccess</span>(payOrder);<br></code></pre></td></tr></table></figure><ul><li>查询订单</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (orderType == <span class="hljs-variable constant_">ORDERTYPE</span>.<span class="hljs-property">ALIH5PAY</span>) &#123;<br><span class="hljs-keyword">let</span> queryResult = <span class="hljs-keyword">await</span> aliH5PayChannel.<span class="hljs-title function_">queryOrder</span>(orderNo);<br>       <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑陋的中国人</title>
    <link href="/2023/09/08/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/"/>
    <url>/2023/09/08/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>我们常常颂扬中国人的美好品德，但人无完人，民族也是如此。这本书就列举出了中国人的一些不足，读完之后我感觉振聋发聩，暗自告诫自己，在以后的生活中，需要常常自省。</p><h2 id="二：笔记"><a href="#二：笔记" class="headerlink" title="二：笔记"></a>二：笔记</h2><h3 id="2-1-极端自傲与自卑，但缺乏自尊"><a href="#2-1-极端自傲与自卑，但缺乏自尊" class="headerlink" title="2.1 极端自傲与自卑，但缺乏自尊"></a>2.1 极端自傲与自卑，但缺乏自尊</h3><p>造成中国人两个极端，不够平衡。 一方面是绝对的自卑，一方面是绝对的自傲。自卑的时候成了奴才，自傲的时候成了主人，却独独没有自尊。<br>这以至于中国人很难有平等观念，你不是我的主人，我就得是你的主人。这种情景影响到个人心态的封闭。死不认错，但又不断有错，以致使中国人产生一种神经质的恐惧。</p><h3 id="2-2-保护自己为第一，明哲保身"><a href="#2-2-保护自己为第一，明哲保身" class="headerlink" title="2.2 保护自己为第一，明哲保身"></a>2.2 保护自己为第一，明哲保身</h3><p>盖儒家在原则上只提倡个人主义而非集体主义。明哲保身，不入危墙。曰：危邦不入，乱邦不居，天下有道，则见，无道，则隐。邦有道，贫且贱，耻也；邦无道，富且贵焉，耻也。<br>都保护自己畏第一，明哲保身，也就有了：</p><ul><li>不敢想也不敢讲；</li><li>混日子；</li><li>拳头大了就是对；不论对错，以拳头大小论对错</li><li>出个冒尖的因为与自己的做法不符，会说他爱管闲事</li><li>有敬有畏，但缺乏爱；对上敬畏，对下严厉，但缺乏平等的爱</li><li>不太为别人着想；臭鞋扔门口，公共区域乱占，等等</li></ul><h3 id="2-3-合作精神不足"><a href="#2-3-合作精神不足" class="headerlink" title="2.3 合作精神不足"></a>2.3 合作精神不足</h3><p>三个人合作能有八个心眼</p><h3 id="2-4-凡事我例外"><a href="#2-4-凡事我例外" class="headerlink" title="2.4 凡事我例外"></a>2.4 凡事我例外</h3><p>随地吐痰是不对的，看到了我就会上去批评，但我自己是可以吐一吐。<br>闯红灯是不对的，看到了我就会上去批评，但我自己是可以闯一闯。<br>诸如此类</p><h3 id="2-5-崇洋媚外分不清"><a href="#2-5-崇洋媚外分不清" class="headerlink" title="2.5 崇洋媚外分不清"></a>2.5 崇洋媚外分不清</h3><p>崇洋经常被认为是媚外。把西方好的东西拿来，这叫崇洋；向外国人谄媚，巴结讨好，这叫媚外。媚外着实是该批评，但崇洋是为了中华民族的伟大复兴。</p><h3 id="2-6-讲礼但不讲理"><a href="#2-6-讲礼但不讲理" class="headerlink" title="2.6 讲礼但不讲理"></a>2.6 讲礼但不讲理</h3><p>讲理会感觉丢面子，因此往往用逃避讨论的方式来对待，这样有了面子，但拒绝了讲理的过程。</p><h2 id="三：读后心得"><a href="#三：读后心得" class="headerlink" title="三：读后心得"></a>三：读后心得</h2><p>书中林林总总说了许多内容，我细细体会与总结，认为造成中国人不足之处的有以下原因：</p><ol><li>2000年的封建帝制与动荡，造成了中国人自尊的缺失，也使得中国人更多关注家而非国</li><li>儒家明哲保身的思想，禁锢了中国人的血性与灵性</li></ol><h2 id="三：何以促进中华民族的伟大复兴"><a href="#三：何以促进中华民族的伟大复兴" class="headerlink" title="三：何以促进中华民族的伟大复兴"></a>三：何以促进中华民族的伟大复兴</h2><ol><li>虚心而非骄傲，骄傲使人自满，民族亦是如此。一个虚心的民族，一个具有包容性的民族，才能永葆青春与活力</li><li>奋勇争先而非明哲保身。当今世界变化太快，逆水行舟，不进则退。唯有勇于进取，大胆创新，才能不被淘汰。</li><li>合作共赢而非窝里斗。人力有时穷，国家也如此。一个人再厉害，凭他自己也仅能完成有限的工作。唯有习惯合作，善于合作，劲往一处使，才能完成更大的事业</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>曾国藩-又笨又慢平天下</title>
    <link href="/2023/09/08/%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B/"/>
    <url>/2023/09/08/%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>一：概述</p><p>曾国藩，是近代儒家文化的集大成者。</p><p>二：读后感</p><ol><li>勤奋，极度的勤奋是成功的基石</li><li>贵人的赏识是一生中难得的机遇</li><li>纵有万千才华，也要与同僚打成一片</li><li>失败，连续的失败是对心灵考验，通过了能获得极大的提升，通不过有可能因此丧命</li><li>舍小义成全大义</li><li>稳，稳扎稳打，稳中求胜，稳到没有破绽</li></ol><p>笨而极致的勤奋；慢却稳定的前进，是这本书对我最重要的教育。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-ES13</title>
    <link href="/2023/09/07/ES6-ES13/"/>
    <url>/2023/09/07/ES6-ES13/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>ES6 ES7 ES8的名称由来是啥？</p><ul><li>ES6 就是 ES2015</li><li>ES7 就是 ES2016</li><li>ES8 就是 ES2017<br>。。。</li></ul><h2 id="二：各版本的特性"><a href="#二：各版本的特性" class="headerlink" title="二：各版本的特性"></a>二：各版本的特性</h2><ol><li>ES6的新特性<ul><li>let const 块作用域</li><li>箭头函数</li><li>for of </li><li>Map 和 Set</li><li>class</li><li>Promise</li><li>函数参数默认值</li><li>…</li><li>String.includes startsWith endsWith</li><li>Array.find findIndex</li><li>解构赋值</li></ul></li><li>ES7的新特性<ul><li>2 ** 3 &lt;&#x3D;&gt; Math.pow(2,3)</li><li>Array.includes</li></ul></li><li>ES8的新特性  ES2017<ul><li>String 的 padStart  padEnd 长度补全  如：‘5’.padStart(4,0)&#x3D;&gt; ‘0005’</li><li>Object.entries 来遍历对象 for(let [k,v] of Object.entries(obj))</li><li>Object.values</li><li>async await 函数</li></ul></li><li>ES9的新特性<ul><li>在循环中使用await for(){await xxxxx}</li><li>Promise.finally</li><li>对象剩余属性 允许把除了解构出的属性之外的剩余属性，放到一个新的对象中<br>  obj &#x3D; {a:1,b:2,c:3}; let {a,bc}&#x3D;obj &#x3D;&gt; a&#x3D;1 bc &#x3D;{b:2,c:3}</li><li>对象扩展属性 允许把对象的所有属性拷贝到另一个对象中<br>  let c &#x3D; {…obj}</li></ul></li><li>ES10的新特性<ul><li>String.trimStart trimEnd ‘    123’.trimStart &#x3D; ‘123‘</li><li>Object fromEntries     通过一个entries来创建对象</li><li>catch(e){} 如无需访问e，可以改成 catch{…}</li><li>Array flat 数组展平（降N维），默认降1维</li><li>Array flatMap 数组展平 + map</li><li>Array sort</li></ul></li><li>ES11的新特性<ul><li>BigInt</li><li>String matchAll</li><li>x &amp;&amp;&#x3D; y  当x 为真时，把Y赋给X</li><li>x ||&#x3D; y  当x 为假时，把Y赋给X</li><li>x ??&#x3D; y  当x 不存在时，把Y赋给X</li><li>?? 空值运算符,前边为空的时候设置成后边的默认值  x&#x3D; a ?? 0 &lt;&#x3D;&gt; if(a!&#x3D;undefined){x&#x3D;a}else{x&#x3D;0} </li><li>?.xxx   a.x  a存在时取值, 不存在时返回undefined</li></ul></li><li>ES12的新特性<ul><li>Promise.any</li><li>String replaceAll</li><li>Numeric Separators</li><li>数字分割符  1_0000_0000 &#x3D; 100000000</li></ul></li><li>ES13的新特性 即 ES2012<ul><li>Array at</li><li>String at</li><li>await import<br> 等等</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql innodb支持的隔离级别与mvcc</title>
    <link href="/2023/09/06/mysql-innodb%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8Emvcc/"/>
    <url>/2023/09/06/mysql-innodb%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8Emvcc/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-概述"><a href="#一：-概述" class="headerlink" title="一： 概述"></a>一： 概述</h2><p>我们都知道，mysql的默认引擎是innodb引擎，之前也提到过了innodb的数据组织方式（聚集索引）与查询过程。<br>本文我们讨论另外一个问题：即innodb的事务</p><h2 id="二：事务及事务的隔离级别"><a href="#二：事务及事务的隔离级别" class="headerlink" title="二：事务及事务的隔离级别"></a>二：事务及事务的隔离级别</h2><h3 id="2-1-什么是事务"><a href="#2-1-什么是事务" class="headerlink" title="2.1 什么是事务"></a>2.1 什么是事务</h3><p>想象你去银行给老王转账1000，那么银行会怎么操作呢？简单来说第一步扣你的钱，第二步给老王加钱。<br>如果第一步扣完你的钱，第二步执行失败了怎么办？如果没有任何后续处理，你可能会骂娘。<br>那应该怎么整呢？如果失败，把你的钱得加回来，并告知你转账操作失败。<br>转账这件事，不管它有多少个步骤，我们把它作为一个整体来看待，要么整体都成功，要么整体都失败，不存在一部分成功，一部分失败。<br>这就叫事务。</p><h3 id="2-2-事务的特征"><a href="#2-2-事务的特征" class="headerlink" title="2.2 事务的特征"></a>2.2 事务的特征</h3><p>事务有什么特征呢?</p><ol><li>原子性：要么都成功，要么都失败</li><li>一致性：事务开始前，事务结束后，数据库的一致性不能被破坏。</li><li>隔离性：多个事务并发进行时，事务之间是隔离的，一个事务不能影响其他事务</li><li>持久性：改完了应该落盘，持久化保存</li></ol><h3 id="2-3-事物的隔离级别及"><a href="#2-3-事物的隔离级别及" class="headerlink" title="2.3 事物的隔离级别及"></a>2.3 事物的隔离级别及</h3><p>啥叫事务的隔离级别？通俗来说就是并发进行的事务，对彼此的影响程度，影响程度越大，隔离级别越低，反之越高；</p><ol><li>read uncommited 即读未提交，能读到其他事物未提交的数据</li><li>read commited 即读已提交，能读到其他事物已提交的数据</li><li>repeatable read 即可重复度，对于之前读到的数据，后续的每次读，这些数据的值都相同，但可能会读到新的行。</li><li>serializable 串行化，并行的其他事物对本事务完全没影响</li></ol><h3 id="三：innodb支持的事务隔离级别"><a href="#三：innodb支持的事务隔离级别" class="headerlink" title="三：innodb支持的事务隔离级别"></a>三：innodb支持的事务隔离级别</h3><p>innodb支持的隔离级别，来到了serializable<br>怎么做到的呢?</p><ol><li>MVCC：多版本并发控制，行数据有多个版本（快照），每个事务只能读取到事务创建之前的数据快照，并且仅本事务可见，对数据的操作保存在事务缓冲区中，提交以后落到磁盘上。</li><li>锁管理：innodb实现了表级锁，和行级锁。<ul><li>共享&#x2F;排他锁(Shared and Exclusive locks)，是行级锁</li><li>意向锁（Intent locks），是表级锁，意向锁有共享意向锁（IS锁）和排他意向锁（IX锁）</li><li>记录锁（Record locks）</li><li>间隙锁（Gap locks）：锁定一个记录之间的区间，以防止幻读和脏读的发生</li><li>临建锁（Next-key locks）：结合了记录锁和间隙锁的锁，锁定一个记录及其区间，以防止幻读和脏读的发生</li></ul></li><li>redolog：记录了每个事务读对数据库的修改操作，用于数据恢复</li><li>undolog：innodb通过回滚日志来回滚事务，回滚时逆序执行从而保证数据的一致性<br> 如操作时增加一行，那回滚日志中记录的应该是删除该行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引建立指导规则及慢查询分析</title>
    <link href="/2023/09/05/mysql%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E5%AF%BC%E8%A7%84%E5%88%99%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/05/mysql%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E5%AF%BC%E8%A7%84%E5%88%99%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>之前的文章中提到过mysql innodb的索引结构，这篇文章探讨mysql的索引建立规则，即慢查询。</p><h2 id="二：索引建立规则"><a href="#二：索引建立规则" class="headerlink" title="二：索引建立规则"></a>二：索引建立规则</h2><ol><li>满足最左前缀匹配原则。在建立索引时需考虑将来的应用场景，及可能的需求变化。</li><li>尽量选择区分度高的列作为索引。区分度 &#x3D; count(distinct col)  &#x2F; count(col) ，通俗来说就是相同的值比较少的列</li><li>尽量的扩展索引而非新建索引</li><li>索引尽量建立在小字段上，一些长的文本字段，不要建立索引</li></ol><h2 id="三：慢查询如何分析"><a href="#三：慢查询如何分析" class="headerlink" title="三：慢查询如何分析"></a>三：慢查询如何分析</h2><ol><li><p>explain 查看执行计划</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">explain <span class="hljs-keyword">select</span> * from xxx <span class="hljs-built_in">where</span> xxxx;<br></code></pre></td></tr></table></figure></li><li><p>开启慢查询日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global show_query_log = on; <span class="hljs-comment"># 这种是在交互式命令中的方式，如果数据库重启，这些就会失效，如果需要长期有效，需要修改mysql的配置文件</span><br>show variables like <span class="hljs-string">&#x27;%long%&#x27;</span>; <br><span class="hljs-built_in">set</span> long_query_time=0.02;// <span class="hljs-comment"># long_query_time是慢查询的临界值单位秒</span><br></code></pre></td></tr></table></figure><p> 慢查询日志的样子：<br> <img src="/pic/manchaxunrizhi.jpg" alt="慢查询日志"></p></li><li><p>开启性能详情</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show variables like <span class="hljs-string">&#x27;%profiling%&#x27;</span><br><span class="hljs-built_in">set</span> profiling = on<br></code></pre></td></tr></table></figure></li></ol><h2 id="四：慢查询的常见原因"><a href="#四：慢查询的常见原因" class="headerlink" title="四：慢查询的常见原因"></a>四：慢查询的常见原因</h2><ol><li>没加索引&#x2F;没用索引导致全表扫描</li><li>单标数据量太大。这种情况看下索引设置的到底对不对，要么考虑分表</li><li>limit 深分页。比方说每页10条，去获取第十万页的数据。 如 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> click <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure> 即使click加了索引，但因为二级索引的叶子结点保存的是主键的值，每条记录还需要回表查询才能知道是否需要丢弃，在该例子中，需要回表100010次，因此会很慢。<br> 这种情况下，需要考虑先查出主键ID，再根据主键查出所有字段 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br>xxx t1,<br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">where</span> click <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10000</span>,<span class="hljs-number">10</span>) t2<br><span class="hljs-keyword">where</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure></li><li>排序不当，导致使用filesort查询<br> 如果  order by xxx 这个xxx不能由查询此sql使用的索引直接完成，mysql就有可能会进行filewort<ul><li>如查询的数量较少，没有超过系统变量sort_buffer_size的大小，会进行内存排序（快排）</li><li>如查询的数量较多，超过了该系统变量，会使用文件进行排序（归并）<br> 会使用filesort查询的场景</li></ul><ol><li>order by 用的字段，不是查询该sql使用到的索引。解决方案：排序字段加索引</li><li>俩排序字段，一个正序，一个倒序，解决方案：可分析需求，然后比方说加个字段，在新的字段上排序，</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引结构及失效情景汇总</title>
    <link href="/2023/09/04/mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%A4%B1%E6%95%88%E6%83%85%E6%99%AF%E6%B1%87%E6%80%BB/"/>
    <url>/2023/09/04/mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%A4%B1%E6%95%88%E6%83%85%E6%99%AF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一：mysql的索引结构"><a href="#一：mysql的索引结构" class="headerlink" title="一：mysql的索引结构"></a>一：mysql的索引结构</h2><p>mysql是一个关系型数据库；<br>mysql的存储引擎最主要的有两个，一个是myisam，一个是innodb，下面我们分别来说明二者的索引结构</p><ol><li><p>myisam</p><ul><li>myisam的索引，结构是B+树，叶子节点保存的是数据记录的地址，也就是说它的索引和数据是分开的，叫非聚簇索引。</li><li>myisam的主键索引和非主键索引本质上没有区别，叶子节点都保存的是数据记录的地址</li></ul></li><li><p>innodb</p><ul><li>innodb的索引，结构是带有数据访问指针的B+树</li><li>主键索引的叶子结点，保存的是数据记录本身；非主键索引的叶子节点，保存的是主键值</li><li>由于innodb的索引，其索引和数据是在一起的，因此被称为聚簇索引</li><li>为提升读取性能，innodb的各节点在磁盘中是一个数据页<ol><li>每个节点是一个磁盘页，这样方便读入内存</li><li>每当访问某磁盘页，将读取其相邻的磁盘页，这个操作叫做磁盘预读，因此其相邻的磁盘页也能很快的被访问到；</li></ol></li><li>由于非叶子结点不存数据，所以这颗B+树的阶非常高（即非叶子结点可以储存非常多的数据项），故数高很小，一个近百万数据的表，可能其数高只有3.</li></ul><p> 一个直观的innodb索引例子：<br> <img src="/pic/innocbbjiatree.jpg" alt="innodbB+树索引"><br> 其中，一个浅蓝色的区域是一个磁盘页，深蓝色的是数据项，P1 P2 P3 是指针</p></li></ol><p>由于mysql的默认引擎是innodb，所以接下来我们的讨论都基于innodb引擎。</p><h2 id="二：B-树的增删改查"><a href="#二：B-树的增删改查" class="headerlink" title="二：B+树的增删改查"></a>二：B+树的增删改查</h2><p>B+树从B树演变而来，与B树的区别是B+树的非叶子节点只保存导航信息，所有数据都保存在叶子结点；<br>下面是一颗深度为4的三阶B+树</p><p><img src="/pic/bjiatree.jpg" alt="b+tree"></p><p>解释:</p><ul><li>每个节点最多有3个子节点，因此叫做3阶</li><li>根节点+非叶节点+叶节点，共4层，因此深度为4</li><li>每个非叶子节点，其节点上都存有</li></ul><p>增删改查要点</p><ul><li>B+树的增，需保持B+树的阶，一旦某节点的子节点数量超过3，需要分裂该节点，并查看父节点是否也有相同的问题。</li><li>B+树的删，同样需保持B+树的阶，B+树的子节点，不得小于m&#x2F;2，小于之后需要合并节点</li><li>B+树的改，不存在节点结构的变化</li><li>B+树的查，时间复杂度为log(n)，具体过程是每次取出一个节点（即读入一个数据页），比较，确定下一步的查询指针，然后继续这个过程。</li></ul><h2 id="三：innodb的查找策略"><a href="#三：innodb的查找策略" class="headerlink" title="三：innodb的查找策略"></a>三：innodb的查找策略</h2><ol><li>主键查询, 查询主键索引即可</li><li>查询用到了非主键索引（也叫辅助索引，二级索引），且所需返回的字段在索引中就有，这时只需要查找辅助索引</li><li>查询用到了非主键索引，如联合索引，所需返回的字段在索引中不全，这时候需要查询主键索引（也叫回表查询）</li><li>如压根没用到索引，需要全表扫描</li></ol><h2 id="四：innodb的索引失效场景"><a href="#四：innodb的索引失效场景" class="headerlink" title="四：innodb的索引失效场景"></a>四：innodb的索引失效场景</h2><ol><li>联合索引不满足最左前缀匹配原则</li><li>索引列参与计算，包括使用了一些函数</li><li>like %在最左边</li><li>类型隐式转换，如在varchar类型的字段上，查找时写int型的值</li><li>使用or操作</li><li>一些比较  &lt;  &gt; !&#x3D; ; isnot null ;not in ; not exists</li></ol><h2 id="五：优化项"><a href="#五：优化项" class="headerlink" title="五：优化项"></a>五：优化项</h2><ol><li>尽量避免使用select * ,而使用select 具体的字段，以期望走覆盖索引</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IM服务器设计与进化</title>
    <link href="/2023/09/03/IM%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%9B%E5%8C%96/"/>
    <url>/2023/09/03/IM%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%9B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>IM：instant messaging ，中文翻译”即时通讯“，干啥的呢？就是我发个消息，你即时的就能看见。<br>那么IM消息的整个系统都有哪些东西呢？</p><ol><li>客户端。用来发送玩家的消息给服务器，接收并显示群内玩家的消息；</li><li>服务端。用来接收并处理玩家的消息，以及给某玩家推送消息<br>有人问客户端自己能不能干这事？不能，因为我想给老王发个消息，但老王在哪我是不知道的，因为老王和我没有连接，所以只好找个中间商，中间商就固定在某个位置，我俩分别于中间商连接，那我俩也就可以连接了。</li></ol><h2 id="二：仅支持单聊的IM消息服务器，IM服务器1-0版"><a href="#二：仅支持单聊的IM消息服务器，IM服务器1-0版" class="headerlink" title="二：仅支持单聊的IM消息服务器，IM服务器1.0版"></a>二：仅支持单聊的IM消息服务器，IM服务器1.0版</h2><p>还是我和老王，我俩都连接了服务器这个中间商，我俩想通个话，怎么整呢？</p><ol><li>首先，我与服务器建立了连接，这个连接有一个唯一的标识，</li><li>然后，老王也与服务器建立了连接，这个连接也有一个唯一的标识</li><li>我想向老王发送一条消息：“吃了吗？”</li><li>那么我先向IM消息服务器发一条消息，说我想向老王发条消息。</li><li>IM服务器接收到了这条消息，它看看在线的人里面有没有老王，发现有，然后把消息发送给老王，然后告诉我发送成功。</li><li>老王接收到这条消息，我本地在服务器告诉我成功之后，也显示了这条消息。</li></ol><p>上边是通俗的讲法，下面是技术的讲法</p><ol><li>我与im服务器建立长连接，如通过socketio建立了长连接 s1，登录信息与长连接的关系保存到服务器，如&lt;playerId1: s1&gt;</li><li>老王与im服务器建立长连接，如通过socketio建立了长连接 s2，登录信息与长连接的关系保存到服务器，如&lt;playerId2: s2&gt;</li><li>我发言，本质上是客户端通过s1，向服务器发送消息：<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">sendMessage:</span> &#123;playerId = playerId2, message = <span class="hljs-string">&quot;吃了吗&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li>IM服务器接收到之后，在缓存中找有没有playerId2，如有，通过playerId2找到s2, 然后通过s2将message发送给playerId2, 同时将此信息发送给playerId1一份。</li><li>双方收到服务器推送的消息，分别展示这条消息</li></ol><p>如此设计，一个简单的单聊IM服务器，就成型了。</p><p>那么它有什么问题？</p><ol><li>只能单聊，群聊暂不支持。我想8个人一起聊，不能实现。</li><li>如果有人掉线了，发向此人的消息他接收不到，那人重新上线，也无法看到，简单来说这条消息丢了。</li></ol><h2 id="三：支持群聊和消息历史的IM服务器，IM消息服务器2-0版"><a href="#三：支持群聊和消息历史的IM服务器，IM消息服务器2-0版" class="headerlink" title="三：支持群聊和消息历史的IM服务器，IM消息服务器2.0版"></a>三：支持群聊和消息历史的IM服务器，IM消息服务器2.0版</h2><p>1.0版本解决只能单聊和消息丢失的问题，那么如何解决？</p><p>通俗来讲：</p><ol><li>通过发言前建立群组，把想群聊的这些人的信息归于一处，来支持群聊，这样就能知道你的发言应该发给谁谁谁</li><li>通过把发言备份到一个可靠的地方，作为历史发言记录，解决消息丢失的问题</li></ol><p>下面是技术的讲法</p><ol><li>playerId1,playerId2,playerId3分别于im服务器通过socketio建立了长连接 s1,s2,s3</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，创建个群组的数据group: {playerIds:[playerId1,playerId2,playerId3]},然后告知playerId1成功，并且通知到playerId2和playerId3这个组建群聊成功</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM收到该请求，查找到该群聊，查找到群聊中的playerid1,2,3，然后分别向playerId1,2,3发送此条消息，并且存储此条群聊的消息到数据库（如redis,mongodb）</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>如果playerId3 断线之后，playerId2说了句“去吃饭”呢？</p><ol><li>客户端保存有群聊最大的消息序号x，与im服务器建立长连接后，先问IM服务器询问目前最新的消息序号y，如x&lt;y，说明客户端存着的消息是滞后的，因此通过请求IM服务器的方式拿到x之后的群聊消息，并及时更新自己的最大消息序号到y</li></ol><p>看起来目前的版本已经支持了群聊，也解决了消息丢失问题。那么它还有什么问题？</p><ol><li>当同时发言的人数多的时候，这台服务器会处理不过来，表现为消息发出去以后老半天不见动静</li></ol><h2 id="四，理论上支持无限人聊天的IM服务器，IM服务器3-0版"><a href="#四，理论上支持无限人聊天的IM服务器，IM服务器3-0版" class="headerlink" title="四，理论上支持无限人聊天的IM服务器，IM服务器3.0版"></a>四，理论上支持无限人聊天的IM服务器，IM服务器3.0版</h2><p>2.0版本的单台服务器在人多时的性能问题，该如何解决？<br>答曰，分布式。分布式也就是多服务的意思，这些服务可能在一个服务器，也可能在多个服务器，这种方式理论上能近乎无限的提升服务的性能，但他会带来一些挑战：</p><ol><li>群聊里的人可能来自不同的服务器，因此消息发送将更复杂</li><li>当多人近乎同时发送消息时，需要保证群聊里的所有人完整，准确，顺序相同的拿到这些人的发言。不能顺序不一样，更不能缺失。</li></ol><p>那么服务器该如何设计呢？<br>通俗来讲：</p><ol><li>客户端创建的群组信息，要所有服务器都能看到，且都能获取，并且群组信息里除了要有用户的ID之外，还得有他在哪台服务器，这样才能找到这个用户在哪</li><li>用户上线时，需要更新一下群组信息，说明我目前连的是这台服务器</li><li>对于来自同一个群组内同时发言的这些请求，不管它有多少，整个服务器部分同时只处理一个</li></ol><p>下面是技术的讲法</p><ol><li>playerId1,playerId2,playerId3分别于im服务器A,B,C 通过socketio建立了长连接 s1,s2,s3</li><li>playerId1,2,3,分别更新自己在数据库中的数据，使server&#x3D;A&#x2F;B&#x2F;C</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，查找数据库，找到playerId1,2,3的数据，拿到各自的server，并创建群组的数据<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">group: &#123;players:[<br>  &#123;id:playerId1,server:A,socket:s1&#125;,<br>  &#123;id:playerId2,server:B,socket:s2&#125;,<br>  &#123;id:playerId3,server:C,socket:s3&#125;,<br>]&#125;,<br></code></pre></td></tr></table></figure>然后告知playerId1成功，并且通知发送消息给B和C，中的playerId2和playerId3这个组建群聊成功</li><li>IM的全局kafka消费者实例，订阅群聊的topic : “群聊ID”，xxxxx.subscribe(‘xxxx’);</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM接收到kafka的消息后，取出群聊消息，查找到该群聊，查找到群聊中的playerid1,2,3，拿到各自的server，然后向playerId1,2,3发送此条消息，并且存储此条群聊的消息到数据库（如redis,mongodb）</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>对于多个服务来说，各服务的在线状态需要同步，如果当前的流量较大，还需要动态的新增服务，简单来说服务需要管理。kubernetes集群是个可行的方案。</p><p>看起来目前的版本已经支持了分布式的服务，那么它还有什么问题？</p><ol><li>逻辑更复杂，客户端连接与消息处理的逻辑耦合在一起，IM服务器的代码将更加复杂，系统的可维护性降低</li><li>可测试性下降，单元测试和集成测试可能需要启动整个im服务器来进行</li><li>耦合性强，难以将消息的处理部分抽离出来，用于其他功能或服务</li><li>代码维护困难，很好理解，越复杂，就越难维护。</li></ol><h2 id="五，架构更优的IM服务器，IM服务器4-0版"><a href="#五，架构更优的IM服务器，IM服务器4-0版" class="headerlink" title="五，架构更优的IM服务器，IM服务器4.0版"></a>五，架构更优的IM服务器，IM服务器4.0版</h2><p>3.0版本的高耦合问题，该如何解决？</p><p>通俗来讲：</p><ol><li>将IM服务器的管理客户端连接，群组管理，发送消息的功能；与对消息的处理功能，分开，各自干各自的事情</li></ol><p>下面是技术的讲法：</p><ol><li>新建若干消息消费者服务器，这些服务器用于消息处理</li><li>IM服务器只负责管理与客户端的连接，群组管理，向客户端发送消息，以及接收来自消费者服务器的消息</li></ol><p>当玩家创建群组时：</p><ol><li>playerId1,playerId2,playerId3分别于im服务器A,B,C 通过socketio建立了长连接 s1,s2,s3</li><li>playerId1,2,3,分别更新自己在全局redis集群中的数据，即playerId1的server&#x3D;A，</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，查找数据库（redis），找到playerId1,2,3的server，并创建群组的数据，并保存到数据库（如redis）<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-attribute">group</span>: &#123;<span class="hljs-attribute">players</span>:[<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId1</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId2</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId3</span>&#125;,<br>]&#125;,<br></code></pre></td></tr></table></figure>然后告知playerId1成功，并且通知发送消息给B和C，中的playerId2和playerId3这个组建群聊成功</li><li>IM通知消息服务，消息服务接到通知后开始subscribe 此topic, topic名字是群组的ID</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li></ol><p>当玩家发言时：</p><ol><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM接收到请求，验证playerId1的身份，将消息存入数据库，并向kafka发送一条消息。topic为群聊ID<br>3.消息消费者拿到来自kafka的消息后，取出群聊的消息，在redis中找到该群聊，取出其中的playerId, 然后从全局redis中找到playerId对应的server，然后给对应的IM服务器发送消息，类似如{server:A,playerId:’playerId1’,”message”:”干啥去”}</li><li>IM服务器接收到来自消息消费者的消息后，验证是否连接有playerId, 如果有，通过socketio向该用户发消息</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>目前的架构，有如下特征：</p><ol><li>IM服务可以是任意多个，负责处理连接，管理群组，发送消息</li><li>消息消费者服务可以是任意多个，负责处理消息，形成明确的消息发送指令，并给到IM服务</li><li>kafka作为中间件存在，负责异步转同步，流量削峰</li><li>IM和消息消费者服务职责明确，有利于维护</li></ol><p>看起来似乎不错了，那么它还有哪些问题？</p><ol><li>鉴权，不是什么人都能发消息，因此需要增加鉴权</li><li>全局的redis来储存用户所在的server信息，一旦redis挂了，所有人都不能聊天了，因此可以考虑redis与mongodb结合，缓存+DB的形式，这将增加开发的复杂度</li><li>消息发从到kafka这段如果失败，就会消息丢失，需要设计个类似接收回执的逻辑</li></ol><p>但主体的架构已经完成，总体来说是个还不错的IM服务器架构。</p><p>这里先空着，我将给出架构图：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> empty <br></code></pre></td></tr></table></figure><h2 id="六：下一代IM服务器的方向在哪里"><a href="#六：下一代IM服务器的方向在哪里" class="headerlink" title="六：下一代IM服务器的方向在哪里"></a>六：下一代IM服务器的方向在哪里</h2><p>本着大胆想象的原则，让我们畅想一下下一代的IM服务器。<br>但我这里还没有具体的答案，但大概有一些关键词，如AI，去中心化和边缘计算，有待思考和讨论</p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器和容器化技术概述</title>
    <link href="/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：容器和容器化"><a href="#一：容器和容器化" class="headerlink" title="一：容器和容器化"></a>一：容器和容器化</h2><ol><li>什么是容器<br> 容器是一种轻量级，可移植的封装，它包括应用程序及其依赖项，以便在不同的计算环境中运行。简单来说他就是个集装箱，包含有应用程序及它运行所需的各种支持。</li><li>什么是镜像<br> 镜像是一个只读的文件系统快照，包含了一个应用程序及其所有依赖项的文件和设置。这个快照可以用于创建运行容器的实例。镜像包含了应用程序的二进制文件、库、环境变量、配置文件等，使得容器能够在隔离的环境中运行。</li><li>什么是容器化和容器化技术<br> 容器化是一种应用程序部署和交付的方法，它是一种理念，旨在将应用程序及其依赖项打包成一个可移植的容器，容器可以可以在不同的环境中运行。<br> 容器化技术是实现这一理念的一些工具和技术，包括容器运行时（docker，containd,podman），镜像（docker镜像，OCI镜像），容器编排工具（Kubernetes，docker compose等）等</li></ol><h2 id="二：Docker概述"><a href="#二：Docker概述" class="headerlink" title="二：Docker概述"></a>二：Docker概述</h2><p>Docker 是一种容器化平台，用于创建、部署和管理容器化应用程序。</p><h3 id="2-1-Docker-的主要功能"><a href="#2-1-Docker-的主要功能" class="headerlink" title="2.1 Docker 的主要功能"></a>2.1 Docker 的主要功能</h3><ol><li>容器化：Docker 允许开发人员将应用程序及其依赖项打包成容器，使应用程序具有独立性、可移植性和一致性，可以在不同环境中运行。</li><li>镜像管理：Docker 镜像是容器的基础，它们包含了应用程序和其依赖项的文件系统快照。Docker 提供了创建、管理和共享镜像的工具。</li><li>容器编排：Docker 提供了容器编排工具，如 Docker Compose 和 Docker Swarm，用于管理多个容器的部署，实现高可用性、负载均衡和伸缩性。</li><li>跨云部署：Docker 容器可以在不同的云提供商之间轻松迁移，支持多云部署策略。</li><li>快速启动和停止：Docker 容器可以在几秒内启动和停止，加速了应用程序的部署和扩展。</li></ol><h3 id="2-2-Docker的组件"><a href="#2-2-Docker的组件" class="headerlink" title="2.2 Docker的组件"></a>2.2 Docker的组件</h3><p>Docker 由以下主要组件组成：</p><ol><li>Docker Daemon（Docker 服务端）：后台运行的服务，负责管理容器的创建、启动、停止、删除等任务。</li><li>Docker 客户端：用户与 Docker 交互的命令行工具或 API 客户端，可发送指令给 Docker Daemon。</li><li>Docker 镜像：容器的基础，包含应用程序及其依赖项的文件系统快照。</li><li>Docker 镜像仓库：用于存储和共享 Docker 镜像的中央存储库，Docker Hub 是一个常见的公共仓库。</li><li>Dockerfile：文本文件，包含创建 Docker 镜像的指令和配置信息。</li><li>Docker 网络：用于容器之间通信以及与外部网络连接的网络配置。</li><li>Docker 数据卷：用于容器内外数据共享和持久性存储的机制。</li><li>Docker Compose：用于定义和运行多个 Docker 容器的应用程序的工具。</li></ol><h3 id="2-3-如何使用docker"><a href="#2-3-如何使用docker" class="headerlink" title="2.3 如何使用docker"></a>2.3 如何使用docker</h3><ol><li>创建dockerFile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用官方 Node.js 镜像作为基础镜像</span><br>FROM node:14<br><br><span class="hljs-comment"># 设置工作目录</span><br>WORKDIR /usr/src/app<br><br><span class="hljs-comment"># 复制项目文件到容器中</span><br>COPY package*.json ./<br>COPY . .<br><br><span class="hljs-comment"># 安装项目依赖</span><br>RUN npm install<br><br><span class="hljs-comment"># 暴露端口</span><br>EXPOSE 3000<br><br><span class="hljs-comment"># 启动应用程序</span><br>CMD [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]<br></code></pre></td></tr></table></figure></li><li>构建镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t my-node-app .<br></code></pre></td></tr></table></figure></li><li>运行Docker容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 3000:3000 -d my-node-app<br></code></pre></td></tr></table></figure></li></ol><h2 id="三：kubernetes概述"><a href="#三：kubernetes概述" class="headerlink" title="三：kubernetes概述"></a>三：kubernetes概述</h2><p>大服务集群上容器的部署，伸缩和管理的各种问题，衍生出来了容器编排引擎，比较著名的有 Mesos, DockerSwarm, Kubernetes。<br>Kubernetes名字太长了，叫起来有点麻烦，而Kubernetes首字母与结尾字母之间有8个字母，因此被称作K8S。</p><h3 id="3-1-kubernetes的相关概念"><a href="#3-1-kubernetes的相关概念" class="headerlink" title="3.1 kubernetes的相关概念"></a>3.1 kubernetes的相关概念</h3><p>k8s概念及架构</p><ol><li>cluster<br>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用</li><li>master<br>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master</li><li>node<br>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。Node运行在Linux操作系统上，可以是物理机或者是虚拟机。</li><li>pod<br>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。同一个pod管理的多个容器之间可以通信和资源共享。</li><li>controller<br>Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。Controller中定义了Pod的部署特性，比如有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等</li><li>service<br>Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。<br>Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。</li><li>namespace<br>Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的</li></ol><h3 id="3-2-kubernetes的架构"><a href="#3-2-kubernetes的架构" class="headerlink" title="3.2 kubernetes的架构"></a>3.2 kubernetes的架构</h3><h4 id="3-2-1：-master节点"><a href="#3-2-1：-master节点" class="headerlink" title="3.2.1： master节点"></a>3.2.1： master节点</h4><p><img src="/pic/kubernetes-master.jpg" alt="master"></p><p>master是kubernetes cluster的大脑</p><ul><li>API Server：提供HTTP&#x2F;HTTPS RESTful API，即Kubernetes API。API Server是Kubernetes Cluster的前端接口，各种客户端工具（CLI或UI）以及Kubernetes其他组件可以通过它管理Cluster的各种资源</li><li>Scheduler：负责决定将Pod放在哪个Node上运行。Scheduler在调度时会充分考虑Cluster的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</li><li>Controller Manager：负责管理Cluster各种资源，保证资源处于预期的状态。Controller Manager由多种controller组成，包括replicationcontroller、endpoints controller、namespace controller、serviceaccountscontroller等。不同的controller管理不同的资源。例如，replication controller管理Deployment、StatefulSet、DaemonSet的生命周期，namespacecontroller管理Namespace资源</li><li>etcd：负责保存Kubernetes Cluster的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速地通知Kubernetes相关组件</li><li>Pod网络：Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案</li><li>kubelet和kube-proxy见node节点的结构（master同时也是一个node，可以运行应用）</li></ul><h4 id="3-2-2：-node节点"><a href="#3-2-2：-node节点" class="headerlink" title="3.2.2： node节点"></a>3.2.2： node节点</h4><p>node是pod运行的地方。</p><p><img src="/pic/kubernetes-node.jpg" alt="node"></p><ul><li>kubelet：kubelet是Node的agent，当Scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息（image、volume等）发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。</li><li>kube-proxy：kube-proxy负责将访问service的TCP&#x2F;UPD数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡</li><li>pod网络：同上</li></ul><h4 id="3-2-3：单master架构"><a href="#3-2-3：单master架构" class="headerlink" title="3.2.3：单master架构"></a>3.2.3：单master架构</h4><p><img src="/pic/kubernetes-master-node.jpg" alt="gingle-master"></p><h3 id="3-3：组件间的协作"><a href="#3-3：组件间的协作" class="headerlink" title="3.3：组件间的协作"></a>3.3：组件间的协作</h3><p>kubectl run httpd-app –image&#x3D;httpd –replicas&#x3D;2 发生了什么？</p><p><img src="/pic/kubernetes-4.jpg" alt="image"></p><ol><li>kubectl发送部署请求到API Server</li><li>API Server通知Controller Manager创建一个deployment资源</li><li>Scheduler执行调度任务，将两个副本Pod分发到k8s-node1和k8s-node2</li><li>k8s-node1和k8s-node2上的kubectl在各自的节点上创建并运行Pod</li></ol><h3 id="3-4：kubectl命令"><a href="#3-4：kubectl命令" class="headerlink" title="3.4：kubectl命令"></a>3.4：kubectl命令</h3><p>kubectl的语法：kubectl [command] [TYPE] [NAME] [flags]</p><ul><li>command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete</li><li>type：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式</li><li>name：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息，如 kubectl get pods</li><li>flags：指定可选的参数。例如，可以使用 -s 或 -server 参数指定 Kubernetes API 服务器的地址和端口</li></ul><p>常用命令示例：</p><ul><li>kubectl get pods</li><li>kubectl get nodes</li><li>kubectl create -f nginx-deployment.yaml</li><li>kubectl delete po rc-nginx-btv4j</li><li>kubectl scale rc rc-nginx-3 —replicas&#x3D;4</li><li>kubectl logs mysql-478535978-1dnm2</li><li>kubectl expose rc nginx –port&#x3D;80 –target-port&#x3D;8000（为RC的nginx创建service，并通过Service的80端口转发至容器的8000端口上）</li><li>kubecl run xxxxx 创建并运行一个或多个容器镜像</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>《每天五分钟玩转Kubernetes》</li><li>《深入浅出Docker》</li><li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">kubernetes官方交互式教程</a>：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">kubectl命令文档</a>：<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create</a></li><li><a href="http://docs.kubernetes.org.cn/475.html">kubectl中文文档</a>：<a href="http://docs.kubernetes.org.cn/475.html">http://docs.kubernetes.org.cn/475.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英文字母起源</title>
    <link href="/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/"/>
    <url>/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>英语的26个字母最初起源于埃及象形文字，后由腓尼基人改进发明了腓尼基字母，希腊人对腓尼基字母加以改革后创造了希腊字母，古罗马人对希腊字母加以改革进而发明了拉丁字母，英文字母就属于拉丁字母。</p><h2 id="二：拉丁字母的起源，含义及引申含义"><a href="#二：拉丁字母的起源，含义及引申含义" class="headerlink" title="二：拉丁字母的起源，含义及引申含义"></a>二：拉丁字母的起源，含义及引申含义</h2><p>A 牛头 牛角；引申为牛角尖锐，针刺，酸痛，食物中最重要的部分<br>B 房屋；<br>C 骆驼；引申为运输，行走，携带，覆盖<br>D 门；引申为向下<br>E 窗户；引申为开关窗户的动作，向外伸延，引申，透过窗户可以看到外面<br>F 失败；引申为错误，失败；由附着引申为漂浮，表面，刀剑等含义<br>G 骆驼的头颈部；由C变化而来，引申为从深处出来，向深处拉<br>H 栅栏；人，围墙，连接，界限，高处；引申为相邻的房间<br>I 手指；人，树，水滴；引申为尖端，一点，火，目标，插，按，蜡烛，多代表与光明相关的东西<br>J 由I变化而来；表勾，挖，捏，握紧，夹紧等手指弯曲做出的动作；<br>K 手掌；张开，拖，压，推等手掌做的动作，引申为统治者，张开，裂开，开口，锋利，打架等<br>L 鞭子；引申含义：拉，抽，打，绕、绑东西的动作，长的，长远的，男性，驯服<br>M 海浪；山峰，引申含义： 男性 牢固 坚强 力量 多 咬合 匹配 合并 碰撞 记忆<br>N 鱼；引申：捞，收缩，摆动，跳跃，连接<br>O 眼睛；引申：转动 范围 开关 循环 观察 圆 女性<br>P 嘴唇；扁的，紧贴，吹，吐，含，吸，引申为向上，突出，顶端<br>Q 垂着尾巴的猴子；引申：收缩，汇集，挠，跳等猴子的动作；象征女性头部，表示女人， 问题<br>R 狗；代表生命力强的，侦查，看守，记忆，杂乱 引申：上司，高层，火苗，河流，招手，跑步<br>S 牙齿，沙丘；代表坚硬，相似，锋利，痕迹，咬，撕开等牙的特征和动作。引申为口舌，女人，流沙，蛇，音符，沙丘，弯腰动作，身体<br>T 叉号；引申为符号，字符，信息，识别，指示，启示，长久，不变，固定，神 工具<br>U 木栓孔; 由V延伸而来；引申含义有宽裕的 间距 容纳 器具 集中<br>V 木钉；引申为拉动，插动，活动，保卫，防护，固定，钉子，山谷，交叉，空，空虚<br>W 由V派生而来；double u,两个门栓，含义由保障，引申为女性 水 错误<br>X 问号；代表未知，无限，目标，希望，极致，顶峰，高贵，冷艳，完美，引申为交叉，四面八方，迷惑，错误<br>Y 早期将Y认为是上边的V和下面的I的组合; 引申：分支，道路，裂开，裂缝，岔生，产生，青年，年轻的，从前，确定<br>Z 宙斯；引申狂热，热情，速度，曲折的</p><h2 id="三：总结"><a href="#三：总结" class="headerlink" title="三：总结"></a>三：总结</h2><p>通过以上的统计，我们得出如下规律</p><h4 id="3-1-字形上，一些字母由其他字母演变而来"><a href="#3-1-字形上，一些字母由其他字母演变而来" class="headerlink" title="3.1 字形上，一些字母由其他字母演变而来"></a>3.1 字形上，一些字母由其他字母演变而来</h4><ol><li>G由C变化而来</li><li>J由I变化而来</li><li>U,W由V延伸而来</li><li>Y是一个意外，把上边的V和下边的I看成了一个字母</li></ol><h4 id="3-2-子母的含义，由几部分组成"><a href="#3-2-子母的含义，由几部分组成" class="headerlink" title="3.2 子母的含义，由几部分组成"></a>3.2 子母的含义，由几部分组成</h4><ol><li>基本含义</li><li>由基本含义引申出的含义</li><li>由字形特征引申出的含义</li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>generator函数与Async/await函数</title>
    <link href="/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>generator函数是一个迭代器</p><h2 id="二-详情"><a href="#二-详情" class="headerlink" title="二 详情"></a>二 详情</h2><p>Generator 函数是ECMAScript 6（ES6）中的一种特殊类型的函数，它能够产生迭代器（Iterator）。与普通的函数不同，Generator 函数可以暂停执行并随时恢复执行，而不会丢失函数的内部状态。这使得它们在处理异步操作、流控制和延迟执行方面非常有用。</p><p>Generator 函数通过使用特殊的关键字 function* 来声明，并在函数体内部使用 yield 表达式来暂停函数的执行并返回一个产生的值。每次调用 yield 都会暂停函数的执行，同时返回一个迭代器对象，您可以使用该迭代器对象来恢复函数的执行。调用生成器函数不会立即执行函数体，而是返回一个生成器对象，您需要显式地调用该生成器对象的 next() 方法来触发函数的执行。</p><p>简单来说：Generator函数是一个迭代器。</p><p>一个Generator函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-params">millionSeconds</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">res</span>(<span class="hljs-number">1</span>);<br>        &#125;, millionSeconds);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFunc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">generatorFunc</span>();<br>    <span class="hljs-keyword">let</span> a = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next a=`</span>, a);<br>    <span class="hljs-keyword">let</span> b = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-keyword">let</span> bResult = <span class="hljs-keyword">await</span> b.<span class="hljs-property">value</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next b=`</span>, b, <span class="hljs-string">`bResult = <span class="hljs-subst">$&#123;bResult&#125;</span>`</span>);<br>    <span class="hljs-keyword">let</span> c = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next c=`</span>, c);<br>    <span class="hljs-keyword">let</span> d = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next d=`</span>, d);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>());<br>&#125;<br><span class="hljs-title function_">test</span>();<br><br></code></pre></td></tr></table></figure><p>结合以上例子，我们来总结一下generator函数的用法：</p><ol><li>generator函数需要用“*”来声明</li><li>yield 后面需要跟的是可被迭代的东西 ，数值，表达式都行</li><li>如果yield后面跟一个promise，那么执行时迭代到这里，next中的value也是一个promise，需要自己手动去await执行</li><li>每次next，都会返回一个对象，该对象中的value表示被迭代的值，done表示是否完毕</li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从koa到koa2</title>
    <link href="/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/"/>
    <url>/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-Koa2简介及与Koa1的区别"><a href="#一：-Koa2简介及与Koa1的区别" class="headerlink" title="一： Koa2简介及与Koa1的区别"></a>一： Koa2简介及与Koa1的区别</h2><p>Koa2是Koa1框架的升级版本，目前已经是koa的默认版本；<br>相较于Koa1，Koa2引入了一些重要的变化和改进。以下是Koa2相对于Koa1的一些区别：</p><ol><li>Koa 1 使用 Generator 函数来处理中间件和异步操作，而 Koa 2 直接支持 async&#x2F;await，让中间件的编写和理解更加简洁明了</li></ol><p>下面我们从使用的角度分别分析：</p><h2 id="二：Koa2的Async-Await支持"><a href="#二：Koa2的Async-Await支持" class="headerlink" title="二：Koa2的Async&#x2F;Await支持"></a>二：Koa2的Async&#x2F;Await支持</h2><p>现在我们使用koa1来实现一个中间件，该如何做呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * (next) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">someAsyncFunction</span>(); <span class="hljs-comment">// Yielding async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> next;<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>koa2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">xxxx</span>(); <span class="hljs-comment">// Await async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>Koa2的中间件函数采用 async (ctx, next) &#x3D;&gt; {…}，而在 Koa1中是function * (next) {…}。Koa2直接支持Async&#x2F;Await，使得中间件的编写和理解更加简洁。</p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析koa的koa-compose</title>
    <link href="/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/"/>
    <url>/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa-compose 是koa用来合并中间件的工具，并且在中间件内部，原各个中间件的执行过程为洋葱式的。<br>本文我们从源码的角度，去看洋葱式是什么？它又是如何实现的？</p><h4 id="二：源码"><a href="#二：源码" class="headerlink" title="二：源码"></a>二：源码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middleware)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware stack must be an array!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码精简</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中的重要逻辑：</p><ul><li>返回值为一个中间件A</li><li>中间件数组的执行，是从第一个开始的</li><li>执行某中间件时，同时传入了下一个中间件（赋值为next），并通过调用next来执行该中间件</li><li>数组中中间件执行完毕后，执行A的下一个中间件</li></ul><h4 id="三：next与洋葱模型"><a href="#三：next与洋葱模型" class="headerlink" title="三：next与洋葱模型"></a>三：next与洋葱模型</h4><p>上回说到，next是用来执行下一个中间件的，那么在某中间件中，next的执行可能有以下情况</p><h5 id="3-1-在最开始调用"><a href="#3-1-在最开始调用" class="headerlink" title="3.1 在最开始调用"></a>3.1 在最开始调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-2-在中间调用"><a href="#3-2-在中间调用" class="headerlink" title="3.2 在中间调用"></a>3.2 在中间调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-3-在末尾调用"><a href="#3-3-在末尾调用" class="headerlink" title="3.3 在末尾调用"></a>3.3 在末尾调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h5><p>由于以下两条显而易见的规则：</p><ul><li>在某中间件内，next之前的代码先于next之后的代码执行</li><li>对某中间件来说，next执行完毕的标志，是其后所有的中间件均执行完毕</li></ul><p>故而中间件执行的过程有以下特征：</p><ul><li>先执行各个中间件next之前的代码，再执行各个中间件next之后的代码</li><li>各中间件next之前的代码，执行顺序为按照中间件顺序，从前向后</li><li>各中间件next之后的代码，执行顺序为按照中间件顺序，从后向前</li></ul><p>最后祭出那颗著名的葱：</p><p><img src="/pic/yangcong.jpg" alt="洋葱模型"></p><p>参考:<br><a href="https://github.com/koajs/compose.git">https://github.com/koajs/compose.git</a></p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koa源码学习及最简实现</title>
    <link href="/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa是基于nodejs平台的下一代web框架（官网描述）<br>官网地址：<a href="https://koa.bootcss.com/">https://koa.bootcss.com/</a><br>git地址：<a href="https://github.com/koajs/koa.git">https://github.com/koajs/koa.git</a><br>koa提供基于http服务的最简的框架模型，包括洋葱式的中间件处理逻辑、对请求和响应的封装等。</p><h4 id="二：使用"><a href="#二：使用" class="headerlink" title="二：使用"></a>二：使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><br><span class="hljs-keyword">let</span> koa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>koa.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);<br>    ctx.<span class="hljs-property">body</span> = &#123; <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> &#125;;<br>&#125;);<br><br>koa.<span class="hljs-title function_">listen</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server listen 5000&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="三：源码"><a href="#三：源码" class="headerlink" title="三：源码"></a>三：源码</h4><p>源码的lib下共四个文件：application.js，context.js，request.js，response.js</p><h5 id="3-1-application-js"><a href="#3-1-application-js" class="headerlink" title="3.1 application.js"></a>3.1 application.js</h5><p>application.js是暴露给外部的入口，关键代码：</p><h6 id="3-1-1-use"><a href="#3-1-1-use" class="headerlink" title="3.1.1 use"></a>3.1.1 use</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;middleware must be a function!&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isGeneratorFunction</span>(fn)) &#123;<br>    <span class="hljs-title function_">deprecate</span>(<span class="hljs-string">&#x27;Support for generators will be removed in v3. &#x27;</span> +<br>              <span class="hljs-string">&#x27;See the documentation for examples of how to convert old middleware &#x27;</span> +<br>              <span class="hljs-string">&#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;</span>);<br>    fn = <span class="hljs-title function_">convert</span>(fn);<br>  &#125;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;use %s&#x27;</span>, fn.<span class="hljs-property">_name</span> || fn.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;-&#x27;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>use方法接收中间件（即函数），并将其放入middleware数组中；<br>return this，用于支持use的链式调用；</p><h6 id="3-1-2-listen"><a href="#3-1-2-listen" class="headerlink" title="3.1.2 listen"></a>3.1.2 listen</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;listen&#x27;</span>);<br>  <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>  <span class="hljs-keyword">return</span> server.<span class="hljs-title function_">listen</span>(...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>koa提供的服务，本质上是nodejs的http模块提供的。koa定义了自己的callback函数用来接收请求和返回结果；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onerror</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createContext</span>(req, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> handleRequest;<br>&#125;<br></code></pre></td></tr></table></figure><p>compose函数是koa-compose提供的，其作用是将多个中间件整理成一个中间件，在此中间件内部，原来的多个中间件的执行过程是洋葱式的；<br>createContext的作用是封装req,res为一个context对象，该对象经handleRequest函数传入每一个中间件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = ctx.<span class="hljs-property">res</span>;<br>  res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onerror</span> = err =&gt; ctx.<span class="hljs-title function_">onerror</span>(err);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResponse</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">respond</span>(ctx);<br>  <span class="hljs-title function_">onFinished</span>(res, onerror); <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx).<span class="hljs-title function_">then</span>(handleResponse).<span class="hljs-title function_">catch</span>(onerror);<br>&#125;   <br></code></pre></td></tr></table></figure><p>当所有中间件执行完毕，调用handleResponse函数，来返回结果</p><h5 id="3-2-context-js"><a href="#3-2-context-js" class="headerlink" title="3.2 context.js"></a>3.2 context.js</h5><p>包含createContext的返回对象相关的一些方法</p><h5 id="3-3-request-js"><a href="#3-3-request-js" class="headerlink" title="3.3 request.js"></a>3.3 request.js</h5><p>基于http.createServer中callback内的参数 req，封装了一些方法</p><h5 id="3-4-response-js"><a href="#3-4-response-js" class="headerlink" title="3.4 response.js"></a>3.4 response.js</h5><p>基于http.createServer中callback内的参数 res，封装了一些方法</p><h4 id="四：最简实现"><a href="#四：最简实现" class="headerlink" title="四：最简实现"></a>四：最简实现</h4><p>假设不考虑参数验错，req和res封装等，最简的类koa模型应该具备以下特征</p><ul><li>支持增加中间件</li><li>中间件的执行流程为洋葱式</li><li>context传入每个中间件，以实现中间件间的数据共享</li><li>具备处理各种事件的能力，如error事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Emitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-compose&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleKoa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Emitter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>        server.<span class="hljs-title function_">listen</span>(...args);<br>    &#125;<br><br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenrCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br>        <span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> ctx = &#123;<br>                req,<br>                res<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handleRequest;<br>    &#125;<br><br>    <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
