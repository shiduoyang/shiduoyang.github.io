<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nginx-配置loadbalance</title>
    <link href="/2024/03/29/nginx-%E9%85%8D%E7%BD%AEloadbalance/"/>
    <url>/2024/03/29/nginx-%E9%85%8D%E7%BD%AEloadbalance/</url>
    
    <content type="html"><![CDATA[<h2 id="loadbanlance配置"><a href="#loadbanlance配置" class="headerlink" title="loadbanlance配置"></a>loadbanlance配置</h2><p>nginx用upsream模块来实现负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs config">http &#123;<br>    upstream backend &#123;<br>        server 192.168.1.100:80;<br>        server 192.168.1.101:80;<br>    &#125;<br><br>    server &#123;<br>        listen 80;<br><br>        location / &#123;<br>            proxy_pass http://backend;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>中间件-sqs</title>
    <link href="/2024/03/29/%E4%B8%AD%E9%97%B4%E4%BB%B6-sqs/"/>
    <url>/2024/03/29/%E4%B8%AD%E9%97%B4%E4%BB%B6-sqs/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>amazon simple queue service 亚马逊提供的完全托管式消息队列服务</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>完全托管</li><li>可靠性</li><li>持久性</li><li>分布式，可扩展性</li><li>消息队列模型</li><li>消息确认机制</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>与rabbitMQ相似</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AWS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;aws-sdk&#x27;</span>);<br><br><span class="hljs-comment">// 设置 AWS 配置</span><br><span class="hljs-variable constant_">AWS</span>.<span class="hljs-property">config</span>.<span class="hljs-title function_">update</span>(&#123; <span class="hljs-attr">region</span>: <span class="hljs-string">&#x27;your-region&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 创建 SQS 服务对象</span><br><span class="hljs-keyword">const</span> sqs = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">AWS</span>.<span class="hljs-title function_">SQS</span>(&#123; <span class="hljs-attr">apiVersion</span>: <span class="hljs-string">&#x27;2012-11-05&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 定义要发送的消息内容</span><br><span class="hljs-keyword">const</span> params = &#123;<br>  <span class="hljs-title class_">MessageBody</span>: <span class="hljs-string">&#x27;Hello from Node.js!&#x27;</span>,<br>  <span class="hljs-title class_">QueueUrl</span>: <span class="hljs-string">&#x27;your-queue-url&#x27;</span> <span class="hljs-comment">// 替换为你的队列 URL</span><br>&#125;;<br><br><span class="hljs-comment">// 发送消息到队列</span><br>sqs.<span class="hljs-title function_">sendMessage</span>(params, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Error&quot;</span>, err);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message sent successfully&quot;</span>, data.<span class="hljs-property">MessageId</span>);<br>  &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AWS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;aws-sdk&#x27;</span>);<br><br><span class="hljs-comment">// 设置 AWS 配置</span><br><span class="hljs-variable constant_">AWS</span>.<span class="hljs-property">config</span>.<span class="hljs-title function_">update</span>(&#123; <span class="hljs-attr">region</span>: <span class="hljs-string">&#x27;your-region&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 创建 SQS 服务对象</span><br><span class="hljs-keyword">const</span> sqs = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">AWS</span>.<span class="hljs-title function_">SQS</span>(&#123; <span class="hljs-attr">apiVersion</span>: <span class="hljs-string">&#x27;2012-11-05&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 定义接收消息的参数</span><br><span class="hljs-keyword">const</span> params = &#123;<br>  <span class="hljs-title class_">QueueUrl</span>: <span class="hljs-string">&#x27;your-queue-url&#x27;</span>, <span class="hljs-comment">// 替换为你的队列 URL</span><br>  <span class="hljs-title class_">MaxNumberOfMessages</span>: <span class="hljs-number">10</span>,     <span class="hljs-comment">// 最多获取 10 条消息</span><br>  <span class="hljs-title class_">VisibilityTimeout</span>: <span class="hljs-number">30</span>,       <span class="hljs-comment">// 消息可见性超时时间（秒）</span><br>  <span class="hljs-title class_">WaitTimeSeconds</span>: <span class="hljs-number">0</span>           <span class="hljs-comment">// 等待时间（秒），设置为 0 表示立即返回</span><br>&#125;;<br><br><span class="hljs-comment">// 接收消息</span><br>sqs.<span class="hljs-title function_">receiveMessage</span>(params, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Error&quot;</span>, err);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">Messages</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received messages:&quot;</span>, data.<span class="hljs-property">Messages</span>);<br><br>    <span class="hljs-comment">// 处理接收到的消息</span><br>    data.<span class="hljs-property">Messages</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message:&quot;</span>, message.<span class="hljs-property">Body</span>);<br>    &#125;);<br><br>    <span class="hljs-comment">// 删除已接收的消息</span><br>    <span class="hljs-keyword">const</span> deleteParams = &#123;<br>      <span class="hljs-title class_">QueueUrl</span>: params.<span class="hljs-property">QueueUrl</span>,<br>      <span class="hljs-title class_">ReceiptHandle</span>: data.<span class="hljs-property">Messages</span>[<span class="hljs-number">0</span>].<span class="hljs-property">ReceiptHandle</span> <span class="hljs-comment">// 删除第一条消息的句柄</span><br>    &#125;;<br>    sqs.<span class="hljs-title function_">deleteMessage</span>(deleteParams, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Delete Error&quot;</span>, err);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message Deleted&quot;</span>, data);<br>      &#125;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;No messages available&quot;</span>);<br>  &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>中间件</title>
    <link href="/2024/03/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2024/03/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ol><li>kafka 高吞吐量的订阅发布消息系统，被用来处理大规模的数据流。其发布订阅是拉的，消费者用定期轮询的方式来获得消息</li><li>rabbitMQ 开源消息代理，用于在不同的系统间异步通信。其发布订阅是推的，有rabbitMQ推送给消费者，因此可以实现消息实时传递</li><li>sqs (amazon simple queue service) 亚马逊提供的完全托管式消息队列服务</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跟我学golang 1:语法与特性</title>
    <link href="/2024/03/06/%E8%B7%9F%E6%88%91%E5%AD%A6golang-1-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%89%B9%E6%80%A7/"/>
    <url>/2024/03/06/%E8%B7%9F%E6%88%91%E5%AD%A6golang-1-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h2><ol><li>静态类型：有利于类型安全</li><li>编译型：go代码直接翻译成机器码，运行速度快</li><li>并发编程：通过goruntines 和 channel，内建对并发的支持</li><li>自动垃圾回收</li><li>反射</li><li>语法简洁</li><li>函数多返回值</li><li>标准库丰富</li><li>跨平台：支持多种操作系统和架构，可以在不同的系统上编译运行</li></ol><h2 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h2><ol><li>高性能：go的性能接近于C++</li><li>快速开发：因语法简洁，标准库丰富，开发速度快</li><li>工程化：内置工具链，如格式化，编译，测试工具</li><li>易于部署：编译后的可执行文件不需要依赖库或虚拟环境</li></ol><h2 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h2><ol><li>错误处理较为繁琐，需要显示的检查错误</li><li>包管理系统不如其他语言成熟</li><li>图形界面方面的支持不如其他语言</li></ol><h2 id="4-语法"><a href="#4-语法" class="headerlink" title="4. 语法"></a>4. 语法</h2><p><a href="!https://tour.go-zh.org/flowcontrol/11">go语言之旅</a></p><ol><li>变量声明 var a int &#x3D; 1; b:&#x3D;2; const Pi &#x3D; 3.14;</li><li>数据类型:<br>bool<br>string<br>int  int8  int16  int32  int64<br>uint uint8 uint16 uint32 uint64 uintptr<br>float32 float64<br>complex64 complex128 复述<br>byte &#x2F;&#x2F; uint8 的别名<br>rune &#x2F;&#x2F; int32 的别名</li><li>数据结构<ol><li>指针：去掉指针运算的C指针</li><li>结构体：结构体就是一组字段 type Person struct {x int; y int}; p:&#x3D; Person{1,2} fmt.Println(p.x)</li><li>数组：数组的大小固定 var a [10]int; primes :&#x3D; [6]int{2, 3, 5, 7, 11, 13}</li><li>切片：为数组提供动态灵活的视角，就像数组的引用 var s []int &#x3D; primes[1:4]; <ol><li>定义：从数组中建立：var s []int &#x3D; primes[1:4];</li><li>定义：文法：q :&#x3D; []int{2, 3, 5, 7, 11, 13}</li><li>定义：make: a :&#x3D; make([]int, 0, 5)  &#x2F;&#x2F; len(a)&#x3D;0 cap(a) &#x3D; 5</li><li>切片的容量，是切片第一个访问的数据起，一直到原数组的末尾包含的元素数</li></ol></li><li>映射：map[string]string{“a”:”a”}</li></ol></li><li>流程控制<ol><li>循环 for i:&#x3D;0; i&lt;10;i++ {} ;  for {} ;  for i,v :&#x3D; range(arr)</li><li>判断 if a &lt; 0 {}; if a:&#x3D; 1+1; a &gt; 1 {}</li><li>switch a {case a: xxxxx }</li><li>defer 将函数推迟到外层函数返回后执行。其参数会立即求值，但延迟调用。通常用来做函数结束时的必须动作.多个defer，后进先出</li></ol></li><li>函数：独立的代码块<ol><li>函数作为参数传递</li><li>闭包</li></ol></li><li>方法：绑定到某类型上的函数 <ol><li>type Person struct{}; </li><li>func (p Person) say() string {return ‘hi, im’+p.name}</li><li>func (p *Person) setName(s string) void {p.name &#x3D; s}</li><li>指针接收者访问调用者本身，值接收者访问调用者的副本</li><li>选择指针作为函数接收者的原因<ol><li>避免复制</li><li>可直接修改调用者的属性</li></ol></li></ol></li><li>接口：一组方法定义的集合<ol><li>类型通过实现接口定义的所有方法的形式来实现该接口，不需要通过implements显式声明</li><li>空接口可以保存任何值，因为任何值都实现了0个方法</li><li>类型断言 var i interface{} &#x3D; MyStruct{“hello”}; s,ok:&#x3D; i.(MyStruct); switch i.(type){case xxxx}</li><li></li></ol></li><li>并发编程</li><li>错误处理和异常机制<ol><li>error 类型是一个内建接口</li></ol></li><li>包的导入与管理</li><li>指针与内存分配</li><li>方法定义于接收者？</li><li>defer panic recover 用于异常处理与资源释放</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx-配置一个http服务</title>
    <link href="/2024/02/28/nginx-%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAhttp%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/02/28/nginx-%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAhttp%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> serverPort = <span class="hljs-number">9006</span>;<br><span class="hljs-keyword">const</span> serverUrl = <span class="hljs-string">&#x27;dev-fb-instant.bubbleshootermvp.com&#x27;</span>;<br><span class="hljs-keyword">const</span> conf = <span class="hljs-string">`server &#123;</span><br><span class="hljs-string">    listen 80;</span><br><span class="hljs-string">    server_name <span class="hljs-subst">$&#123;serverUrl&#125;</span>;</span><br><span class="hljs-string">    client_max_body_size 10m;</span><br><span class="hljs-string">    charset utf-8;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    gzip on;</span><br><span class="hljs-string">    gzip_min_length 1k;</span><br><span class="hljs-string">    gzip_buffers 4 16k;</span><br><span class="hljs-string">    gzip_http_version 1.0;</span><br><span class="hljs-string">    gzip_comp_level 2;</span><br><span class="hljs-string">    gzip_types text/plain application/javascript application/x-javascript text/css text/javascript application/xml application/json;</span><br><span class="hljs-string">    gzip_vary on;</span><br><span class="hljs-string">    gzip_proxied off;</span><br><span class="hljs-string">    gzip_disable msie6;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    location / &#123;</span><br><span class="hljs-string">        proxy_pass http://127.0.0.1:<span class="hljs-subst">$&#123;serverPort&#125;</span>;</span><br><span class="hljs-string">        proxy_set_header Host $http_host;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;`</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dynaomdb如何存储超过400kb的项</title>
    <link href="/2024/02/18/dynaomdb%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E8%B6%85%E8%BF%87400kb%E7%9A%84%E9%A1%B9/"/>
    <url>/2024/02/18/dynaomdb%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E8%B6%85%E8%BF%87400kb%E7%9A%84%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<ol><li>将数据拆分成多个项， 为每个部分创建唯一标识符，确保能够关联和重组数据</li><li>将大对象，拆到其他系统中，如S3，然后在dynamodb中存储数据的引用地址</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-性能</title>
    <link href="/2024/01/20/mysql-%E6%80%A7%E8%83%BD/"/>
    <url>/2024/01/20/mysql-%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-锁</title>
    <link href="/2024/01/20/mysql-%E9%94%81/"/>
    <url>/2024/01/20/mysql-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>mysql innodb的锁，是加在了索引上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql大表如何dump</title>
    <link href="/2024/01/17/mysql%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95dump/"/>
    <url>/2024/01/17/mysql%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95dump/</url>
    
    <content type="html"><![CDATA[<h2 id="一：思路"><a href="#一：思路" class="headerlink" title="一：思路"></a>一：思路</h2><ol><li>不要锁表</li><li>谨防数据一下全部入内存</li><li>在非访问高峰期进行</li><li>增加dump速度</li></ol><h2 id="二：可选方案"><a href="#二：可选方案" class="headerlink" title="二：可选方案"></a>二：可选方案</h2><ol><li>使用<code>--single-transaction</code>选项。启动事务来保证数据的一致性，同时不会锁表<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqldump --single-transaction -u 用户名 -p 数据库名 表名 &gt; 大表备份.sql<br></code></pre></td></tr></table></figure></li><li>使用<code>--quick</code>选项，逐行获取数据，而不是将整个结果集加载到内存中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqldump --quick -u 用户名 -p 数据库名 表名 &gt; 大表备份.sql<br></code></pre></td></tr></table></figure></li><li>使用<code>--compress</code>选项，对远程数据库服务器进行备份时，该选项可以减少传输数据量<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqldump --compress -u 用户名 -p 数据库名 表名 &gt; 大表备份.sql<br></code></pre></td></tr></table></figure></li><li>使用<code>--where</code>来分割数据导出，这样可以将一个大表分成多个部分备份。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqldump --<span class="hljs-built_in">where</span>=<span class="hljs-string">&quot;id &lt; 1000000&quot;</span> -u 用户名 -p 数据库名 表名 &gt; 大表部分1.sql<br></code></pre></td></tr></table></figure></li><li>使用mydumper&#x2F;myloader工具，支持多线程导出和导入，可以加快备份和恢复过程</li></ol>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bash-安装stablediffusion</title>
    <link href="/2024/01/17/bash-%E5%AE%89%E8%A3%85stablediffusion-mac/"/>
    <url>/2024/01/17/bash-%E5%AE%89%E8%A3%85stablediffusion-mac/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span><br>/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span><br>brew install cmake protobuf rust python@3.10 git wget<br><span class="hljs-built_in">cd</span> ~/Documents<br><span class="hljs-built_in">mkdir</span> stabledf<br><span class="hljs-built_in">cd</span> stabledf<br>git config --blobal http.postBuffer 524288000<br>git <span class="hljs-built_in">clone</span> https://github.Com/AUTOMATIC1111/stable-diffusion-webui<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>bash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stablediffusion</tag>
      
      <tag>bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang-自学笔记-1-基本语法和数据类型</title>
    <link href="/2024/01/17/golang-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/01/17/golang-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-学习笔记-1-基本语法和数据类型"><a href="#golang-学习笔记-1-基本语法和数据类型" class="headerlink" title="golang-学习笔记-1-基本语法和数据类型"></a>golang-学习笔记-1-基本语法和数据类型</h1>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang-自学路径</title>
    <link href="/2024/01/17/golang-%E8%87%AA%E5%AD%A6%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/01/17/golang-%E8%87%AA%E5%AD%A6%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<ol><li>入门<ol><li>基本语法和数据类型<ol><li>变量，常量，基本数据类型，运算符等</li><li>流程控制语句</li><li>函数，方法，结构体，接口等面向对象的概念</li></ol></li><li>标准库和常用包<ol><li>fmt,bufio,os,io等常用包</li><li>net,http等网络编程常用包</li><li>database&#x2F;sql、redis等DB常用包</li></ol></li></ol></li><li>深入<ol><li>并发编程<ol><li>了解Golang的协程、通道等并发编程基础</li><li>学习锁、互斥量等同步原语</li><li>学习使用goroutine实现高并发程序</li></ol></li><li>网络编程<ol><li>了解TCP&#x2F;IP协议相关的知识</li><li>掌握Golang的socket编程</li><li>学习HTTP协议和Web编程</li></ol></li><li>高级特性<ol><li>了解Golang的垃圾回收机制</li><li>学习反射和接口的高级应用</li><li>学习Golang的Cgo扩展</li></ol></li></ol></li><li>实战<ol><li>web框架</li></ol></li></ol><p>参考书目：</p><ul><li>《Go语言编程》</li><li><img src="https://golang.org/doc/effective_go.html" alt="官方文档"></li><li>《Go标准库》</li><li>《Go语言高并发编程》</li><li>《Go语言并发编程实战》</li><li><img src="https://golang.org/doc/effective_go.html#concurrency" alt="官方文档"></li><li>《Go Web编程》</li><li><img src="https://golang.org/pkg/net/" alt="官方文档"></li><li>《Go语言高级编程》</li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试-restful api</title>
    <link href="/2023/11/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-restful-api/"/>
    <url>/2023/11/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-restful-api/</url>
    
    <content type="html"><![CDATA[<p>restful API具体的HTTP方法和含义如下：</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>put与patch的区别：<br>put是更新整个资源，patch是更新部分资源</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试-Redis</title>
    <link href="/2023/11/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-Redis/"/>
    <url>/2023/11/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-Redis/</url>
    
    <content type="html"><![CDATA[<ol><li>redis是什么<br>一个高性能内存数据库，数据也可以写入磁盘中意保证数据的不丢失，而且redis的操作是原子性的</li><li>redis的优缺点<br>优点：<ol><li>基于内存操作，速度快</li><li>支持多种数据类型</li><li>支持持久化 RDB 和 AOF</li><li>支持事务，其操作都是原子性的，同时redis还支持对几个操作合并之后的原子性执行</li><li>支持主从复制<br>缺点：</li><li>对结构化查询的支持比较差</li><li>数据库容量受内存容量的限制</li><li>很难支持在线扩容</li></ol></li><li>redis为什么这么快<ol><li>基于内存</li><li>IO多路复用模型</li><li>高效的数据结构，对数据类型底层做了优化，目的是为了追求更快的速度</li></ol></li><li>redis的线程模型<br>多个套接字、IO多路复用程序、文件事件分派器、事件处理器。<br>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型<br>文件事件处理器使用I&#x2F;O多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。<br>当被监听的套接字准备好执行连接accept、read、write、close等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件<br>虽然文件事件处理器以单线程方式运行， 但通过使用 I&#x2F;O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</li><li>redis的应用场景<ol><li>缓存热点数据</li><li>计数器</li><li>分布式锁</li><li>简单的消息队列，用redis自身的发布订阅模式或者list来实现简单的消息队列，实现一步操作</li><li>限速器，比方说限制某个用户访问某个接口的频率</li><li>好友关系：利用集合的一些命令，实现共同好友，共同爱好之类的功能</li></ol></li><li>redis与memcached的区别<br>memcached数据结构单一，仅用来缓存数据，二reddis支持多种数据类型。<br>memcached不支持持久化，redis支持<br>Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。<br>Redis 的速度比 Memcached 快很多。Redis 使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞 IO 模型。（Redis6.0引入了多线程IO，用来处理网络数据的读写和协议解析，但是命令的执行仍然是单线程）<br>value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。</li></ol><p>6.Redis 数据类型有哪些？<br>    基本数据类型：<br>    1、String：最常用的一种数据类型，String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。<br>    2、Hash：Hash 是一个键值对集合。<br>    3、Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。<br>    4、List：有序可重复的集合，底层是依赖双向链表实现的。<br>    5、SortedSet：有序Set。内部维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。<br>    特殊的数据类型：<br>    1、Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。Bitmap的长度与集合中元素个数无关，而是与基数的上限有关。<br>    2、Hyperloglog。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。<br>    3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。</p><ol start="7"><li><p>Redis的内存用完了会怎样？如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回）。也可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p></li><li><p>Redis如何做内存优化？<br>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。</p></li><li><p>keys命令存在的问题？<br>redis的单线程的。keys指令会导致线程阻塞一段时间，直到执行完毕，服务才能恢复。scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是O(1)，但是要真正实现keys的功能，需要执行多次scan。<br>scan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会有以下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键。</p></li><li><p>Redis事务事务的原理是将一个事务范围内的若干命令发送给Redis，然后再让Redis依次执行这些命令。</p></li><li><p>redis的数据结构有哪些</p><ul><li>string</li><li>hash</li><li>set</li><li>zset</li><li>list</li></ul></li><li><p>redis为什么这么快</p><ol><li>基于内存</li><li>I&#x2F;O多路复用技术，支持并发的连接</li><li>且用一个线程处理所有的命令。<br> <strong>省去了山下文切换的时间，不用考虑锁的问题；且可处理并发的连接</strong><br> 基于I&#x2F;O多路复用机制的线程模型，可以处理并发的连接<br> * 文件处理器包含四个部分（接收请求，放队列，每次拿一个，处理）<br>     1. 多个socket<br>     2. IO多路复用程序（用来接收各种请求）<br>     3. 文件事件分派器<br>     4. 事件处理器（命令请求处理器，命令回复处理器，命令应答处理器）<br> * “多路”指的是多个网络连接；“复用”指的是复用同一个线程<br> * 多路I&#x2F;O复用模型是利用select，poll,epoll可以同时检查多个流的I&#x2F;O的能力</li><li>在数据存储时会有选择的使用不同的底层数据结构<ol><li>list在容量较小时，存成zipList,否则linkedList</li><li>hash在容量较小时，也会存成ziplist，否则存成hashtable</li><li>zset在容量较小时，也会存成ziplist, 否则存成skipList, 同时保存在字典和跳跃表中</li></ol></li></ol></li><li><p>为什么redis是单线程</p><ul><li>用一个线程来处理所有网络请求</li></ul></li><li><p>redis是单线程，如何发挥多核CPU的优势</p><ul><li>在单机开多个redis实例</li></ul></li><li><p>select poll epoll 了解吗<br> 他们都是IO多路复用的机制</p><ul><li>select  事件驱动模型只用单线程执行，适合创建一个简单的事件驱动的服务器程序，它有最大连接数的限制</li><li>pool 原理与select相似，他没有最大连接数的限制</li><li>epoll 是一种I&#x2F;O事件通知机制，是linux内核实现IO多路复用的一个实现。I&#x2F;O多路复用是：在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，单后对其操作<br> 效率更高：select pool 都是用轮训的方式，epoll是事件通知的形式</li></ul></li><li><p>skipList的结构了解吗？</p><ul><li>skiplist的结构，是在有序的链表之上建立索引</li><li>其查找的时间复杂度，是log2n</li></ul></li><li><p>redis缓存穿透，击穿，雪崩是什么，该如何解决</p><ul><li>缓存穿透：找一个缓存中没有的数据，只能去DB查<ul><li>解决：缓存空对象</li><li>解决2：布隆过滤器（用某比特位表示key是否存在，需要对某key进行hash计算得到一个位的位置）</li></ul></li><li>缓存击穿：缓存键过期时，大量的请求穿过缓存，进入DB<ul><li>key永不过期</li><li>分布式锁，同时只有一个请求重新加载热点数据到缓存中，其他的等待（同时只能有一个请求获取到该key的锁进行查询）</li></ul></li><li>缓存雪崩：大量的键过期<ul><li>将每个key的过期时间打散</li></ul></li></ul></li><li><p>redis的应用场景</p><ol><li>做缓存</li><li>做排行榜</li><li>当锁</li></ol></li><li><p>redis的持久化</p><ol><li>rdb </li><li>aof</li></ol></li><li><p>redis的过期策略和淘汰策略</p><ol><li>过期策略：处理键过期<ul><li>定时删除：设定过期时间时创建个定时器</li><li>惰性删除：每次取key时检查该key是否过期</li><li>定期删除：每隔一段时间删</li></ul></li><li>淘汰策略：处理当内存满的时候，删除数据用<ul><li>默认策略：不删除，拒绝写入，并报错</li><li>allkeys-lru: 所有key用最近最少使用（LRU）淘汰</li><li>allkeys-lfu：所有key用最不常用算法淘汰</li><li>volatile-lru： 从设置了过期时间的 key 中使用 LRU 算法进行淘汰；</li><li>volatile-lfu： 从设置了过期时间的 key 中使用 LFU 算法进行淘汰；</li><li>allkeys-random： 从所有 key 中随机淘汰数据；</li><li>volatile-random： 从设置了过期时间的 key 中随机淘汰数据；</li><li>volatile-ttl： 在设置了过期时间的key中，淘汰过期时间剩余最短的。</li></ul></li></ol></li><li><p>管道pipline</p><ol><li>管道 从请求上或者响应上批量处理</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试-编码规范</title>
    <link href="/2023/11/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2023/11/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<ol><li><p>编程规范的目的</p><ol><li>提高可读性，方便后续的迭代</li><li>编程人员不再绑定到某一个项目，因熟悉代码的成本降低，编程人员可以随时替换</li><li>提高安全性和可用性，把相关规则写入编程规范来减少高风险代码的产生</li></ol></li><li><p>编程规范的包含的内容有哪些</p><ol><li>编程风格，包括命名，空格和换行，函数编写尽快返回，注释，异常处理，&#x3D;&#x3D;&#x3D;<ol><li>命名：变量，类名，文件名</li><li>空格和换行：什么时候加空格，什么时候换行</li><li>函数编写的原则：如尽快返回</li><li>怎么写注释，注释的更新与删除</li><li>怎么处理异常：如避免在for循环中try catch, 异常不要用来做流程控制，捕获异常一定要处理&#x3D;&#x3D;&#x3D;</li></ol></li><li>扩展性，如模块化，封装与继承</li><li>日志：日志保存多久（如两周），不要在日志产生的服务中读取日志，而应该使用日志分析工具来做&#x3D;&#x3D;&#x3D;</li><li>安全：用户输入的参数必须做合法性校验</li><li>数据库：命名，字段类型选择，索引，页面搜索严格禁止左模糊或全模糊&#x3D;&#x3D;&#x3D;</li></ol></li><li><p>几个具体的编程规范</p><ol><li>函数尽快返回</li><li>避免在for循环中try catch 这样性能比较低</li><li>用户的输入必须做合法性校验</li><li>数据库查询尽量避免使用select * ,应改成实际需要的字段</li></ol></li><li><p>node.js实现编程规约的工具有哪些</p><ol><li>eslint&#x2F;tslint</li><li>文档</li></ol></li></ol><p>参考：</p><ol><li>阿里巴巴编程规约</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试-k8s</title>
    <link href="/2023/11/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-k8s/"/>
    <url>/2023/11/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-k8s/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是etcd</li><li>etcd的应用场景</li><li>什么是kubernetes</li><li>kubernetes与docker的关系</li><li>kubernetes如何实现集群管理</li><li>kubernetes的优势，适用场景及特点</li><li>kubernetes的缺点和当前的不足</li><li>kubernetes基础概念有哪些</li><li>kubernetes集群相关组件有哪些</li><li>kube-proxy的作用</li><li>kubernetes创建一个pod的主要流程是什么</li><li>kubernetes中pod的重启策略</li><li>kubernetes中的ingress对象<br>ingress将不同url分发到后端不同的service，以实现http层的业务路由机制</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试-CI-CD</title>
    <link href="/2023/11/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-CI-CD/"/>
    <url>/2023/11/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-CI-CD/</url>
    
    <content type="html"><![CDATA[<ol><li><p>CI&#x2F;CD是什么？<br>持续集成&#x2F;持续交付</p></li><li><p>常见的CI&#x2F;CD工具有哪些</p><ol><li>Jenkins</li><li>Gitlab</li><li></li></ol></li><li><ol><li>docker 容器化工具</li><li>Jenkins 持续集成工具</li><li>jira敏捷的团队协作工具</li><li>Prometheus 监控工具</li><li>Selenium&#x2F;jmeter –连续测试（CT）工具</li><li>argocd k8s的gitops工具。GitOps 是一种机制，可以从最后已知的 Git 提交版本中拉取最新的代码和应用程序配置，并将其直接部署到 Kubernetes 资源中。ArgoCD基于拉的机制</li></ol></li></ol><p>4 您能列举一些最常用的DevOps工具吗？<br>答：以下是一些使用最广泛的DevOps工具的列表：</p><p>Ansible&#x2F;Puppet&#x2F;chef&#x2F;saltstack –配置管理和应用程序部署工具<br>Docker –容器化工具<br>Git&#x2F;Gitlab –版本控制系统（VCS）工具<br>Jenkins –持续集成（CI）工具<br>Nexus - 制品库管理工具<br>Jira –敏捷的团队协作工具<br>wiki -文档管理工具<br>Promtheus –连续监控工具<br>Selenium&#x2F;jmeter –连续测试（CT）工具<br>spug - 开源运维平台</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试十:nginx</title>
    <link href="/2023/11/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8D%81-nginx/"/>
    <url>/2023/11/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8D%81-nginx/</url>
    
    <content type="html"><![CDATA[<p>nginx使用的是事件模型，关键词：epoll IO多路复用</p><p>动静分离</p><p>负载均衡算法：</p><ol><li>轮询</li><li>权重</li><li>IPhash</li><li>fair 第三方插件，可根据页面大小和加载时间长短智能的进行负载均衡，响应时间短的优先分配</li><li>url hash，相同url的分配到同一个服务器</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试二:mongodb</title>
    <link href="/2023/11/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%BA%8C-mongodb/"/>
    <url>/2023/11/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%BA%8C-mongodb/</url>
    
    <content type="html"><![CDATA[<h2 id="问题列表及答案"><a href="#问题列表及答案" class="headerlink" title="问题列表及答案"></a>问题列表及答案</h2><ol><li><p>Mongodb的架构</p><ol><li>mongodb server</li><li>存储引擎</li></ol></li><li><p>Mongodb支持的存储引擎<br> mongodb采用了可插拔的存储引擎API，允许第三方为mongodb开发存储引擎，存储引擎有如下几种：</p><ul><li>MMAPV1 刚出来的时候用的存储引擎，4.x版本之后不再使用</li><li>WiredTiger 3.2之后，默认存储引擎编程WiredTiger</li><li>In-Memory 存储引擎，将数据不再放到磁盘上，存储在内存中</li></ul></li><li><p>Mongodb是如何组织数据的？<br> WiredTiger引擎用B+树组织磁盘上的数据</p></li><li><p>单机Mongodb下，一条查询sql的执行过程</p><ol><li>生成查询计划：根据查询条件和索引信息生成查询计划，查询计划是一个查询执行的路线图</li><li>查询优化：查询优化器根据查询计划和数据库的统计信息选择最佳的执行策略。</li><li>索引扫描：判断查询条件能否用到索引，如果能用到，会进行索引扫描以快速定位到文档</li><li>数据检索：根据查询条件从磁盘中读取对应文档数据。</li><li>结果返回：将对应文档数据返回给应用程序</li></ol></li><li><p>Mongodb的锁了解吗<br> MongoDB 允许多个客户端读写相同的数据。为了确保一致性，MongoDB 使用锁定和并发控制来防止客户端同时修改相同的数据。对单个文档的写入要么完整发生，要么根本不发生，并且客户端始终看到一致的数据。<br> MongoDB 使用多粒度锁定，允许操作锁定在全局、数据库或集合级别，并允许各个存储引擎在集合级别以下（例如，在 WiredTiger 中的文档级别）实现自己的并发控制。</p></li><li><p>Mongodb的事务了解吗？分布式事务了解吗</p><ol><li>与关系型数据库一样，MongoDB 事务同样具有 ACID 特性。MongoDB 单文档原生支持原子性，也具备事务的特性。</li><li>MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说事务的作用域限制为一个副本集内。MongoDB </li><li>4.2 引入了分布式事务，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。<br> <strong>6.1 mongodb分布式事务的实现原理</strong><br> mongodb使用两段式提交来实现分布式事务</li><li>准备阶段：分布式事务协调器向所有参与者发送准备请求，参与者收到以后执行，并返回操作结果。如果所有参与者都表示操作成功，那么分布式事务协调器发送提交请求</li><li>提交阶段：参与者执行提交命令，并反馈操作结果，分布式事务协调器根据操作结果判断是否提交事务</li></ol><p> <strong>6.1 mongodb分布式事务如何提高并发性</strong><br> mongodb使用乐观并发控制来提高并发性。简单来说先操作，提交前对数据进行版本控制，提交时校验版本判断是否应该继续执行。</p></li><li><p>Mongodb的聚合了解吗？Mapreduce的应用场景是什么<br> 应用场景：</p><ol><li>生成复杂的报表</li><li>计算指标和检测KPI</li><li>图像识别</li><li>LOT设备管理与监控</li></ol></li><li><p>Mongodb备份与恢复原理</p><ol><li>冷备份：创建数据文件的副本，前提是要停止服务器</li><li>热备份：运行时备份 mongodump与mongorestore</li><li>fsync和锁方式备份：fsync强制将缓冲区的数据写入磁盘，锁阻塞所有写入操作，直到备份完成</li><li>从属备份：在从服务器上备份</li></ol></li><li><p>Mongodb主从复制原理，复制集了解吗<br> oplog记录了主节点上所有的写操作，从节点定期轮询oplog，以获取最新的写操作。从节点将oplog的写操作应用到自己的数据集中，以保持与主节点的数据同步。如果主节点发生故障，副本集会基于raft协议选出新的主节点<br> raft协议：相关角色有领导者，候选者，跟随者。</p></li><li><p>Mongodb的分片了解吗<br>分片是一种水平扩展的方式，将数据集分布在多个服务器上。</p></li><li><p>Mongodb实现高可用的手段有哪些？</p><ol><li>副本集和分片机制来实现数据的高可用和水平扩展。副本集是把数据复制到多个节点上，保证数据的冗余和可用性；分片是将数据划分为多个片段，分散在不同节点上，实现数据的水平扩展。复制集是一个可自动处理故障的主备库集群</li><li>监控，如Prometheus</li></ol></li><li><p>Mongodb与mysql如何选择</p><ol><li>数据模型是什么，如果需要灵活的数据模型，选择mongodb</li><li>数据一致性，如果需要强一致性和事务支持，选择MySQL</li><li>处理规模，如果需要处理海量和高并发请求，选择MongoDB</li><li>应用场景，mysql适用于传统的企业业务系统，mongodb适用于实时分析和社交网络</li></ol></li><li><p>Mongodb查询如何优化？慢查询如何定位问题与解决<br>慢查询定位：</p><ol><li>explain查看查询计划</li><li>mongodb查询慢日志</li></ol></li></ol><p>参考：<br><a href="https://www.zhihu.com/tardis/bd/art/571183984?source_id=1001">https://www.zhihu.com/tardis/bd/art/571183984?source_id=1001</a></p>]]></content>
    
    
    <categories>
      
      <category>Mongodb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mongodb</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端面试一-MySQL</title>
    <link href="/2023/11/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-MySQL/"/>
    <url>/2023/11/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95-MySQL/</url>
    
    <content type="html"><![CDATA[<p>bin日志与redolog的区别：</p><ol><li>bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志，而 redo log 只记 InnoDB 存储引擎的日志。</li><li>记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。</li><li>写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。</li><li>写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。</li></ol><p>更新sql的执行过程</p><ol><li>找到修改的行后，读到内存，修改内容并同步到内存。</li><li>innodb引擎写redolog，并将这行记录的状态改为prepare</li><li>server层记录binlog</li><li>提交事务，并在redolog中将该行的状态改为commit</li></ol><p>那为什么要两阶段提交呢？<br>为什么要两阶段提交呢？直接提交不行吗？</p><p>我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p><p>优化mysql慢查询</p><ul><li>避免不必要的列</li><li>分页的优化：延迟关联，书签方式</li><li>索引优化：使用覆盖索引，联合索引时符合最左前缀匹配原则，避免用!&#x3D; &lt; &gt;, 避免用函数运算，文本查询通配符尽量避免%xxx%</li><li>join优化：尽量用join替代子查询，子查询会创建一张临时表；关联查询时用小表驱动大表，即小left join 大</li><li>排序优化：设计索引时候，尽量既能满足查询又能满足排序</li></ul><p>explain的type字段<br>type 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。<br>性能从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li>system<br>system：当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘 IO，速度非常快</li><li>const<br>const：表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。</li><li>eq_ref<br>eq_ref：查询时命中主键primary key 或者 unique key索引， type 就是 eq_ref。</li><li>ref_or_null<br>ref_or_null：这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行。</li><li>index_merge<br>index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。</li><li>unique_subquery<br>unique_subquery：替换下面的 IN子查询，子查询返回不重复的集合。</li><li>index_subquery<br>index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。</li><li>range<br>range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用 bettween…and、&lt;、&gt;、&lt;&#x3D;、in 等条件查询 type 都是 range。</li><li>index<br>index：Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。</li><li>ALL 全表扫描。</li></ul><p>Extra 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：<br>Using index：表示 MySQL 将使用覆盖索引，以避免回表<br>Using where：表示会在存储引擎检索之后再进行过滤<br>Using temporary ：表示对查询结果排序时会使用一个临时表。</p><p>索引失效的场景：</p><ol><li>不满足最左前缀匹配原则</li><li>查询条件用了&gt;&lt;!&#x3D;,函数计算</li><li>隐式类型转换，如查询条件的值是个字符串，但没有用引号包裹</li><li>mysql优化器判断全表扫描比用索引还快</li></ol><p>聚簇索引和非聚簇索引的区别</p><ol><li>聚簇索引叶子结点保存的是数据行，非聚簇索引叶子结点保存的不是数据行，而是主键的ID</li></ol><p>回表查询<br>在辅助索引上查出来主键值后，在主键索引上再查一遍得到数据行的操作，叫回表</p><p>覆盖索引<br>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p><p>最左前缀匹配：<br>用name,age建立联合索引，建立索引树时，当name 相等的时候，age才是有序的。<br>这个时候我们使用 where name&#x3D; ‘张三‘ and age &#x3D; ‘20 ‘去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较 age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的时候 name 是第一个比较因子，所以就没用上索引。</p><p>索引下推优化<br>联合索引遇到非等值查询时终止了，之前需要分别回表查询，但有了索引下推，可以在联合索引里判定。<br>如where a like ‘a%’ and b&gt;0 and c &gt;0,且建立了联合索引a,b,c<br>索引下推之前：引擎层like ‘a%’ and b&gt;0 &#x3D;&gt; 回表查询<br>索引下推之前：引擎层like ‘a%’ and b&gt;0 and c &gt;0 &#x3D;&gt; 回表查询</p><p>锁的分类：<br>如果按锁粒度划分，有以下 3 种：<br>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。<br>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。<br>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般<br>如果按照兼容性，有两种，<br>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。<br>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</p><p>说说 InnoDB 里的行锁实现<br>Record Lock 记录锁<br>Gap Lock 间隙锁：间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个左开右开空间，如 1,6都有数据，那么(1,6)是间隙<br>Next-key Lock 临键锁：临键指的是间隙加上它右边的记录组成的左开右闭区间<br>Insert Intention Lock 插入意向锁，锁的是间隙。 一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap 锁 的那个事务提交。</p><p>当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p><p>那 ACID 靠什么保证的呢？<br>MySQL 通过事务管理和持久性存储机制来确保 ACID（原子性、一致性、隔离性和持久性）。<br>01、原子性（Atomicity），undo log 记录了事务发生之前的数据，如果事务失败，InnoDB 会根据 undo log 回滚数据。<br>02、一致性（Consistency）一致性是 ACID 的目的，也就是说，只要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。<br>03、隔离性 (Isolation) MVCC (多版本并发控制) 机制来处理并发事务，确保每个事务都有自己的数据版本。事务查看数据时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。<br>在 MVCC 中，每次更新记录时，都会生成记录的一个新版本，而不是覆盖老版本。每个版本都会有两个额外的属性：一个表示版本的创建时间（或事务ID），另一个表示版本的过期时间（或下一个版本的事务ID）。<br>当事务尝试读取记录时，它会看到该事务开始时有效的那个版本。<br>MVCC 通过提供数据版本来支持事务的隔离性。不同的事务会看到不同版本的数据行，这取决于事务的开始时间和它的隔离级别。<br>04、持久性 (Durability)，由 MySQL 的存储引擎（如InnoDB）通过写入磁盘来确保。即使在系统崩溃之后，已提交事务的更改也不会丢失。<br>InnoDB 使用“redo log”来记录数据的更改，在系统崩溃后，redo log 可用于恢复数据。<br>redo log 是一种物理日志，记录了对数据页的物理更改。当事务进行写操作时，InnoDB 首先会写入 redo log，并不会立即修改数据文件。这种写入方式被称为“write-ahead logging”（先写日志）。</p><p>高可用：</p><p>读写分离</p><p>那读写分离的分配怎么实现呢？</p><ol><li>程序代码封装<br>程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 “中间层封装” ） ，实现读写操作分离和数据库服务器连接的管理<br>如TDDL (Taobao Distributed Data Layer, 外号：头都大了）、基于 Hibernate 进行简单封装</li><li>中间件封装<br>中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。<br>对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。</li></ol><p>主从复制原理了解吗？<br>master 数据写入，更新 binlog<br>master 创建一个 dump 线程向 slave 推送 binlog<br>slave 连接到 master 的时候，会创建一个 IO 线程接收 binlog，并记录到 relay log 中继日志中<br>slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步<br>slave 记录自己的 binglog</p><p>主从同步延迟怎么处理<br>主从同步延迟的原因<br>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致，主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p><p>解决：</p><ol><li>写操作后的读操作指定发给数据库主服务器</li><li>读从机失败后再读一次主机<br>这就是通常所说的 “二次读取” ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。</li><li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li></ol><p>你们一般是怎么分库的呢</p><ol><li>垂直分库：拆表，不同的表在不同库</li><li>水平分库：拆记录，不同行分到不同的库中</li></ol><p>那你们是怎么分表的？</p><ol><li>垂直：拆字段，不同字段分到不同的表中</li><li>水平：拆行，不同行分到不同的表中</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mongodb与mysql如何选择</title>
    <link href="/2023/10/17/mongodb%E4%B8%8Emysql%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/"/>
    <url>/2023/10/17/mongodb%E4%B8%8Emysql%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>数据模型：</p><ol><li>如果需要建立复杂的关系模型，比如多对多关系或者表连接，使用mysql。mysql提供了强大的sql查询语言，能够处理复杂的关系查询。</li><li>如果需要存储动态和非结构化的数据，用mongodb，mongodb的文档模型可以轻松的存储和查询各种类型的数据。</li></ol><p>数据量和性能：<br>3. 如果需要处理大量的结构化数据，且需要高性能和包并发处理，那么用mysql。mysql使用索引和优化技术提供快速的查询和事务处理。<br>4. 如果需要处理大量的非结构话数据，且需要水平扩展能力，用mongodb。mongodb使用分片技术来实现水平扩展，可以处理大规模的数据和高并发请求。</p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http之headers与https概述</title>
    <link href="/2023/09/26/http%E4%B9%8Bheaders%E4%B8%8Ehttps%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/26/http%E4%B9%8Bheaders%E4%B8%8Ehttps%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><h2 id="二：http-header"><a href="#二：http-header" class="headerlink" title="二：http header"></a>二：http header</h2><p>常见字段</p><ol><li>content-type：<ul><li>text&#x2F;html ： HTML格式</li><li>text&#x2F;plain ：纯文本格式</li><li>text&#x2F;xml ： XML格式</li><li>image&#x2F;gif ：gif图片格式</li><li>image&#x2F;jpeg ：jpg图片格式</li><li>image&#x2F;png：png图片格式<br> 以application开头的媒体格式类型：</li><li>application&#x2F;xhtml+xml ：XHTML格式</li><li>application&#x2F;xml： XML数据格式</li><li>application&#x2F;atom+xml ：Atom XML聚合格式</li><li>application&#x2F;json： JSON数据格式</li><li>application&#x2F;pdf：pdf格式</li><li>application&#x2F;msword ： Word文档格式</li><li>application&#x2F;octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application&#x2F;x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）<br> 另外一种常见的媒体格式是上传文件之时使用的：</li><li>multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul></li><li>Authorization 鉴权相关</li><li>Cache-Control 指定请求和响应遵循的缓存机制</li><li>Cookie 为辨别用户身份保存在浏览器的缓存数据</li><li>User-AgentUser-Agent的内容包含发出请求的用户信息如操作系统版本、CPU 类型、浏览器版本等（爬虫相关）</li><li>referer 先前网页的地址，即请求的来路</li></ol><p></p><h2 id="二：http三次握手与四次挥手"><a href="#二：http三次握手与四次挥手" class="headerlink" title="二：http三次握手与四次挥手"></a>二：http三次握手与四次挥手</h2><p>http基于TCP建立连接，TCP报文中的相关字段：</p><ol><li>SYN&#x3D;1用来标识想建立连接；</li><li>ACK&#x3D;1标识这是一条确认报文</li><li>seq 是序号</li><li>ack 是确认序号</li></ol><p>HTTP三次握手</p><ol><li>SYN&#x3D;1 ACK&#x3D;0 seq&#x3D;x ack&#x3D;0 （即想建立TCP连接）</li><li>SYN&#x3D;1 ACK&#x3D;1 seq&#x3D;y ack&#x3D;x+1  （服务端回复报文）</li><li>SYN&#x3D;0 ACK&#x3D;1 seq&#x3D;x+1 ack&#x3D;y+1  (客户端回复报文)</li></ol><p>三次握手的目的，是为了确认双方都有收发能力。</p><p>HTTP四次挥手</p><ol><li>FIN&#x3D;1 客户端向服务器发</li><li>ACK&#x3D;1</li><li>FIN&#x3D;1服务器向客户端发</li><li>ACK&#x3D;1</li></ol><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><p>HTTPS 使用TLS (SSL) 来加密普通的HTTP 请求和响应，ssl协议也是应用层协议，但它工作在应用层和传输层之间。<br>SSL（Secure Sockets Layer安全套接层）</p><p>https请求过程，在TCP连接建立之后：</p><ol><li>客户端发送支持的加密协议及版本，如SSL TLS</li><li>服务端收到后，选择合适的加密协议，返回证书（包含公钥）</li><li>客户端收到以后，确定证书的有效性，如有效，生成一个会话秘钥（即一个随机数），用公钥加密它，并发送给服务端</li><li>服务端收到以后，用私钥解密，拿到会话秘钥，随后用这个会话秘钥对要发送的数据进行加密</li><li>客户端收到以后，用会话秘钥解密，并且解析数据呈现给客户</li></ol><p>简单来说，用非对称加密的方式来传输了会话秘钥，后续用会话秘钥来加解密通信内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.rfc-editor.org/rfc/rfc9110.html#field.content-type">https://www.rfc-editor.org/rfc/rfc9110.html#field.content-type</a><br><a href="https://cloud.tencent.com/developer/article/1017988">https://cloud.tencent.com/developer/article/1017988</a></p>]]></content>
    
    
    <categories>
      
      <category>Http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的网络攻击及防护要点</title>
    <link href="/2023/09/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    <url>/2023/09/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一  概述"></a>一  概述</h2><h2 id="二-常见的网络攻击类型"><a href="#二-常见的网络攻击类型" class="headerlink" title="二 常见的网络攻击类型"></a>二 常见的网络攻击类型</h2><ol><li>注入类<ul><li>sql注入</li><li>os命令注入（操作系统命令 注入）</li><li>ldap注入</li><li>远程文件包含：url中加入某些参数，让项目require了恶意的文件</li></ul></li><li>绕过防御类<ul><li>目录遍历：访问应用之外的文件</li><li>不安全对象引用</li></ul></li><li>跨站类<ul><li>跨站请求</li><li>跨站请求伪造（CSRF）：通过已认证的浏览器在受信任的站点上执行非正常操作，如A可能点进去一个邮件中带有转账请求的链接。</li><li>跨站脚本攻击：链接中带脚本，诱导用户点击，而后脚本窃取用户的session发给攻击者</li></ul></li><li>资源消耗类<ul><li>分布式拒绝服务（DDOS)：攻击者用网络协议的固有漏洞，伪造合理的服务请求，消耗服务器有限的贷款和服务资源。如UDP。一般攻击者会利用被留后门的主机，批量向被攻击者发请求。</li></ul></li><li>篡改仿冒类<ul><li>认证和会话管理实效: 攻击者窃取服务器上保存的session，来进行各种操作</li><li>隐藏变量更改</li></ul></li><li>配置管理类<ul><li>不安全的数据存储： 需要对敏感数据加密</li><li>信息泄露和不安全的参数处理</li></ul></li><li>窃听攻击<ul><li>中间人攻击：攻击者充当客户端与服务器之间的中间人，进行窃听，及非法操作。可以给参数加密，加密信息存储在header，来解决</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《WEB应用安全攻防技术讲座(徐震)》</p>]]></content>
    
    
    <categories>
      
      <category>网络攻击</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka概述</title>
    <link href="/2023/09/19/kafka%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/19/kafka%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>broker 服务节点<br>topic partition</p><p>topic<br>offset在partition中的序号<br>副本<br>record: 包含  topic key value</p><p>kafka中zookeeper的作用</p><p>作为kafka集群信息和状态的保存者，并能将变化及时通知出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Producer.ts</span><br><span class="hljs-comment">// 声明发送的topic，然后send</span><br><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> kafka <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;kafka-node&#x27;</span><br><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> kafka.<span class="hljs-title class_">KafkaClient</span>(&#123;<span class="hljs-attr">kafkaHost</span>: <span class="hljs-string">&#x27;localhost:9092&#x27;</span>&#125;)<br><br><span class="hljs-keyword">const</span> producer = <span class="hljs-keyword">new</span> kafka.<span class="hljs-title class_">HighLevelProducer</span>(client)<br>producer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Kafka Producer is connected and ready.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// For this demo we just log producer errors to the console.</span><br>producer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>&#125;)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendRecord</span> = (<span class="hljs-params">objData, cb</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(objData))<br><br>  <span class="hljs-comment">// Create a new payload</span><br>  <span class="hljs-keyword">const</span> record = [<br>    &#123;<br>      <span class="hljs-attr">topic</span>: <span class="hljs-string">&#x27;webevents.dev&#x27;</span>,<br>      <span class="hljs-attr">messages</span>: buffer,<br>      <span class="hljs-attr">attributes</span>: <span class="hljs-number">1</span> <span class="hljs-comment">/* Use GZip compression for the payload */</span><br>    &#125;<br>  ]<br><br>  <span class="hljs-comment">// Send record to Kafka and log result/error</span><br>  producer.<span class="hljs-title function_">send</span>(record, cb)<br>&#125;<br><br><span class="hljs-keyword">let</span> times = <span class="hljs-number">0</span><br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">sendRecord</span>(&#123;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">`this is message <span class="hljs-subst">$&#123;++times&#125;</span>!`</span><br>  &#125;, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`err: <span class="hljs-subst">$&#123;err&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`data: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>`</span>)<br>  &#125;)<br>&#125;, <span class="hljs-number">1000</span>)<br><br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Consumer.ts</span><br><span class="hljs-comment">// 设定侦听的topic，然后on message</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> kafka <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;kafka-node&#x27;</span><br><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> kafka.<span class="hljs-title class_">KafkaClient</span>(&#123;<span class="hljs-attr">kafkaHost</span>: <span class="hljs-string">&#x27;localhost:9092&#x27;</span>&#125;)<br><br><span class="hljs-keyword">const</span> topics = [<br>  &#123;<br>    <span class="hljs-attr">topic</span>: <span class="hljs-string">&#x27;webevents.dev&#x27;</span><br>  &#125;<br>]<br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">autoCommit</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">fetchMaxWaitMs</span>: <span class="hljs-number">1000</span>,<br>  <span class="hljs-attr">fetchMaxBytes</span>: <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>  <span class="hljs-comment">// encoding: &#x27;buffer&#x27;</span><br>&#125;<br><span class="hljs-comment">// &#123; autoCommit: false, fetchMaxWaitMs: 1000, fetchMaxBytes: 1024 * 1024 &#125;;</span><br><br><span class="hljs-keyword">const</span> consumer = <span class="hljs-keyword">new</span> kafka.<span class="hljs-title class_">Consumer</span>(client, topics, options)<br><br>consumer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) &#123;<br><br>  <span class="hljs-comment">// Read string into a buffer.</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`[message]:==:&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(message)&#125;</span>`</span>)<br>  <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Buffer</span>(<span class="hljs-title class_">String</span>(message.<span class="hljs-property">value</span>), <span class="hljs-string">&#x27;binary&#x27;</span>)<br>  <span class="hljs-keyword">const</span> decodedMessage = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(buf.<span class="hljs-title function_">toString</span>())<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;decodedMessage: &#x27;</span>, decodedMessage)<br>&#125;)<br><br>consumer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)<br>&#125;)<br><br>process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  consumer.<span class="hljs-title function_">close</span>(<span class="hljs-literal">true</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    process.<span class="hljs-title function_">exit</span>()<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>kafka的作用：<br>作为一个消息队列，又因为它能长久的保存数据，且容量理论上可以无限的大。<br>可以用于：</p><ol><li>流量削峰，比方说秒杀</li><li>因为它是一个中间件，因此可以用于解耦</li><li>他用一种异步转同步的方式保证了消息消费的顺序性，因此可以用于消除一些并发问题</li></ol><p>redis的发布订阅，是推的，消息存入内存，不会持久化。<br>kafka的发布订阅，是拉的，默认可持久化<br>rabbitmMQ的发布订阅，是推的，默认不持久化，可以持久化</p>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间件-kafka</title>
    <link href="/2023/09/19/%E4%B8%AD%E9%97%B4%E4%BB%B6-kafka/"/>
    <url>/2023/09/19/%E4%B8%AD%E9%97%B4%E4%BB%B6-kafka/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>一个高吞吐量的发布订阅消息系统，被用来处理大规模的数据流。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>持久性</li><li>分区</li><li>复制</li><li>容错</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>用来处理大规模数据流，构建实时数据处理系统，实现异步通信和事件驱动架构</p><ul><li>实时日志收集和分析</li><li>构建事件驱动的服务架构</li><li>实时处理和分析大规模的数据流</li></ul><h2 id="业务使用场景示例"><a href="#业务使用场景示例" class="headerlink" title="业务使用场景示例"></a>业务使用场景示例</h2><p>以处理游戏中的日志 item_change为例</p><p>topic &#x3D; serverName_item_change 按日志来源来分区<br>partitionKey &#x3D; 用户ID、或者对消息进行hash，确保消息在分区中均匀分布</p><p>notes:</p><ul><li>topic 用来确认发往哪个频道</li><li>partitionKey 用来确定消息存在此频道的哪个分区</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>生产者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Producer</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node-rdkafka&#x27;</span>);<br><br><span class="hljs-keyword">const</span> producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(&#123;<br>  <span class="hljs-string">&#x27;metadata.broker.list&#x27;</span>: <span class="hljs-string">&#x27;localhost:9092&#x27;</span>, <span class="hljs-comment">// Kafka 服务器地址</span><br>&#125;);<br><br>producer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Producer ready&#x27;</span>);<br><br>  <span class="hljs-comment">// 发送消息</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * topic</span><br><span class="hljs-comment">   * partition 用来指定发往哪个分区</span><br><span class="hljs-comment">   * message</span><br><span class="hljs-comment">   * key 消息的键值，相同key的消息会被发往相同的分区</span><br><span class="hljs-comment">   * timestamp 消息的时间戳</span><br><span class="hljs-comment">   * headers 头信息，用来传一些额外的信息</span><br><span class="hljs-comment">   */</span><br>  producer.<span class="hljs-title function_">produce</span>(<span class="hljs-string">&#x27;my-topic&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello Kafka!&#x27;</span>), <span class="hljs-literal">null</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>&#125;);<br><br>producer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;delivery-report&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, report</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Delivery failed:&#x27;</span>, err);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message delivered:&#x27;</span>, report);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 连接 Kafka</span><br>producer.<span class="hljs-title function_">connect</span>();<br><br><span class="hljs-comment">// 等待生产者准备就绪</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  producer.<span class="hljs-title function_">disconnect</span>();<br>&#125;, <span class="hljs-number">1000</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">KafkaConsumer</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node-rdkafka&#x27;</span>);<br><br><span class="hljs-keyword">const</span> consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>(&#123;<br>  <span class="hljs-string">&#x27;group.id&#x27;</span>: <span class="hljs-string">&#x27;my-group&#x27;</span>,<br>  <span class="hljs-string">&#x27;metadata.broker.list&#x27;</span>: <span class="hljs-string">&#x27;localhost:9092&#x27;</span>, <span class="hljs-comment">// Kafka 服务器地址</span><br>&#125;);<br><br>consumer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Consumer ready&#x27;</span>);<br><br>  <span class="hljs-comment">// 订阅 Topic</span><br>  consumer.<span class="hljs-title function_">subscribe</span>([<span class="hljs-string">&#x27;my-topic&#x27;</span>]);<br>&#125;);<br><br>consumer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message received:&#x27;</span>, message.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>());<br>&#125;);<br><br><span class="hljs-comment">// 连接 Kafka</span><br>consumer.<span class="hljs-title function_">connect</span>();<br><br><span class="hljs-comment">// 等待消费者准备就绪</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  consumer.<span class="hljs-title function_">disconnect</span>();<br>&#125;, <span class="hljs-number">10000</span>);<br><br></code></pre></td></tr></table></figure><ul><li>创建消费者，需要指定消费者组</li><li>同一个消费者组的消费者，不会重复消费消息，会尽量均分消息。</li><li>一个消费者可以订阅多个topic</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>消费者</li><li>broker 服务节点</li><li>topic 主题，逻辑容器</li><li>partition 分区 物理存储单元，用于将消息均匀分布在多个broker上</li><li>consumer group 消费者组，同一消费者组分topic中的信息</li><li>zookeeper 协调服务，用来存储kafka集群的元数据，并能将变化及时通知出去</li></ul><p>kafka中某个topic的分区，如分3各区，这三个partition会分布在不同的broker上<br>比如：</p><ul><li>partition1在broker1上</li><li>partition2在broker2上</li><li>partition3在broker3上<br>然后broker中还会存储partition的副本数据，写入操作只有在写入所有副本之后才算成功，提高容错性和高可用性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次高并发下mongodb保存失败问题</title>
    <link href="/2023/09/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8Bmongodb%E4%BF%9D%E5%AD%98%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8Bmongodb%E4%BF%9D%E5%AD%98%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>mongodb在高并发下保存失败，报了version error错误</p><p>来自同一用户的请求，A，B,A在未返回之前，B到来了，且A，B在几乎同时，去更新了同一个document。<br>处理流程较长的请求在处理过程中，如果有一个处理流程较短的请求，就有可能出现上述情况。</p><p>解决方案：<br>加了redlock锁</p><p>改进方案：</p><ol><li>找一个kafka, 将请求路径及参数发到kafka，然后由server订阅kafka的topic，topic可以是server+serverNum</li><li>让客户端做个限制，当之前的请求未返回时，不发送后续的请求。</li></ol>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aws服务全景概述</title>
    <link href="/2023/09/15/aws%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/15/aws%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><h2 id="二：各产品"><a href="#二：各产品" class="headerlink" title="二：各产品"></a>二：各产品</h2><ul><li>数据库产品<ul><li>关系型<ul><li>amazon aurora: 与 MySQL 和 PostgreSQL 兼容的关系数据库，专为云而打造,性能与商用数据库相当，成本只有1&#x2F;10</li><li>amazon rds：Amazon Relational Database Service，关系型数据库，支持多种数据引擎，如MySQL、PostgreSQL、Oracle、SQL Server 和 Amazon Aurora</li><li>amazon redshift：关系型数据仓库</li></ul></li><li>非关系型<ul><li>amazon dynamodb: nosql数据库，近乎有无限的可拓展性</li><li>amazon documentDB 兼容mongodb：文档数据库</li></ul></li><li></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Aws</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd概述</title>
    <link href="/2023/09/15/etcd%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/15/etcd%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>etcd 是一个分布式键值对存储，设计用来可靠而快速的保存关键数据并提供访问。通过分布式锁，leader选举和写屏障(write barriers)来实现可靠的分布式协作。etcd集群是为高可用，持久性数据存储和检索而准备。</p><h2 id="二：如何使用"><a href="#二：如何使用" class="headerlink" title="二：如何使用"></a>二：如何使用</h2><p>以mac，本地集群为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew search etcd;<br>brew install etcd; <span class="hljs-comment">## 安装</span><br>brew services list;<br>brew services start etcd; <span class="hljs-comment">## 运行</span><br>brew services stop etcd;<br>etcdctl endpoint health; <span class="hljs-comment">## 检查下是否真的运行</span><br><br>etcdctl put <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-string">&#x27;shiduoyang&#x27;</span> <span class="hljs-comment">## 设置键值对</span><br>etcdctl get <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-comment">## 获取键对应的值</span><br>etcdctl del <span class="hljs-string">&#x27;name&#x27;</span> <br>etcdctl watch <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-comment">## 建立长连接，监听key的值变化</span><br><br><span class="hljs-comment">## 租约，租约是一段时间，租约到期，附加该租约的key全部到期</span><br>etcdctl lease grant 20; <span class="hljs-comment">## 定义一个租约，grant类型（creates leases), 20秒到期</span><br>etcdctl put --lease=694d8a9802897a11 <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">## 租约到期以后，该key被删除</span><br></code></pre></td></tr></table></figure><h2 id="三：如何创建一个etcd集群"><a href="#三：如何创建一个etcd集群" class="headerlink" title="三：如何创建一个etcd集群"></a>三：如何创建一个etcd集群</h2><p>以三台机器为例，<br>架设他们的ip分别是10.0.1.10；10.0.1.11；10.0.1.12；<br>主机分别是infra0.example.com;infra1.example.com;infra2.example.com;<br>名字分别是infra0,infra1,infra2;<br>那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">etcd --name infra0 <br>--initial-advertise-peer-urls http://10.0.1.10:2380 \<br>--listen-peer-urls http://10.0.1.10:2380 \<br>--listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \<br>--advertise-client-urls http://10.0.1.10:2379 \<br>--initial-cluster-token etcd-cluster-1 \<br>--initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>--initial-cluster-state new<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \<br>--listen-peer-urls http://10.0.1.11:2380 \<br>--listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \<br>--advertise-client-urls http://10.0.1.11:2379 \<br>--initial-cluster-token etcd-cluster-1 \<br>--initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>--initial-cluster-state new<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \<br>--listen-peer-urls http://10.0.1.12:2380 \<br>--listen-client-urls http://10.0.1.12:2379,http://127.0.0.1:2379 \<br>--advertise-client-urls http://10.0.1.12:2379 \<br>--initial-cluster-token etcd-cluster-1 \<br>--initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \<br>--initial-cluster-state new<br></code></pre></td></tr></table></figure><p>–listen-peer-urls 都是填本机<br>–listen-client-urls填本机ip<br>–advertise-client-urls填本机ip<br>集群信息在inital-cluster中体现</p><h2 id="三：etcd的存储方案"><a href="#三：etcd的存储方案" class="headerlink" title="三：etcd的存储方案"></a>三：etcd的存储方案</h2><p>etcd分为内存存储与磁盘存储<br>内存存储，存储的内容主要是wa（预写日志 write ahead log）和 索引，堆，等方便查询的数据结构；<br>磁盘存储，存储snapshot和wa日志。<br>snapshot是某个时间点etcd的数据快照，这样能及时释放日益增加的wa日志。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://doczhcn.gitbook.io/etcd/index">https://doczhcn.gitbook.io/etcd/index</a></p>]]></content>
    
    
    <categories>
      
      <category>Etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>Docker</tag>
      
      <tag>Etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记-kubernetes中文指南</title>
    <link href="/2023/09/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-kubernetes%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-kubernetes%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一：容器，容器化，docker-到kubernetes"><a href="#一：容器，容器化，docker-到kubernetes" class="headerlink" title="一：容器，容器化，docker,到kubernetes"></a>一：容器，容器化，docker,到kubernetes</h2><ol><li>容器：想象一个集装箱，里面包含有应用程序运行所需的所有组件，且这个集装箱可以跨平台的运行。</li><li>容器化：将应用程序放在容器中，以容器为单位进行管理，实现跨平台运行的这种思想，叫做容器化</li><li>docker：docker是一个容器化工具，用于打包和运行容器</li><li>kubernetes：kubernetes用于对若干容器组成的集群的管理</li></ol><h2 id="二：云原生概念与云原生的发展"><a href="#二：云原生概念与云原生的发展" class="headerlink" title="二：云原生概念与云原生的发展"></a>二：云原生概念与云原生的发展</h2><p>云原生本身甚至不能称之为一个架构，它首先是一个基础设施，运行于其上的应用程序叫做云原生应用，符合云原生设计哲学的应用架构才叫做云原生架构。</p><p>那么云原生的设计哲学是什么呢？</p><ol><li>面向分布式设计：容器，微服务，API驱动的开发</li><li>面向配置设计：一个镜像，多个环境配置</li><li>面向韧性设计：故障容忍和自愈</li><li>面向弹性设计：弹性扩展和对负载变化做出反应</li><li>面向交付设计：自动拉起，缩短交付时间</li><li>面向性能设计：响应式，并发和资源高效利用</li><li>面向自动化设计：自动化的devops</li><li>面向诊断性设计：集群级别的日志，metic和追踪</li><li>面向安全性设计：安全端点，api gateway,端到端加密</li></ol><p>总体来说，凡能提升云上资源利用率和应用交付效率的方式和行为，都是云原生的。<br>云原生的相关概念：微服务，devops, 容器化，持续交付</p><p>云原生的发展史：</p><ol><li>kubernetes开启了云原生的序幕</li><li>istio服务网格的出现，引领了后kubernetes时代的微服务</li><li>serverless的再次兴起，使得云原生从基础设施层不断向应用架构层挺近。</li></ol><h2 id="三：云计算的宏观分类"><a href="#三：云计算的宏观分类" class="headerlink" title="三：云计算的宏观分类"></a>三：云计算的宏观分类</h2><ol><li>lass: Infrastructure-as-a-service 基础设施服务,etc: computer,coterage,networking,aws,google cloud platform</li><li>pass: platform-as-a-service,etc: mysql,mongodb,java,node.js</li><li>sass: software-as-a-service,etc: email,facebook</li></ol><h2 id="四：kubernetes概念与原理"><a href="#四：kubernetes概念与原理" class="headerlink" title="四：kubernetes概念与原理"></a>四：kubernetes概念与原理</h2><p>kubernetes是一个容器编排引擎。它运用了“期望状态”原则，它提供一个规范，让你描述集群的架构，定义服务的最终形态，kubernetes帮你维护这个形态。</p><h3 id="4-1-kubernetes架构"><a href="#4-1-kubernetes架构" class="headerlink" title="4.1 kubernetes架构"></a>4.1 kubernetes架构</h3><p>kubernetes架构，如果从外部来看，可类比为一个有一个集装箱所组成的集群，这些集装箱有不同的类型和功能。</p><ol><li>集群。所有组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间</li><li>节点。节点是集群中的单个机器（对应物理机器或云中的虚拟机），节点是部署应用和服务的地方。有两种节点master和worker</li><li>主节点。主节点是控制其他所有节点的特殊节点。主节点的组成：<ul><li>API Server：命令接收</li><li>Scheduler：调度pod，比方说将某pod调度到某worker执行</li><li>Controlelr Manager：控制管理各种资源</li><li>etcd: 用于存储集群信息，在数据发生变化时，及时通知相关组件</li><li>kubelet：所有节点都有，用于接收来自master的信息，及报告当前节点的状态</li><li>kubeproxy：所有节点都有，用于将service的流量转发到后端的容器，kubeproxy实现了负载均衡</li></ul></li><li>worker节点。集群中真正干活的地方(你的应用程序在此运行), 它托管或运行一个或多个容器<ul><li>kubelet</li><li>kubeproxy</li></ul></li><li>pod。是一个逻辑单位，是kubernetes可调度的最小单位，包含一个或多个容器，构建出一个应用程序。pod运行在node（即节点）上。</li><li>service。services是一组逻辑上的pod，并提供了一个ip地址和DNS名称，你可以通过它访问service内的所有pod</li><li>ReplicationController或ReplicaSet。负责实际管理pod的生命周期，在适当的时机创建或杀死pod</li></ol><p>网络相关：<br>8. ingress和egress。把pod看层一个逻辑的服务器，那么从外部进入服务器的流量称为ingress,从服务器出去的叫egress。创建入口策略与出口策略的目的是控制哪些流量能进入服务器，哪些流量能流出服务器。比方说定义9998端口的所有流量，都导入某pod<br>10. 服务网络。用于管理服务之间的网络流量。 </p><p><img src="/pic/kubernetesjiagoutu.jpg" alt="kubernetes架构"></p><h4 id="4-1-1-kubernetes的设计理念"><a href="#4-1-1-kubernetes的设计理念" class="headerlink" title="4.1.1 kubernetes的设计理念"></a>4.1.1 kubernetes的设计理念</h4><p>kubernetes的设计理念和功能类似一个linux的分层结构。<br><img src="/pic/kubernetesfenceng.jpg" alt="kubernetes分层"></p><h3 id="4-1-2-kubernetes的资源对象"><a href="#4-1-2-kubernetes的资源对象" class="headerlink" title="4.1.2 kubernetes的资源对象"></a>4.1.2 kubernetes的资源对象</h3><p>以下对象都可以在yaml中作为一种api类型来配置<br>资源对象：</p><ul><li>pod: 可创建和管理的最小单元，一组容器</li><li>Pod ReplicaSet：一组描述，描述了pod需要维护的副本个数 </li><li>ReplicationController </li><li>Deployment：为pod和replicaSet提供声明式的更新能力</li><li>StatefulSet： </li><li>DaemonSet </li><li>Job：</li><li>CronJob : 重复调用的job</li><li>HorizontalPodAutoscaling </li><li>Node </li><li>Namespace </li><li>Service </li><li>Ingress</li><li>Label </li><li>CustomResourceDefinition</li></ul><p>存储对象：</p><ul><li>Volume</li><li>PersistentVolume </li><li>Secret </li><li>ConfigMap</li></ul><p>策略对象：</p><ul><li>SecurityContext </li><li>ResourceQuota </li><li>LimitRange</li></ul><p>身份对象：</p><ul><li>ServiceAccount </li><li>Role </li><li>ClusterRole</li></ul><p>简单来说，用这些对象来描述三件事：</p><ol><li>什么容器化应用在运行，及其在哪个pod上</li><li>使用什么资源</li><li>表现出什么策略</li></ol><p>TODO:</p><p>参考：<br>kubernetes中文指南<br><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>Docker</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记-道德经</title>
    <link href="/2023/09/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    <url>/2023/09/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%81%93%E5%BE%B7%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>道德经，分为道经和德经，内容主要是两块，一块是帝王治理天下之术，一块是为人处世之道。</p><h2 id="二：节选"><a href="#二：节选" class="headerlink" title="二：节选"></a>二：节选</h2><ul><li>道可道，非常道，名可名，非常名。无名天地之使，有名天地之母。</li><li>天下皆知美之为美，斯恶已。皆知善之为善，斯不善已。故有无相生，难易相成，长短相较，高下相倾，音声相和，前后相随。是以圣人处无为之事，行不言之教；万物作焉而不辞，生而不有，危而不持，功成而弗居，是以不去。</li><li>上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤</li><li>大道废，有仁义;智慧出，有大伪;六亲不和，有孝慈;国家昏乱，有忠臣。</li><li>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以 圣人抱一为天下式。不自见，故明;不自是，故彰;不自伐， 故有功;不自矜，故长。夫唯不争，故天下莫能与之争。古 之所谓曲则全者，岂虚言哉!诚全而归之。</li><li>企者不立，跨者不行，自见者不明，自是者不彰，自伐者无 功，自矜者不长。其在道也，曰“馀食赘行”。物或恶之， 故有道者不处。</li><li>知其雄，守其雌，为天下谿。为天下谿，常德不离，复归于婴儿。知其白，守其黑，为天下式。为天下式，常德不忒，复归于无极。知其荣，守其辱，为天下谷，常德乃足，复归于朴。朴散则为器，圣人用之，则为官长，故大制不割。</li><li>知人者智，自知者明。胜人者有力，自胜者强。知足者富。强行者有志。不失其所者久。死而不亡者寿。</li><li>将欲歙之，必固张之;将欲弱之，必固强之;将欲废之，必固兴之;将欲夺之，必固与之。是谓微明。柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。</li><li>上德不德，是以有德;下德不失德，是以无德。上德无为而无以为;下德为之而有以为。上仁为之而无以为;上义为之而有以为。上礼为之而莫之应，则攘臂而扔之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首。前识者，道之华，而愚之始。是以大丈夫处其厚，不居其薄;处其实，不居其华。故去彼取此。</li><li>反者道之动，弱者道之用。天下万物生于有，有生于无。</li><li>道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。人之所恶，唯孤、寡、不穀，而王公以为称。故物或损之而益，或益之而损。人之所教，我亦教之。强梁者不得其死，吾将以为教父。</li><li>其安易持，其未兆易谋。其脆易泮，其微易散。为之于未有， 治之于未乱。合抱之木，生于毫末;九层之台，起于累土; 千里之行，始于足下。为者败之，执者失之。是以圣人无为 故无败，无执故无失。民之从事，常于几成而败之。慎终如 始，则无败事。是以圣人欲不欲，不贵难得之货;学不学， 复众人之所过。以辅万物之自然，而不敢为。</li><li>民不畏死，奈何以死惧之?若使民常畏死，而为奇者，吾得执而杀之，孰敢?常有司杀者杀。夫代司杀者杀，是谓代大匠斲，夫代大匠斲者，希有不伤其手矣。</li><li>人之生也柔弱，其死也坚强。万物草木之生也柔脆，其死也枯藁。故坚强者死之徒，柔弱者生之徒。是以兵强则不胜，木强则兵。强大处下，柔弱处上。</li><li>信言不美，美言不信。善者不辩，辩者不善。知者不博，博者不知。圣人不积，既以为人己愈有，既以与人己愈多。天之道，利而不害;圣人之道，为而不争。</li></ul><h2 id="三：总结"><a href="#三：总结" class="headerlink" title="三：总结"></a>三：总结</h2><p>道为世界运转的根基，人应该顺应事物发展的规律做事，不做违背规律的事。<br>待人处事，常处于一个“下”的位置，比较好。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell命令概述</title>
    <link href="/2023/09/14/shell%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/14/shell%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一-shell概述"><a href="#一-shell概述" class="headerlink" title="一 shell概述"></a>一 shell概述</h2><p>shell是你（用户）和Linux（或者更准确的说，是你和Linux内核）之间的接口程序。你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。<br>shell 是一个命令语言解释器（command-language interpreter）。拥有自己内建的 shell 命令集。此外，shell也能被系统中其他有效的Linux 实用程序和应用程序（utilities and application programs）所调用。</p><h2 id="二-shell命令"><a href="#二-shell命令" class="headerlink" title="二 shell命令"></a>二 shell命令</h2><table><thead><tr><th align="left">文件管理</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">ls</td><td align="left">查询目录中的文件及属性信息</td><td align="left">ls -a</td></tr><tr><td align="left">cp</td><td align="left">复制文件或目录</td><td align="left">cp -rf .&#x2F; ..&#x2F;</td></tr><tr><td align="left">mkdir</td><td align="left">创建目录</td><td align="left">mkdir test</td></tr><tr><td align="left">mv</td><td align="left">移动文件或目录</td><td align="left">mv a.txt ..&#x2F;</td></tr><tr><td align="left">pwd</td><td align="left">显示当前目录的路径</td><td align="left">pwd</td></tr><tr><td align="left">tar</td><td align="left">压缩和解压缩文件</td><td align="left">tar czvf File.tar.gz &#x2F;etc</td></tr></tbody></table><table><thead><tr><th align="left">文档编辑</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">cat</td><td align="left">在终端显示文件内容</td><td align="left">cat -n x.txt</td></tr><tr><td align="left">echo</td><td align="left">输出字符串或提取后的变量值</td><td align="left">echo ‘123’</td></tr><tr><td align="left">rm</td><td align="left">删除文件或目录</td><td align="left">rm -rf .&#x2F;test</td></tr><tr><td align="left">grep</td><td align="left">强大的文本搜索工具</td><td align="left">grep -arn ‘xxx’ .&#x2F;</td></tr><tr><td align="left">tail</td><td align="left">查看文件尾部内容</td><td align="left">tail -f xxx.log</td></tr><tr><td align="left">rmdir</td><td align="left">删除空目录文件</td><td align="left">rmdir .&#x2F;dir</td></tr></tbody></table><table><thead><tr><th align="left">系统管理</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">find</td><td align="left">根据路径和条件搜索指定文件</td><td align="left">find &#x2F; -name ‘*.conf’</td></tr><tr><td align="left">rpm</td><td align="left">rmp软件包管理器</td><td align="left">rpm -ivh cockpit-185-2.el8.x86_64.rpm</td></tr><tr><td align="left">startx</td><td align="left">初始化x-Windows系统</td><td align="left">startx</td></tr><tr><td align="left">ps</td><td align="left">显示进程状态</td><td align="left">ps aux</td></tr><tr><td align="left">uname</td><td align="left">显示系统内核信息</td><td align="left">uname -a</td></tr><tr><td align="left">resize2fs</td><td align="left">同步文件系统容量到内核</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">磁盘管理</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">df</td><td align="left">显示磁盘空间使用量情况</td><td align="left">df -h</td></tr><tr><td align="left">fdisk</td><td align="left">管理磁盘分区</td><td align="left">fdisk -l</td></tr><tr><td align="left">lsblk</td><td align="left">查看系统的磁盘使用情况</td><td align="left"></td></tr><tr><td align="left">vgextend</td><td align="left">扩展卷组设备</td><td align="left"></td></tr><tr><td align="left">hdparm</td><td align="left">显示与设定硬盘参数</td><td align="left"></td></tr><tr><td align="left">pvcreate</td><td align="left">创建物理卷设备</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">文件传输</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">tftp</td><td align="left">上传及下载命令</td><td align="left">ftp 192.168.10.10;get File1.txt</td></tr><tr><td align="left">curl</td><td align="left">文件与传输工具</td><td align="left">curl -X ‘POST’ localhost:4000&#x2F;</td></tr><tr><td align="left">fsck</td><td align="left">检查与修复文件系统</td><td align="left"></td></tr><tr><td align="left">lprm</td><td align="left">移除打印队列中的人物</td><td align="left"></td></tr><tr><td align="left">ftpwho</td><td align="left">显示FTP会话信息</td><td align="left"></td></tr><tr><td align="left">rsync</td><td align="left">远程数据同步工具</td><td align="left">rsync -r &#x2F;Dir 192.168.10.10:&#x2F;Dir</td></tr></tbody></table><table><thead><tr><th align="left">网络通讯</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">ssh</td><td align="left">安全的远程连接服务器</td><td align="left">ssh 192.168.10.10</td></tr><tr><td align="left">netstat</td><td align="left">显示网络状态</td><td align="left">netstat -ap</td></tr><tr><td align="left">dhclient</td><td align="left">动态获取或释放ip地址</td><td align="left"></td></tr><tr><td align="left">ifconfig</td><td align="left">显示或设置网络设备参数信息</td><td align="left"></td></tr><tr><td align="left">ping</td><td align="left">测试主机间网络连通性</td><td align="left">ping 192.168.10.10</td></tr><tr><td align="left">sshd</td><td align="left">openssh服务器守护进程</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">设备管理</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">mount</td><td align="left">将文件挂载到目录</td><td align="left"></td></tr><tr><td align="left">lspci</td><td align="left">显示当前设备PCI总线设备信息</td><td align="left"></td></tr><tr><td align="left">sencors</td><td align="left">监测服务器硬件信息</td><td align="left"></td></tr><tr><td align="left">setleds</td><td align="left">设置键盘的led灯光状态</td><td align="left"></td></tr><tr><td align="left">rfkill</td><td align="left">管理蓝牙和wify设备</td><td align="left"></td></tr><tr><td align="left">setpci</td><td align="left">设置PCI硬件设备参数</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">备份压缩</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">zip</td><td align="left">压缩文件</td><td align="left"></td></tr><tr><td align="left">unzip</td><td align="left">解压缩zip文件</td><td align="left"></td></tr><tr><td align="left">gzip</td><td align="left">压缩和解压文件</td><td align="left"></td></tr><tr><td align="left">zipinfo</td><td align="left">查看压缩文件信息</td><td align="left"></td></tr><tr><td align="left">gunzip</td><td align="left">解压提取文件内容</td><td align="left"></td></tr><tr><td align="left">unarj</td><td align="left">解压arj文件</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">其他命令</th><th align="left">命令</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">hash</td><td align="left">管理命令运行时查询的hash表</td><td align="left"></td></tr><tr><td align="left">wait</td><td align="left">等待指令执行完毕</td><td align="left"></td></tr><tr><td align="left">wget</td><td align="left">下载网络文件</td><td align="left">wget <a href="http://xxxxx/x.log">http://xxxxx/x.log</a></td></tr><tr><td align="left">history</td><td align="left">显示与管理历史命令记录</td><td align="left"></td></tr><tr><td align="left">bc</td><td align="left">数字计算器</td><td align="left"></td></tr><tr><td align="left">rmmod</td><td align="left">移除内核模块</td><td align="left"></td></tr></tbody></table><p>所以，要想知道某端口的占用情况，有几种方式？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep 4000<br>lsof -i:4000<br></code></pre></td></tr></table></figure><p>常用的命令：</p><ul><li>ps</li><li>curl</li><li>grep</li><li>ssh</li><li>netstat</li></ul><h2 id="三-参考"><a href="#三-参考" class="headerlink" title="三 参考"></a>三 参考</h2><p>参考：<a href="https://www.linuxcool.com/">https://www.linuxcool.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMQ概述</title>
    <link href="/2023/09/11/%E4%B8%AD%E9%97%B4%E4%BB%B6-rabbitMQ/"/>
    <url>/2023/09/11/%E4%B8%AD%E9%97%B4%E4%BB%B6-rabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>RabbitMQ是一个开源的消息代理软件，用来在不同系统之间进行异步通讯</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>消息队列</li><li>消息路由：根据路由键将消息路由到不同的队列中</li><li>可靠性与持久化：保证消息不丢失，支持将消息持久化到磁盘上</li><li>高可用性与可扩展</li><li>灵活的插件系统</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>异步通信</li><li>任务队列</li><li>发布订阅模式</li><li>日志收集与分析</li><li>应用程序集成：解耦</li><li>微服务架构</li><li>流式处理</li></ul><h2 id="业务适用场景示例"><a href="#业务适用场景示例" class="headerlink" title="业务适用场景示例"></a>业务适用场景示例</h2><p>生产者生成任务 到任务队列中，然后去干别的事<br>消费者从任务队列中取出任务，处理，然后发送确认消息（或采用其他形式的通信给生产者告知任务完成）<br>生产者监听到确认消息，执行该任务的收尾工作</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>生产者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;amqplib&#x27;</span>);<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">produceMessage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;amqp://localhost&#x27;</span>); <span class="hljs-comment">// RabbitMQ服务器的地址</span><br>    <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();<br>    <span class="hljs-keyword">const</span> queue = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br>    <span class="hljs-keyword">const</span> message = <span class="hljs-string">&#x27;Hello, RabbitMQ!&#x27;</span>;<br><br>    <span class="hljs-comment">// 声明一个队列，如果队列不存在则创建</span><br>    <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queue, &#123; <span class="hljs-attr">durable</span>: <span class="hljs-literal">false</span> &#125;);<br><br>    <span class="hljs-comment">// 发送消息到队列</span><br>    channel.<span class="hljs-title function_">sendToQueue</span>(queue, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(message));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[x] Sent &#x27;<span class="hljs-subst">$&#123;message&#125;</span>&#x27;`</span>);<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">close</span>();<br>    <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">close</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">produceMessage</span>();<br><br></code></pre></td></tr></table></figure></li><li><p>消费者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> amqp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;amqplib&#x27;</span>);<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">consumeMessage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> amqp.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;amqp://localhost&#x27;</span>); <span class="hljs-comment">// RabbitMQ服务器的地址</span><br>    <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">createChannel</span>();<br>    <span class="hljs-keyword">const</span> queue = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br>    <span class="hljs-comment">// 声明一个队列，如果队列不存在则创建</span><br>    <span class="hljs-keyword">await</span> channel.<span class="hljs-title function_">assertQueue</span>(queue, &#123; <span class="hljs-attr">durable</span>: <span class="hljs-literal">false</span> &#125;);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[*] Waiting for messages in <span class="hljs-subst">$&#123;queue&#125;</span>. To exit press CTRL+C`</span>);<br><br>    <span class="hljs-comment">// 接收消息</span><br>    channel.<span class="hljs-title function_">consume</span>(queue, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[x] Received &#x27;<span class="hljs-subst">$&#123;message.content.toString()&#125;</span>&#x27;`</span>);<br>      channel.<span class="hljs-title function_">ack</span>(message); <span class="hljs-comment">// 发送确认消息，rabbitMQ收到该消息后会删除该消息</span><br>    &#125;, <br>    &#123; <br>      <span class="hljs-attr">noAck</span>: <span class="hljs-literal">false</span> <br>    &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">consumeMessage</span>();<br><br></code></pre></td></tr></table></figure></li><li><p>常用示例</p></li></ol><p>3.1 消息持久化<br>消息数据被持久化的保存在磁盘中，直到用户确认消费为止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">channel.<span class="hljs-title function_">sendToQueue</span>(queue, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello world&#x27;</span>), &#123; <span class="hljs-attr">persistent</span>: <span class="hljs-literal">true</span> &#125;);<br><br></code></pre></td></tr></table></figure><p>3.2 队列持久化<br>队列的元数据被持久的保存在磁盘中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">channel.<span class="hljs-title function_">assertQueue</span>(<span class="hljs-string">&#x27;myQueue&#x27;</span>, &#123; <span class="hljs-attr">durable</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>RabbitMQ的组成和架构包括以下核心组件：</p><ol><li><p>Broker：<br>Broker是RabbitMQ的核心组件，负责接收、存储和传递消息。它包括了Exchange、Queue、Channel等子组件。</p></li><li><p>Exchange：<br>Exchange是消息的分发中心，它根据规则将消息路由到一个或多个队列。Exchange有不同的类型，包括Direct、Fanout、Topic等。</p></li><li><p>Queue：<br>Queue是消息的缓冲区，存储待处理的消息。多个消费者可以订阅同一个队列，但只有一个消费者会接收到特定消息。</p></li><li><p>Channel：<br>Channel是在连接中创建的虚拟连接，用于在客户端和Broker之间传递消息。它可以看作是在连接中的独立工作线程，用于提高消息传递效率。</p></li><li><p>Producer和Consumer：<br>Producer是生产者，负责将消息发布到Exchange。Consumer是消费者，负责从Queue获取并处理消息。</p></li></ol><h2 id="四：一些问题"><a href="#四：一些问题" class="headerlink" title="四：一些问题"></a>四：一些问题</h2><ol><li>rabbitMQ是否支持接收历史信息</li></ol><p>RabbitMQ默认情况下不会保留历史消息数据，这意味着一旦消息被消费者接收并确认（Acknowledge），<strong>它们将被删除，不再可用</strong>。这种行为是为了保持消息队列的高性能和低延迟。</p><p>然而，如果实在想要接收历史消息，怎么办？</p><ul><li>持久化消息。在消息发布时将persistent设置为true</li><li>使用消息日志</li><li>使用消息记录器</li></ul>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js发散问题:进程,线程与协程的区别</title>
    <link href="/2023/09/11/node-js%E5%8F%91%E6%95%A3%E9%97%AE%E9%A2%98-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/11/node-js%E5%8F%91%E6%95%A3%E9%97%AE%E9%A2%98-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ol><li>进程（Process）：</li></ol><ul><li>进程是计算机中的一个独立执行单位，它有自己的独立内存空间和资源。</li><li>每个进程都有一个独立的地址空间，不同进程之间的数据不能直接共享，通信需要特定的机制（如进程间通信IPC）。</li><li>进程之间的切换开销相对较高，因为需要保存和恢复进程的状态。</li><li>进程是多任务处理的基本单位，通常代表一个运行的程序。</li></ul><ol start="2"><li>线程（Thread）：</li></ol><ul><li>线程是进程内的一个执行单元，多个线程可以共享同一进程的内存和资源。</li><li>线程之间可以更方便地进行通信，因为它们共享相同的内存空间。</li><li>线程之间的切换开销较小，因为它们共享相同的地址空间。</li><li>线程用于提高程序的并发性和性能，例如，一个多线程程序可以在一个线程执行计算任务的同时，在另一个线程执行I&#x2F;O任务。</li></ul><ol start="3"><li>协程（Coroutine）：</li></ol><ul><li>协程是一种轻量级的线程，也称为用户态线程。它们是由程序员控制的，而不是由操作系统控制。</li><li>协程可以在同一线程内并发执行，但它们不会并行执行。程序员可以显式地控制协程的调度。</li><li>协程通常用于编写高效的异步和非阻塞代码，例如，在网络编程中，可以使用协程来处理大量并发连接。</li><li>协程的切换开销非常小，因为它们是由程序员控制的，不涉及操作系统的上下文切换。</li></ul><p>总结：</p><ol><li>进程是操作系统中的独立执行单位，线程是进程内的执行单位，而协程是程序员控制的轻量级执行单位。</li><li>进程之间的通信较为复杂，线程共享同一进程的内存，通信较为容易，而协程通常是在同一线程内执行，通信也相对容易。</li><li>进程和线程通常用于多核处理器上的并行计算，而协程用于编写高效的异步代码。选择哪种技术取决于具体的应用场景和需求。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js子线程</title>
    <link href="/2023/09/11/node-js%E5%AD%90%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/09/11/node-js%E5%AD%90%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>在Node.js中，子线程（Child Threads）通常是指通过worker_threads模块创建的独立线程。这些子线程允许你在Node.js应用程序中执行并行计算任务，从而充分利用多核处理器，并提高性能。</p><p>相关概念：</p><ol><li>worker_threads 模块： Node.js的核心模块中包含了worker_threads，该模块允许你创建和管理子线程。通过这个模块，你可以在独立的线程中运行JavaScript代码。</li><li>线程与进程的区别： 子线程是运行在主Node.js进程内部的额外线程，与主进程共享内存空间。与子进程不同，子线程不是独立的操作系统进程。这意味着<strong>子线程之间可以共享数据和资源</strong>，但也需要谨慎处理共享数据以避免竞态条件等问题。</li><li>多核处理器利用： 子线程适用于需要执行计算密集型任务的场景，例如图像处理、数据分析、加密等。通过将这些任务分配给子线程，可以充分利用多核处理器的性能。</li><li>通信和同步： 主线程和子线程之间可以通过消息传递进行通信，就像主进程和子进程之间的通信一样。worker_threads模块提供了postMessage和on(‘message’)等方法来实现消息传递。</li></ol><h2 id="二：示例"><a href="#二：示例" class="headerlink" title="二：示例"></a>二：示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-comment">// 主线程代码</span><br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br><br>  <span class="hljs-comment">// 监听子线程的消息</span><br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`主线程收到计算结果：<span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// 向子线程发送消息，触发计算</span><br>  worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">num1</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">num2</span>: <span class="hljs-number">10</span> &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 子线程代码</span><br>  parentPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; num1, num2 &#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子线程收到任务：计算 <span class="hljs-subst">$&#123;num1&#125;</span> * <span class="hljs-subst">$&#123;num2&#125;</span>`</span>);<br><br>    <span class="hljs-comment">// 执行复杂计算</span><br>    <span class="hljs-keyword">const</span> result = num1 * num2;<br><br>    <span class="hljs-comment">// 向主线程发送计算结果</span><br>    parentPort.<span class="hljs-title function_">postMessage</span>(result);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js子进程</title>
    <link href="/2023/09/11/node-js%E5%AD%90%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/09/11/node-js%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-子进程概述"><a href="#一：-子进程概述" class="headerlink" title="一： 子进程概述"></a>一： 子进程概述</h2><p>在Node.js中，子进程是指由主Node.js进程启动的独立的操作系统进程。这些子进程可以执行独立的任务、脚本或外部命令，与主进程并行运行，从而充分利用多核处理器和执行并发任务。<br>Node.js提供了child_process模块，其中包含多种方法来创建、控制和与子进程进行交互。以下是一些常见的用例：</p><ul><li>执行外部命令： child_process.spawn或child_process.exec</li><li>运行独立脚本： child_process.fork创建一个新的Node.js进程，该进程可以运行独立的JavaScript脚本文件。这通常用于创建并发的Node.js进程来处理不同的任务。</li><li>进程间通信： child_process.send和process.on(‘message’)等方法在父子进程之间传递消息和数据。</li><li>并行处理： 通过创建多个子进程，你可以并行处理任务，提高程序性能。这对于处理大量请求或计算密集型任务非常有用。</li></ul><h2 id="二：如何创建子进程"><a href="#二：如何创建子进程" class="headerlink" title="二：如何创建子进程"></a>二：如何创建子进程</h2><h3 id="2-1-spawn-用来执行外部命令"><a href="#2-1-spawn-用来执行外部命令" class="headerlink" title="2.1 spawn 用来执行外部命令"></a>2.1 spawn 用来执行外部命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 执行 ls 命令</span><br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-l&#x27;</span>]);<br><br><span class="hljs-comment">// 处理子进程的输出</span><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程输出：<span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 处理子进程的错误</span><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`子进程错误：<span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 子进程退出时触发</span><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出，退出码 <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="2-2-fork-用来创建子进程并执行node-js文件"><a href="#2-2-fork-用来创建子进程并执行node-js文件" class="headerlink" title="2.2 fork 用来创建子进程并执行node.js文件"></a>2.2 fork 用来创建子进程并执行node.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fork &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 在子进程中执行 child.js 文件</span><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;child.js&#x27;</span>);<br><br><span class="hljs-comment">// 父进程发送消息给子进程</span><br>child.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello from parent&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 处理子进程发送的消息</span><br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`父进程接收到消息：<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(message)&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 子进程退出时触发</span><br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出，退出码 <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-3-exec-来执行外币命令，与spawn不同的是它传输整个的命令字符串"><a href="#2-3-exec-来执行外币命令，与spawn不同的是它传输整个的命令字符串" class="headerlink" title="2.3 exec 来执行外币命令，与spawn不同的是它传输整个的命令字符串"></a>2.3 exec 来执行外币命令，与spawn不同的是它传输整个的命令字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 执行 ls 命令</span><br><span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ls -l&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行错误：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程输出：<span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`子进程错误：<span class="hljs-subst">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="三：主进程与子进程之间如何通讯"><a href="#三：主进程与子进程之间如何通讯" class="headerlink" title="三：主进程与子进程之间如何通讯"></a>三：主进程与子进程之间如何通讯</h2><ol><li>主进程与子进程之间通过child_process模块提供的函数来通讯</li><li>通过网络请求来通讯，如TCP，具体用法是在子进程创建一个tcp客户端，连接到主进程的tcp服务器上。</li><li>一些共享内存的模块如shared-memory</li><li>通过文件来交换数据</li></ol><p>以下是child_process来实现父子进程通讯的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fork &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 创建子进程</span><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;child.js&#x27;</span>);<br><br><span class="hljs-comment">// 向子进程发送消息</span><br>child.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello from the main process&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 监听来自子进程的消息</span><br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`主进程收到消息：<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(message)&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用child_process的相关方法，进程之间通讯的方法</p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js模块</title>
    <link href="/2023/09/11/node-js%E6%A8%A1%E5%9D%97/"/>
    <url>/2023/09/11/node-js%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>本文介绍node.js的常见模块</p><h2 id="二：核心模块列表"><a href="#二：核心模块列表" class="headerlink" title="二：核心模块列表"></a>二：核心模块列表</h2><ol><li>events</li></ol><ul><li>http：用于创建HTTP服务器和处理HTTP请求和响应的模块。</li><li>https：与http模块类似，但用于创建HTTPS服务器和处理HTTPS请求和响应。</li><li>fs：用于文件系统操作，包括读取文件、写入文件、创建文件夹等。</li><li>path：提供与文件路径和目录路径相关的实用功能，用于处理文件路径的构造和解析。</li><li>os：用于访问操作系统的信息，如操作系统平台、CPU架构等。</li><li>events：用于实现事件驱动编程，可用于创建自定义事件和处理事件。</li><li>util：包含一些实用工具函数，如继承、格式化、调试等。</li><li>crypto：提供了加密和解密等密码学功能的模块。</li><li>stream：用于处理流数据的模块，支持可读流和可写流。</li><li>buffer：用于处理二进制数据的模块，提供了缓冲区操作和数据转换功能。</li><li>querystring：用于解析和格式化URL查询字符串的模块。</li><li>url：用于解析和构建URL的模块。</li><li>child_process：用于创建和管理子进程的模块，允许Node.js应用程序与其他进程进行交互。</li><li>net：用于创建TCP服务器和客户端的模块。</li><li>http2：用于创建HTTP&#x2F;2服务器和客户端的模块。</li></ul><h2 id="三：node-js的模块化"><a href="#三：node-js的模块化" class="headerlink" title="三：node.js的模块化"></a>三：node.js的模块化</h2><p>Node.js的模块化是一种组织和封装代码的方法，旨在提高代码的可维护性、可重用性和可扩展性。Node.js支持CommonJS模块系统，这是一种模块化的规范，允许开发者将代码划分为小的、独立的模块，每个模块都可以独立开发、测试和维护。</p><p>相关概念：</p><ul><li>模块（Module）：一个模块就是一个独立的JavaScript文件，它可以包含函数、变量、类等等。每个模块都有自己的作用域，因此模块中的代码不会污染全局作用域。</li><li>导出（Export）：通过module.exports或exports对象，一个模块可以将其内部的函数、变量等暴露给其他模块使用。这些导出的内容可以在其他模块中引入并使用。</li><li>导入（Import）：要在一个模块中使用其他模块导出的内容，可以使用require函数来导入它们。导入的内容会被包含在一个对象中，可以通过该对象来访问导入的函数和变量。</li><li>模块路径（Module Path）：在require函数中，你需要指定要导入的模块的路径。路径可以是相对路径（相对于当前模块）或绝对路径，也可以是模块名，Node.js会根据模块名来查找对应的模块文件。</li><li>核心模块（Core Modules）：Node.js提供了一些内置的核心模块，如http、fs、os等，它们可以直接通过require来使用，无需额外安装。</li><li>第三方模块（Third-party Modules）：除了核心模块，Node.js社区还维护了大量的第三方模块，可以通过npm安装和使用。这些模块可以用于各种用途，从Web框架和数据库驱动到数据处理和工具库等等。</li></ul><h2 id="四：导入模块的过程"><a href="#四：导入模块的过程" class="headerlink" title="四：导入模块的过程"></a>四：导入模块的过程</h2><p>模块导入，是一个同步的过程。</p><ol><li>模块路径解析：当调用require函数时，Node.js首先解析要导入的模块的路径。路径可以是相对路径（相对于当前模块）或绝对路径，也可以是模块名。如果路径是一个模块名，Node.js会尝试查找该模块名对应的模块文件。</li><li>模块缓存：Node.js会检查模块是否已经被加载过。如果模块已经加载并缓存了，Node.js会直接返回缓存的模块，而不会重新加载。这是为了提高性能并避免重复加载。</li><li>模块加载：如果模块没有被缓存，Node.js会根据路径查找对应的模块文件。Node.js支持多种文件扩展名，如.js、.json和.node等。根据路径找到文件后，Node.js会读取文件内容，并将其包装在一个模块封装器函数中。</li><li>模块编译：模块封装器函数会被传递给Node.js的模块编译器，该编译器将JavaScript代码转换为可执行的函数。这个过程包括了词法分析、语法分析和代码生成。</li><li>导出对象：模块中的内容（变量、函数、类等）被包含在一个对象中，这个对象可以通过module.exports或exports来暴露给其他模块。模块的导出对象成为其他模块可以访问的接口。</li><li>返回导出对象：一旦模块加载和编译完成，并且导出对象已经构建，Node.js会将导出对象缓存起来，并将其返回给调用require函数的模块。这样，调用require的模块就可以使用被导出的功能了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http状态码记录</title>
    <link href="/2023/09/11/http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/11/http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。<br>响应分为五类：<br>信息响应(100–199)<br>成功响应(200–299)<br>重定向(300–399)<br>客户端错误(400–499)<br>服务器错误 (500–599)</p><h2 id="二：详解"><a href="#二：详解" class="headerlink" title="二：详解"></a>二：详解</h2><h4 id="2-1-100-199信息相应"><a href="#2-1-100-199信息相应" class="headerlink" title="2.1 100-199信息相应"></a>2.1 100-199信息相应</h4><ul><li>100Continue继续。客户端应继续其请求</li><li>101Switching Protocols切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li></ul><h4 id="2-2-200-299成功相应"><a href="#2-2-200-299成功相应" class="headerlink" title="2.2 200-299成功相应"></a>2.2 200-299成功相应</h4><ul><li>200OK请求成功。一般用于GET与POST请求</li><li>201Created已创建。成功请求并创建了新的资源</li><li>202Accepted已接受。已经接受请求，但未处理完成</li><li>203Non-Authoritative Information非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li><li>204No Content无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205Reset Content重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206Partial Content部分内容。服务器成功处理了部分GET请求</li></ul><h4 id="2-3-300-399重定向"><a href="#2-3-300-399重定向" class="headerlink" title="2.3 300-399重定向"></a>2.3 300-399重定向</h4><ul><li>300Multiple Choices多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301Moved Permanently永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302Found临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303See Other查看其它地址。与301类似。使用GET和POST请求查看</li><li>304Not Modified未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>305Use Proxy使用代理。所请求的资源必须通过代理访问</li><li>306Unused已经被废弃的HTTP状态码</li><li>307Temporary Redirect临时重定向。与302类似。使用GET请求重定向</li></ul><h4 id="2-4-400-499客户端错误"><a href="#2-4-400-499客户端错误" class="headerlink" title="2.4 400-499客户端错误"></a>2.4 400-499客户端错误</h4><ul><li>400Bad Request客户端请求的语法错误，服务器无法理解</li><li>401Unauthorized请求要求用户的身份认证</li><li>402Payment Required保留，将来使用</li><li>403Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404Not Found服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>405Method Not Allowed客户端请求中的方法被禁止</li><li>406Not Acceptable服务器无法根据客户端请求的内容特性完成请求</li><li>407Proxy Authentication Required请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li><li>408Request Time-out服务器等待客户端发送的请求时间过长，超时</li><li>409Conflict服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</li><li>410Gone客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</li><li>411Length Required服务器无法处理客户端发送的不带Content-Length的请求信息</li><li>412Precondition Failed客户端请求信息的先决条件错误</li><li>413Request Entity Too Large由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li><li>414Request-URI Too Large请求的URI过长（URI通常为网址），服务器无法处理</li><li>415Unsupported Media Type服务器无法处理请求附带的媒体格式</li><li>416Requested range not satisfiable客户端请求的范围无效</li><li>417Expectation Failed服务器无法满足Expect的请求头信息</li></ul><h4 id="2-5-500-599服务端错误"><a href="#2-5-500-599服务端错误" class="headerlink" title="2.5 500-599服务端错误"></a>2.5 500-599服务端错误</h4><ul><li>500Internal Server Error服务器内部错误，无法完成请求</li><li>501Not Implemented服务器不支持请求的功能，无法完成请求</li><li>502Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503Service Unavailable由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li><li>504Gateway Time-out充当网关或代理的服务器，未及时从远端服务器获取请求</li><li>505HTTP Version not supported服务器不支持请求的HTTP协议的版本，无法完成处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js事件循环</title>
    <link href="/2023/09/09/node-js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2023/09/09/node-js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>node.js的事件循环，是node.js非阻塞IO的原因，因为非阻塞IO，node.js获得了高性能。</p><h2 id="二：事件循环的阶段"><a href="#二：事件循环的阶段" class="headerlink" title="二：事件循环的阶段"></a>二：事件循环的阶段</h2><p>事件循环的每一个阶段，都有一个队列来执行回调。</p><ul><li>timer ： 处理 setTimeout 和setInterval 回调</li><li>pending callback：执行推迟到下一个事件循环的io回调</li><li>idle prepare：仅内部使用</li><li>poll: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的几乎任何回调（如网络请求，数据库查询，文件读取）;在适当的时机在此处暂停</li><li>check 处理setImmediately回调</li><li>close：处理一些关闭回调，如socket.on(‘close’)回调</li></ul><p>宏任务在不同的队列中被执行，处于事件循环的不同阶段<br>微任务穿插在每一种宏任务之间，即微任务在不同阶段之间执行</p><ul><li>执行process.nexttick就绪的任务</li><li>查看有没有就绪的微任务，如果有，拿出来全部执行</li></ul><h3 id="2-2-微任务与宏任务"><a href="#2-2-微任务与宏任务" class="headerlink" title="2.2 微任务与宏任务"></a>2.2 微任务与宏任务</h3><p>宏任务：</p><ul><li>setTimeout</li><li>setInterval</li><li>I&#x2F;O<br>微任务:</li><li>promises</li><li>process.nextTick</li><li>Object.observe</li></ul><p>每个事件循环迭代包括以下步骤：<br>执行宏任务<br>执行所有微任务</p><!-- 检查是否有宏任务需要执行。如果有，**执行一个宏任务**。执行当前事件循环迭代中的**所有微任务（Micro Task）**。  * 先执行process.nextTick回调  * 然后执行promise --><p>参考：<br><a href="https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick">https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick</a></p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react概述</title>
    <link href="/2023/09/08/react%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/08/react%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>react哲学：页面由组件整合而来</p><h2 id="二：相关概念"><a href="#二：相关概念" class="headerlink" title="二：相关概念"></a>二：相关概念</h2><ol><li>如何创建和嵌套组件：<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>I&#x27;m a button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to my app<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何添加标签和样式<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;img className=<span class="hljs-string">&quot;avatar&quot;</span> /&gt;<br><span class="hljs-comment">/* In your CSS */</span><br>.<span class="hljs-property">avatar</span> &#123;<br>  border-<span class="hljs-attr">radius</span>: <span class="hljs-number">50</span>%;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何显示数据<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hedy Lamarr&#x27;</span>,<br>  <span class="hljs-attr">imageUrl</span>: <span class="hljs-string">&#x27;https://i.imgur.com/yXOvdOSs.jpg&#x27;</span>,<br>  <span class="hljs-attr">imageSize</span>: <span class="hljs-number">90</span>,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.imageUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">Photo</span> <span class="hljs-attr">of</span> &#x27; + <span class="hljs-attr">user.name</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">width:</span> <span class="hljs-attr">user.imageSize</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">height:</span> <span class="hljs-attr">user.imageSize</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何渲染条件和列表<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>  &#123;isLoggedIn ? (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminPanel</span> /&gt;</span></span><br>  ) : (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginForm</span> /&gt;</span></span><br>  )&#125;<br>&lt;/div&gt;<br><br><span class="hljs-keyword">const</span> listItems = products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.id&#125;</span>&gt;</span></span><br><span class="language-xml">    &#123;product.title&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>);<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li><li>如何对事件做出响应并更新界面<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;You clicked me!&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Click me</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">// 更新界面</span><br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Clicked &#123;count&#125; times</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何在组件间共享数据<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params">&#123; count, onClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Clicked &#123;count&#125; times</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Counters that update together<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="三：生产级的react框架"><a href="#三：生产级的react框架" class="headerlink" title="三：生产级的react框架"></a>三：生产级的react框架</h2><ol><li>next.js是一个全栈式的 React 框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-next-app<br></code></pre></td></tr></table></figure></li><li>remix是一个具有嵌套路由的全栈式 React 框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-remix<br></code></pre></td></tr></table></figure></li><li>Gatsby是一个快速的支持 CMS（内容管理系统） 的网站的 React 框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-gatsby<br></code></pre></td></tr></table></figure></li><li>expo 用于原生应用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-expo-app<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>react官网：<a href="https://zh-hans.react.dev/learn">https://zh-hans.react.dev/learn</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通用型支付服务设计概述</title>
    <link href="/2023/09/08/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/08/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>日前应公司业务发展的要求，对支付逻辑进行了拆分，形成了独立支付服务。本文基于服务拆分的实践，探讨建立独立支付服务的思路。<br>文末的关键编码，为处理后的伪代码，与实际项目无关，特此声明。</p><h4 id="一：什么是独立支付服务"><a href="#一：什么是独立支付服务" class="headerlink" title="一：什么是独立支付服务"></a>一：什么是独立支付服务</h4><p>假设有三个不同的项目A,B,C，都需要接入支付宝H5支付功能。按照以往的开发模式，这三个项目需要分别开发一套与支付宝的对话逻辑，包括下单、支付回调、订单支付状态查询等。<br>假设这三个项目，现在要接入微信H5支付和微信JSAPI支付，那么同理，他们需要分别开发一套与微信方的对话逻辑。<br>如果还需要接入其他的支付方式呢？<br>独立支付服务可以理解为这些支付方式的代理，A,B,C在独立支付服务中注册它们的关键支付参数及商品，独立支付服务提供支付流程的保证和在关键的时间节点（订单创建、订单支付成功等）的通知。<br>有了独立支付服务，不管有多少个项目，大家都不需要关注与微信方等的对话逻辑，只需要关注必要的配置及少数几个通知就可以了。</p><h4 id="二：支付服务应包含哪些功能"><a href="#二：支付服务应包含哪些功能" class="headerlink" title="二：支付服务应包含哪些功能"></a>二：支付服务应包含哪些功能</h4><ul><li>客户管理。提供客户的注册、鉴权、关键支付信息（如微信appid）等的存储。</li><li>商品管理。客户创建商品、修改商品价格、设置各种通知接口。</li><li>支付服务。封装与实际支付服务提供者（微信、支付宝）的交互，提供统一的预下单接口，并在关键的时间节点通知客户。</li><li>查询服务。客户主动查询某订单的支付状态。</li></ul><h4 id="三：支付的整体流程是什么"><a href="#三：支付的整体流程是什么" class="headerlink" title="三：支付的整体流程是什么"></a>三：支付的整体流程是什么</h4><p>假设支付平台的服务器为S，客户的服务器为s，客户的前端（支付按钮所在的地方）为c。<br>假设客户A已经在支付平台注册了商品a，并设置当a创建订单和支付成功的时候，都要通知给s。<br>以支付宝H5支付为例。</p><h5 id="当用户点击支付按钮之后，支付流程应该是这样的："><a href="#当用户点击支付按钮之后，支付流程应该是这样的：" class="headerlink" title="当用户点击支付按钮之后，支付流程应该是这样的："></a>当用户点击支付按钮之后，支付流程应该是这样的：</h5><ul><li>c-&gt;S：用户要支付啦，选的是支付宝H5支付，商品是a，数量是1，用户的唯一标识是“15705420001” ，需要带给s那货的信息是”xxxxxx”;</li><li>S-&gt;c：我和支付宝方沟通过了，订单已创建，你的支付参数是*****，订单标识为12345;</li><li>S-&gt;s：有用户创建订单啦，用户是“15705420001”，商品是a，数量是1，你的客户端托我给你带的话是‘xxxxxx’，订单标识是12345；</li><li>c ：用支付参数一顿操作，唤起了支付，用户付款;</li><li>支付宝-&gt;S：订单12345支付成功啦；</li><li>S-&gt;s:  有用户支付订单啦，用户是“15705420001”，商品是a，数量是1，你的客户端托我给你带的话是‘xxxxxx’，订单标识是12345；</li><li>s：记录用户15705420001，买了1个商品a；</li></ul><h6 id="如果s不相信支付成功的通知呢？"><a href="#如果s不相信支付成功的通知呢？" class="headerlink" title="如果s不相信支付成功的通知呢？"></a>如果s不相信支付成功的通知呢？</h6><ul><li>s-&gt;S： 这个订单12345的，确实支付了吗？你去支付宝问问；</li><li>S-&gt;s：问过支付宝了，支付了；</li><li>s：记录用户15705420001，买了1个商品a；</li></ul><h5 id="c从支付宝的支付页面返回之后"><a href="#c从支付宝的支付页面返回之后" class="headerlink" title="c从支付宝的支付页面返回之后"></a>c从支付宝的支付页面返回之后</h5><ul><li>c-&gt;S：麻烦看下12345支付成功了吗；</li><li>S-&gt;c：问过支付宝了，支付了；</li><li>c：跳转支付成功页面；</li></ul><h4 id="四：关键编码"><a href="#四：关键编码" class="headerlink" title="四：关键编码"></a>四：关键编码</h4><p>笔者实践采用的是koa+mysql+redis技术栈，关键编码依然以支付宝h5支付为例。</p><h6 id="4-1：支付宝h5支付"><a href="#4-1：支付宝h5支付" class="headerlink" title="4.1：支付宝h5支付"></a>4.1：支付宝h5支付</h6><ul><li>获取支付参数时<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">const</span> info = <span class="hljs-keyword">await</span> aliH5PayChannel.<span class="hljs-title function_">unifiedOrder</span>(goodsInfo);<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">notifyOrderCreated</span>(goodsInfo, info);<br></code></pre></td></tr></table></figure></li><li>用户支付成功后</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//支付结果通知逻辑</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">notifyPaySuccess</span>(payOrder);<br></code></pre></td></tr></table></figure><ul><li>查询订单</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (orderType == <span class="hljs-variable constant_">ORDERTYPE</span>.<span class="hljs-property">ALIH5PAY</span>) &#123;<br><span class="hljs-keyword">let</span> queryResult = <span class="hljs-keyword">await</span> aliH5PayChannel.<span class="hljs-title function_">queryOrder</span>(orderNo);<br>       <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑陋的中国人</title>
    <link href="/2023/09/08/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/"/>
    <url>/2023/09/08/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>我们常常颂扬中国人的美好品德，但人无完人，民族也是如此。这本书就列举出了中国人的一些不足，读完之后我感觉振聋发聩，暗自告诫自己，在以后的生活中，需要常常自省。</p><h2 id="二：笔记"><a href="#二：笔记" class="headerlink" title="二：笔记"></a>二：笔记</h2><h3 id="2-1-极端自傲与自卑，但缺乏自尊"><a href="#2-1-极端自傲与自卑，但缺乏自尊" class="headerlink" title="2.1 极端自傲与自卑，但缺乏自尊"></a>2.1 极端自傲与自卑，但缺乏自尊</h3><p>造成中国人两个极端，不够平衡。 一方面是绝对的自卑，一方面是绝对的自傲。自卑的时候成了奴才，自傲的时候成了主人，却独独没有自尊。<br>这以至于中国人很难有平等观念，你不是我的主人，我就得是你的主人。这种情景影响到个人心态的封闭。死不认错，但又不断有错，以致使中国人产生一种神经质的恐惧。</p><h3 id="2-2-保护自己为第一，明哲保身"><a href="#2-2-保护自己为第一，明哲保身" class="headerlink" title="2.2 保护自己为第一，明哲保身"></a>2.2 保护自己为第一，明哲保身</h3><p>盖儒家在原则上只提倡个人主义而非集体主义。明哲保身，不入危墙。曰：危邦不入，乱邦不居，天下有道，则见，无道，则隐。邦有道，贫且贱，耻也；邦无道，富且贵焉，耻也。<br>都保护自己畏第一，明哲保身，也就有了：</p><ul><li>不敢想也不敢讲；</li><li>混日子；</li><li>拳头大了就是对；不论对错，以拳头大小论对错</li><li>出个冒尖的因为与自己的做法不符，会说他爱管闲事</li><li>有敬有畏，但缺乏爱；对上敬畏，对下严厉，但缺乏平等的爱</li><li>不太为别人着想；臭鞋扔门口，公共区域乱占，等等</li></ul><h3 id="2-3-合作精神不足"><a href="#2-3-合作精神不足" class="headerlink" title="2.3 合作精神不足"></a>2.3 合作精神不足</h3><p>三个人合作能有八个心眼</p><h3 id="2-4-凡事我例外"><a href="#2-4-凡事我例外" class="headerlink" title="2.4 凡事我例外"></a>2.4 凡事我例外</h3><p>随地吐痰是不对的，看到了我就会上去批评，但我自己是可以吐一吐。<br>闯红灯是不对的，看到了我就会上去批评，但我自己是可以闯一闯。<br>诸如此类</p><h3 id="2-5-崇洋媚外分不清"><a href="#2-5-崇洋媚外分不清" class="headerlink" title="2.5 崇洋媚外分不清"></a>2.5 崇洋媚外分不清</h3><p>崇洋经常被认为是媚外。把西方好的东西拿来，这叫崇洋；向外国人谄媚，巴结讨好，这叫媚外。媚外着实是该批评，但崇洋是为了中华民族的伟大复兴。</p><h3 id="2-6-讲礼但不讲理"><a href="#2-6-讲礼但不讲理" class="headerlink" title="2.6 讲礼但不讲理"></a>2.6 讲礼但不讲理</h3><p>讲理会感觉丢面子，因此往往用逃避讨论的方式来对待，这样有了面子，但拒绝了讲理的过程。</p><h2 id="三：读后心得"><a href="#三：读后心得" class="headerlink" title="三：读后心得"></a>三：读后心得</h2><p>书中林林总总说了许多内容，我细细体会与总结，认为造成中国人不足之处的有以下原因：</p><ol><li>2000年的封建帝制与动荡，造成了中国人自尊的缺失，也使得中国人更多关注家而非国</li><li>儒家明哲保身的思想，禁锢了中国人的血性与灵性</li></ol><h2 id="三：何以促进中华民族的伟大复兴"><a href="#三：何以促进中华民族的伟大复兴" class="headerlink" title="三：何以促进中华民族的伟大复兴"></a>三：何以促进中华民族的伟大复兴</h2><ol><li>虚心而非骄傲，骄傲使人自满，民族亦是如此。一个虚心的民族，一个具有包容性的民族，才能永葆青春与活力</li><li>奋勇争先而非明哲保身。当今世界变化太快，逆水行舟，不进则退。唯有勇于进取，大胆创新，才能不被淘汰。</li><li>合作共赢而非窝里斗。人力有时穷，国家也如此。一个人再厉害，凭他自己也仅能完成有限的工作。唯有习惯合作，善于合作，劲往一处使，才能完成更大的事业</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>曾国藩-又笨又慢平天下</title>
    <link href="/2023/09/08/%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B/"/>
    <url>/2023/09/08/%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>一：概述</p><p>曾国藩，是近代儒家文化的集大成者。</p><p>二：读后感</p><ol><li>勤奋，极度的勤奋是成功的基石</li><li>贵人的赏识是一生中难得的机遇</li><li>纵有万千才华，也要与同僚打成一片</li><li>失败，连续的失败是对心灵考验，通过了能获得极大的提升，通不过有可能因此丧命</li><li>舍小义成全大义</li><li>稳，稳扎稳打，稳中求胜，稳到没有破绽</li></ol><p>笨而极致的勤奋；慢却稳定的前进，是这本书对我最重要的教育。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-ES13</title>
    <link href="/2023/09/07/ES6-ES13/"/>
    <url>/2023/09/07/ES6-ES13/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>ES6 ES7 ES8的名称由来是啥？</p><ul><li>ES6 就是 ES2015</li><li>ES7 就是 ES2016</li><li>ES8 就是 ES2017<br>。。。</li></ul><h2 id="二：各版本的特性"><a href="#二：各版本的特性" class="headerlink" title="二：各版本的特性"></a>二：各版本的特性</h2><ol><li>ES6的新特性<ul><li>let const 块作用域</li><li>箭头函数</li><li>for of </li><li>Map 和 Set</li><li>class</li><li>Promise</li><li>函数参数默认值</li><li>…</li><li>String.includes startsWith endsWith</li><li>Array.find findIndex</li><li>解构赋值</li></ul></li><li>ES7的新特性<ul><li>2 ** 3 &lt;&#x3D;&gt; Math.pow(2,3)</li><li>Array.includes</li></ul></li><li>ES8的新特性  ES2017<ul><li>String 的 padStart  padEnd 长度补全  如：‘5’.padStart(4,0)&#x3D;&gt; ‘0005’</li><li>Object.entries 来遍历对象 for(let [k,v] of Object.entries(obj))</li><li>Object.values</li><li>async await 函数</li></ul></li><li>ES9的新特性<ul><li>在循环中使用await for(){await xxxxx}</li><li>Promise.finally</li><li>对象剩余属性 允许把除了解构出的属性之外的剩余属性，放到一个新的对象中<br>  obj &#x3D; {a:1,b:2,c:3}; let {a,bc}&#x3D;obj &#x3D;&gt; a&#x3D;1 bc &#x3D;{b:2,c:3}</li><li>对象扩展属性 允许把对象的所有属性拷贝到另一个对象中<br>  let c &#x3D; {…obj}</li></ul></li><li>ES10的新特性<ul><li>String.trimStart trimEnd ‘    123’.trimStart &#x3D; ‘123‘</li><li>Object fromEntries     通过一个entries来创建对象</li><li>catch(e){} 如无需访问e，可以改成 catch{…}</li><li>Array flat 数组展平（降N维），默认降1维</li><li>Array flatMap 数组展平 + map</li><li>Array sort</li></ul></li><li>ES11的新特性<ul><li>BigInt</li><li>String matchAll</li><li>x &amp;&amp;&#x3D; y  当x 为真时，把Y赋给X</li><li>x ||&#x3D; y  当x 为假时，把Y赋给X</li><li>x ??&#x3D; y  当x 不存在时，把Y赋给X</li><li>?? 空值运算符,前边为空的时候设置成后边的默认值  x&#x3D; a ?? 0 &lt;&#x3D;&gt; if(a!&#x3D;undefined){x&#x3D;a}else{x&#x3D;0} </li><li>?.xxx   a.x  a存在时取值, 不存在时返回undefined</li></ul></li><li>ES12的新特性<ul><li>Promise.any</li><li>String replaceAll</li><li>Numeric Separators</li><li>数字分割符  1_0000_0000 &#x3D; 100000000</li></ul></li><li>ES13的新特性 即 ES2012<ul><li>Array at</li><li>String at</li><li>await import<br> 等等</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql innodb支持的隔离级别与mvcc</title>
    <link href="/2023/09/06/mysql-innodb%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8Emvcc/"/>
    <url>/2023/09/06/mysql-innodb%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8Emvcc/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-概述"><a href="#一：-概述" class="headerlink" title="一： 概述"></a>一： 概述</h2><p>我们都知道，mysql的默认引擎是innodb引擎，之前也提到过了innodb的数据组织方式（聚集索引）与查询过程。<br>本文我们讨论另外一个问题：即innodb的事务</p><h2 id="二：事务及事务的隔离级别"><a href="#二：事务及事务的隔离级别" class="headerlink" title="二：事务及事务的隔离级别"></a>二：事务及事务的隔离级别</h2><h3 id="2-1-什么是事务"><a href="#2-1-什么是事务" class="headerlink" title="2.1 什么是事务"></a>2.1 什么是事务</h3><p>想象你去银行给老王转账1000，那么银行会怎么操作呢？简单来说第一步扣你的钱，第二步给老王加钱。<br>如果第一步扣完你的钱，第二步执行失败了怎么办？如果没有任何后续处理，你可能会骂娘。<br>那应该怎么整呢？如果失败，把你的钱得加回来，并告知你转账操作失败。<br>转账这件事，不管它有多少个步骤，我们把它作为一个整体来看待，要么整体都成功，要么整体都失败，不存在一部分成功，一部分失败。<br>这就叫事务。</p><h3 id="2-2-事务的特征"><a href="#2-2-事务的特征" class="headerlink" title="2.2 事务的特征"></a>2.2 事务的特征</h3><p>事务有什么特征呢?</p><ol><li>原子性：要么都成功，要么都失败</li><li>一致性：事务开始前，事务结束后，数据库的一致性不能被破坏。</li><li>隔离性：多个事务并发进行时，事务之间是隔离的，一个事务不能影响其他事务</li><li>持久性：改完了应该落盘，持久化保存</li></ol><h3 id="2-3-事物的隔离级别及"><a href="#2-3-事物的隔离级别及" class="headerlink" title="2.3 事物的隔离级别及"></a>2.3 事物的隔离级别及</h3><p>啥叫事务的隔离级别？通俗来说就是并发进行的事务，对彼此的影响程度，影响程度越大，隔离级别越低，反之越高；</p><ol><li>read uncommited 即读未提交，能读到其他事物未提交的数据</li><li>read commited 即读已提交，能读到其他事物已提交的数据</li><li>repeatable read 即可重复度，对于之前读到的数据，后续的每次读，这些数据的值都相同，但可能会读到新的行。</li><li>serializable 串行化，并行的其他事物对本事务完全没影响</li></ol><h3 id="三：innodb支持的事务隔离级别"><a href="#三：innodb支持的事务隔离级别" class="headerlink" title="三：innodb支持的事务隔离级别"></a>三：innodb支持的事务隔离级别</h3><p>innodb支持的隔离级别，来到了serializable<br>怎么做到的呢?</p><ol><li>MVCC：多版本并发控制，行数据有多个版本（快照），每个事务只能读取到事务创建之前的数据快照，并且仅本事务可见，对数据的操作保存在事务缓冲区中，提交以后落到磁盘上。</li><li>锁管理：innodb实现了表级锁，和行级锁。<ul><li>共享&#x2F;排他锁(Shared and Exclusive locks)，是行级锁</li><li>意向锁（Intent locks），是表级锁，意向锁有共享意向锁（IS锁）和排他意向锁（IX锁）</li><li>记录锁（Record locks）</li><li>间隙锁（Gap locks）：锁定一个记录之间的区间，以防止幻读和脏读的发生</li><li>临建锁（Next-key locks）：结合了记录锁和间隙锁的锁，锁定一个记录及其区间，以防止幻读和脏读的发生</li></ul></li><li>redolog：记录了每个事务读对数据库的修改操作，用于数据恢复</li><li>undolog：innodb通过回滚日志来回滚事务，回滚时逆序执行从而保证数据的一致性<br> 如操作时增加一行，那回滚日志中记录的应该是删除该行。</li></ol><h2 id="三-拓展阅读"><a href="#三-拓展阅读" class="headerlink" title="三 拓展阅读"></a>三 拓展阅读</h2><p>关于MVCC：<a href="https://www.51cto.com/article/719614.html">https://www.51cto.com/article/719614.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引建立指导规则及慢查询分析</title>
    <link href="/2023/09/05/mysql%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E5%AF%BC%E8%A7%84%E5%88%99%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/05/mysql%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E5%AF%BC%E8%A7%84%E5%88%99%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>之前的文章中提到过mysql innodb的索引结构，这篇文章探讨mysql的索引建立规则，即慢查询。</p><h2 id="二：索引建立规则"><a href="#二：索引建立规则" class="headerlink" title="二：索引建立规则"></a>二：索引建立规则</h2><ol><li>满足最左前缀匹配原则。在建立索引时需考虑将来的应用场景，及可能的需求变化。</li><li>尽量选择区分度高的列作为索引。区分度 &#x3D; count(distinct col)  &#x2F; count(col) ，通俗来说就是相同的值比较少的列</li><li>尽量的扩展索引而非新建索引</li><li>索引尽量建立在小字段上，一些长的文本字段，不要建立索引</li></ol><h2 id="三：慢查询如何分析"><a href="#三：慢查询如何分析" class="headerlink" title="三：慢查询如何分析"></a>三：慢查询如何分析</h2><ol><li><p>explain 查看执行计划</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">explain <span class="hljs-keyword">select</span> * from xxx <span class="hljs-built_in">where</span> xxxx;<br></code></pre></td></tr></table></figure></li><li><p>开启慢查询日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global show_query_log = on; <span class="hljs-comment"># 这种是在交互式命令中的方式，如果数据库重启，这些就会失效，如果需要长期有效，需要修改mysql的配置文件</span><br>show variables like <span class="hljs-string">&#x27;%long%&#x27;</span>; <br><span class="hljs-built_in">set</span> long_query_time=0.02;// <span class="hljs-comment"># long_query_time是慢查询的临界值单位秒</span><br></code></pre></td></tr></table></figure><p> 慢查询日志的样子：<br> <img src="/pic/manchaxunrizhi.jpg" alt="慢查询日志"></p></li><li><p>开启性能详情</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show variables like <span class="hljs-string">&#x27;%profiling%&#x27;</span><br><span class="hljs-built_in">set</span> profiling = on<br></code></pre></td></tr></table></figure></li></ol><h2 id="四：慢查询的常见原因"><a href="#四：慢查询的常见原因" class="headerlink" title="四：慢查询的常见原因"></a>四：慢查询的常见原因</h2><ol><li>没加索引&#x2F;没用索引导致全表扫描</li><li>单表数据量太大。这种情况看下索引设置的到底对不对，要么考虑分表</li><li>limit 深分页。比方说每页10条，去获取第十万页的数据。 如 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> click <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure> 即使click加了索引，但因为二级索引的叶子结点保存的是主键的值，每条记录还需要回表查询才能知道是否需要丢弃，在该例子中，需要回表100010次，因此会很慢。<br> 这种情况下，需要考虑先查出主键ID，再根据主键查出所有字段 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br>xxx t1,<br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">where</span> click <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10000</span>,<span class="hljs-number">10</span>) t2<br><span class="hljs-keyword">where</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure></li><li>排序不当，导致使用filesort查询<br> 如果  order by xxx 这个xxx不能由查询此sql使用的索引直接完成，mysql就有可能会进行filewort<ul><li>如查询的数量较少，没有超过系统变量sort_buffer_size的大小，会进行内存排序（快排）</li><li>如查询的数量较多，超过了该系统变量，会使用文件进行排序（归并）<br> 会使用filesort查询的场景</li></ul><ol><li>order by 用的字段，不是查询该sql使用到的索引。解决方案：排序字段加索引</li><li>俩排序字段，一个正序，一个倒序，解决方案：可分析需求，然后比方说加个字段，在新的字段上排序，</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引结构及失效情景汇总</title>
    <link href="/2023/09/04/mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%A4%B1%E6%95%88%E6%83%85%E6%99%AF%E6%B1%87%E6%80%BB/"/>
    <url>/2023/09/04/mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%A4%B1%E6%95%88%E6%83%85%E6%99%AF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一：mysql的索引结构"><a href="#一：mysql的索引结构" class="headerlink" title="一：mysql的索引结构"></a>一：mysql的索引结构</h2><p>mysql是一个关系型数据库；<br>mysql的存储引擎最主要的有两个，一个是myisam，一个是innodb，下面我们分别来说明二者的索引结构</p><ol><li><p>myisam</p><ul><li>myisam的索引，结构是B+树，叶子节点保存的是数据记录的地址，也就是说它的索引和数据是分开的，叫非聚簇索引。</li><li>myisam的主键索引和非主键索引本质上没有区别，叶子节点都保存的是数据记录的地址</li></ul></li><li><p>innodb</p><ul><li>innodb的索引，结构是带有数据访问指针的B+树</li><li>主键索引的叶子结点，保存的是数据记录本身；非主键索引的叶子节点，保存的是主键值</li><li>由于innodb的索引，其索引和数据是在一起的，因此被称为聚簇索引</li><li>为提升读取性能，innodb的各节点在磁盘中是一个数据页<ol><li>每个节点是一个磁盘页，这样方便读入内存</li><li>每当访问某磁盘页，将读取其相邻的磁盘页，这个操作叫做磁盘预读，因此其相邻的磁盘页也能很快的被访问到；</li></ol></li><li>由于非叶子结点不存数据，所以这颗B+树的阶非常高（即非叶子结点可以储存非常多的数据项），故数高很小，一个近百万数据的表，可能其数高只有3.</li></ul><p> 一个直观的innodb索引例子：<br> <img src="/pic/innocbbjiatree.jpg" alt="innodbB+树索引"><br> 其中，一个浅蓝色的区域是一个磁盘页，深蓝色的是数据项，P1 P2 P3 是指针</p></li></ol><p>由于mysql的默认引擎是innodb，所以接下来我们的讨论都基于innodb引擎。</p><h2 id="二：B-树的增删改查"><a href="#二：B-树的增删改查" class="headerlink" title="二：B+树的增删改查"></a>二：B+树的增删改查</h2><p>B+树从B树演变而来，与B树的区别是B+树的非叶子节点只保存导航信息，所有数据都保存在叶子结点；<br>下面是一颗深度为4的三阶B+树</p><p><img src="/pic/bjiatree.jpg" alt="b+tree"></p><p>解释:</p><ul><li>每个节点最多有3个子节点，因此叫做3阶</li><li>根节点+非叶节点+叶节点，共4层，因此深度为4</li><li>每个非叶子节点，其节点上都存有</li></ul><p>增删改查要点</p><ul><li>B+树的增，需保持B+树的阶，一旦某节点的子节点数量超过3，需要分裂该节点，并查看父节点是否也有相同的问题。</li><li>B+树的删，同样需保持B+树的阶，B+树的子节点，不得小于m&#x2F;2，小于之后需要合并节点</li><li>B+树的改，不存在节点结构的变化</li><li>B+树的查，时间复杂度为log(n)，具体过程是每次取出一个节点（即读入一个数据页），比较，确定下一步的查询指针，然后继续这个过程。</li></ul><h2 id="三：innodb的查找策略"><a href="#三：innodb的查找策略" class="headerlink" title="三：innodb的查找策略"></a>三：innodb的查找策略</h2><ol><li>主键查询, 查询主键索引即可</li><li>查询用到了非主键索引（也叫辅助索引，二级索引），且所需返回的字段在索引中就有，这时只需要查找辅助索引</li><li>查询用到了非主键索引，如联合索引，所需返回的字段在索引中不全，这时候需要查询主键索引（也叫回表查询）</li><li>如压根没用到索引，需要全表扫描</li></ol><h2 id="四：innodb的索引失效场景"><a href="#四：innodb的索引失效场景" class="headerlink" title="四：innodb的索引失效场景"></a>四：innodb的索引失效场景</h2><ol><li>联合索引不满足最左前缀匹配原则</li><li>索引列参与计算，包括使用了一些函数</li><li>like %在最左边</li><li>类型隐式转换，如在varchar类型的字段上，查找时写int型的值</li><li>使用or操作</li><li>一些比较  &lt;  &gt; !&#x3D; ; isnot null ;not in ; not exists</li></ol><h2 id="五：优化项"><a href="#五：优化项" class="headerlink" title="五：优化项"></a>五：优化项</h2><ol><li>尽量避免使用select * ,而使用select 具体的字段，以期望走覆盖索引</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IM服务器设计与进化</title>
    <link href="/2023/09/03/IM%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%9B%E5%8C%96/"/>
    <url>/2023/09/03/IM%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%9B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>IM：instant messaging ，中文翻译”即时通讯“，干啥的呢？就是我发个消息，你即时的就能看见。<br>那么IM消息的整个系统都有哪些东西呢？</p><ol><li>客户端。用来发送玩家的消息给服务器，接收并显示群内玩家的消息；</li><li>服务端。用来接收并处理玩家的消息，以及给某玩家推送消息<br>有人问客户端自己能不能干这事？不能，因为我想给老王发个消息，但老王在哪我是不知道的，因为老王和我没有连接，所以只好找个中间商，中间商就固定在某个位置，我俩分别于中间商连接，那我俩也就可以连接了。</li></ol><h2 id="二：仅支持单聊的IM消息服务器，IM服务器1-0版"><a href="#二：仅支持单聊的IM消息服务器，IM服务器1-0版" class="headerlink" title="二：仅支持单聊的IM消息服务器，IM服务器1.0版"></a>二：仅支持单聊的IM消息服务器，IM服务器1.0版</h2><p>还是我和老王，我俩都连接了服务器这个中间商，我俩想通个话，怎么整呢？</p><ol><li>首先，我与服务器建立了连接，这个连接有一个唯一的标识，</li><li>然后，老王也与服务器建立了连接，这个连接也有一个唯一的标识</li><li>我想向老王发送一条消息：“吃了吗？”</li><li>那么我先向IM消息服务器发一条消息，说我想向老王发条消息。</li><li>IM服务器接收到了这条消息，它看看在线的人里面有没有老王，发现有，然后把消息发送给老王，然后告诉我发送成功。</li><li>老王接收到这条消息，我本地在服务器告诉我成功之后，也显示了这条消息。</li></ol><p>上边是通俗的讲法，下面是技术的讲法</p><ol><li>我与im服务器建立长连接，如通过socketio建立了长连接 s1，登录信息与长连接的关系保存到服务器，如&lt;playerId1: s1&gt;</li><li>老王与im服务器建立长连接，如通过socketio建立了长连接 s2，登录信息与长连接的关系保存到服务器，如&lt;playerId2: s2&gt;</li><li>我发言，本质上是客户端通过s1，向服务器发送消息：<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">sendMessage:</span> &#123;playerId = playerId2, message = <span class="hljs-string">&quot;吃了吗&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li>IM服务器接收到之后，在缓存中找有没有playerId2，如有，通过playerId2找到s2, 然后通过s2将message发送给playerId2, 同时将此信息发送给playerId1一份。</li><li>双方收到服务器推送的消息，分别展示这条消息</li></ol><p>如此设计，一个简单的单聊IM服务器，就成型了。</p><p>那么它有什么问题？</p><ol><li>只能单聊，群聊暂不支持。我想8个人一起聊，不能实现。</li><li>如果有人掉线了，发向此人的消息他接收不到，那人重新上线，也无法看到，简单来说这条消息丢了。</li></ol><h2 id="三：支持群聊和消息历史的IM服务器，IM消息服务器2-0版"><a href="#三：支持群聊和消息历史的IM服务器，IM消息服务器2-0版" class="headerlink" title="三：支持群聊和消息历史的IM服务器，IM消息服务器2.0版"></a>三：支持群聊和消息历史的IM服务器，IM消息服务器2.0版</h2><p>1.0版本解决只能单聊和消息丢失的问题，那么如何解决？</p><p>通俗来讲：</p><ol><li>通过发言前建立群组，把想群聊的这些人的信息归于一处，来支持群聊，这样就能知道你的发言应该发给谁谁谁</li><li>通过把发言备份到一个可靠的地方，作为历史发言记录，解决消息丢失的问题</li></ol><p>下面是技术的讲法</p><ol><li>playerId1,playerId2,playerId3分别于im服务器通过socketio建立了长连接 s1,s2,s3</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，创建个群组的数据group: {playerIds:[playerId1,playerId2,playerId3]},然后告知playerId1成功，并且通知到playerId2和playerId3这个组建群聊成功</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM收到该请求，查找到该群聊，查找到群聊中的playerid1,2,3，然后分别向playerId1,2,3发送此条消息，并且存储此条群聊的消息到数据库（如redis,mongodb）</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>如果playerId3 断线之后，playerId2说了句“去吃饭”呢？</p><ol><li>客户端保存有群聊最大的消息序号x，与im服务器建立长连接后，先问IM服务器询问目前最新的消息序号y，如x&lt;y，说明客户端存着的消息是滞后的，因此通过请求IM服务器的方式拿到x之后的群聊消息，并及时更新自己的最大消息序号到y</li></ol><p>看起来目前的版本已经支持了群聊，也解决了消息丢失问题。那么它还有什么问题？</p><ol><li>当同时发言的人数多的时候，这台服务器会处理不过来，表现为消息发出去以后老半天不见动静</li></ol><h2 id="四，理论上支持无限人聊天的IM服务器，IM服务器3-0版"><a href="#四，理论上支持无限人聊天的IM服务器，IM服务器3-0版" class="headerlink" title="四，理论上支持无限人聊天的IM服务器，IM服务器3.0版"></a>四，理论上支持无限人聊天的IM服务器，IM服务器3.0版</h2><p>2.0版本的单台服务器在人多时的性能问题，该如何解决？<br>答曰，分布式。分布式也就是多服务的意思，这些服务可能在一个服务器，也可能在多个服务器，这种方式理论上能近乎无限的提升服务的性能，但他会带来一些挑战：</p><ol><li>群聊里的人可能来自不同的服务器，因此消息发送将更复杂</li><li>当多人近乎同时发送消息时，需要保证群聊里的所有人完整，准确，顺序相同的拿到这些人的发言。不能顺序不一样，更不能缺失。</li></ol><p>那么服务器该如何设计呢？<br>通俗来讲：</p><ol><li>客户端创建的群组信息，要所有服务器都能看到，且都能获取，并且群组信息里除了要有用户的ID之外，还得有他在哪台服务器，这样才能找到这个用户在哪</li><li>用户上线时，需要更新一下群组信息，说明我目前连的是这台服务器</li><li>对于来自同一个群组内同时发言的这些请求，不管它有多少，整个服务器部分同时只处理一个</li></ol><p>下面是技术的讲法</p><ol><li>playerId1,playerId2,playerId3分别于im服务器A,B,C 通过socketio建立了长连接 s1,s2,s3</li><li>playerId1,2,3,分别更新自己在数据库中的数据，使server&#x3D;A&#x2F;B&#x2F;C</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，查找数据库，找到playerId1,2,3的数据，拿到各自的server，并创建群组的数据<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">group: &#123;players:[<br>  &#123;id:playerId1,server:A,socket:s1&#125;,<br>  &#123;id:playerId2,server:B,socket:s2&#125;,<br>  &#123;id:playerId3,server:C,socket:s3&#125;,<br>]&#125;,<br></code></pre></td></tr></table></figure>然后告知playerId1成功，并且通知发送消息给B和C，中的playerId2和playerId3这个组建群聊成功</li><li>IM的全局kafka消费者实例，订阅群聊的topic : “群聊ID”，xxxxx.subscribe(‘xxxx’);</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM接收到kafka的消息后，取出群聊消息，查找到该群聊，查找到群聊中的playerid1,2,3，拿到各自的server，然后向playerId1,2,3发送此条消息，并且存储此条群聊的消息到数据库（如redis,mongodb）</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>对于多个服务来说，各服务的在线状态需要同步，如果当前的流量较大，还需要动态的新增服务，简单来说服务需要管理。kubernetes集群是个可行的方案。</p><p>看起来目前的版本已经支持了分布式的服务，那么它还有什么问题？</p><ol><li>逻辑更复杂，客户端连接与消息处理的逻辑耦合在一起，IM服务器的代码将更加复杂，系统的可维护性降低</li><li>可测试性下降，单元测试和集成测试可能需要启动整个im服务器来进行</li><li>耦合性强，难以将消息的处理部分抽离出来，用于其他功能或服务</li><li>代码维护困难，很好理解，越复杂，就越难维护。</li></ol><h2 id="五，架构更优的IM服务器，IM服务器4-0版"><a href="#五，架构更优的IM服务器，IM服务器4-0版" class="headerlink" title="五，架构更优的IM服务器，IM服务器4.0版"></a>五，架构更优的IM服务器，IM服务器4.0版</h2><p>3.0版本的高耦合问题，该如何解决？</p><p>通俗来讲：</p><ol><li>将IM服务器的管理客户端连接，群组管理，发送消息的功能；与对消息的处理功能，分开，各自干各自的事情</li></ol><p>下面是技术的讲法：</p><ol><li>新建若干消息消费者服务器，这些服务器用于消息处理</li><li>IM服务器只负责管理与客户端的连接，群组管理，向客户端发送消息，以及接收来自消费者服务器的消息</li></ol><p>当玩家创建群组时：</p><ol><li>playerId1,playerId2,playerId3分别于im服务器A,B,C 通过socketio建立了长连接 s1,s2,s3</li><li>playerId1,2,3,分别更新自己在全局redis集群中的数据，即playerId1的server&#x3D;A，</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，查找数据库（redis），找到playerId1,2,3的server，并创建群组的数据，并保存到数据库（如redis）<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-attribute">group</span>: &#123;<span class="hljs-attribute">players</span>:[<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId1</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId2</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId3</span>&#125;,<br>]&#125;,<br></code></pre></td></tr></table></figure>然后告知playerId1成功，并且通知发送消息给B和C，中的playerId2和playerId3这个组建群聊成功</li><li>IM通知消息服务，消息服务接到通知后开始subscribe 此topic, topic名字是群组的ID</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li></ol><p>当玩家发言时：</p><ol><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM接收到请求，验证playerId1的身份，将消息存入数据库，并向kafka发送一条消息。topic为群聊ID<br>3.消息消费者拿到来自kafka的消息后，取出群聊的消息，在redis中找到该群聊，取出其中的playerId, 然后从全局redis中找到playerId对应的server，然后给对应的IM服务器发送消息，类似如{server:A,playerId:’playerId1’,”message”:”干啥去”}</li><li>IM服务器接收到来自消息消费者的消息后，验证是否连接有playerId, 如果有，通过socketio向该用户发消息</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>目前的架构，有如下特征：</p><ol><li>IM服务可以是任意多个，负责处理连接，管理群组，发送消息</li><li>消息消费者服务可以是任意多个，负责处理消息，形成明确的消息发送指令，并给到IM服务</li><li>kafka作为中间件存在，负责异步转同步，流量削峰</li><li>IM和消息消费者服务职责明确，有利于维护</li></ol><p>看起来似乎不错了，那么它还有哪些问题？</p><ol><li>鉴权，不是什么人都能发消息，因此需要增加鉴权</li><li>全局的redis来储存用户所在的server信息，一旦redis挂了，所有人都不能聊天了，因此可以考虑redis与mongodb结合，缓存+DB的形式，这将增加开发的复杂度</li><li>消息发从到kafka这段如果失败，就会消息丢失，需要设计个类似接收回执的逻辑</li></ol><p>但主体的架构已经完成，总体来说是个还不错的IM服务器架构。</p><p>这里先空着，我将给出架构图：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> empty <br></code></pre></td></tr></table></figure><h2 id="六：下一代IM服务器的方向在哪里"><a href="#六：下一代IM服务器的方向在哪里" class="headerlink" title="六：下一代IM服务器的方向在哪里"></a>六：下一代IM服务器的方向在哪里</h2><p>本着大胆想象的原则，让我们畅想一下下一代的IM服务器。<br>但我这里还没有具体的答案，但大概有一些关键词，如AI，去中心化和边缘计算，有待思考和讨论</p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器和容器化技术概述</title>
    <link href="/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：容器和容器化"><a href="#一：容器和容器化" class="headerlink" title="一：容器和容器化"></a>一：容器和容器化</h2><ol><li>什么是容器<br> 容器是一种轻量级，可移植的封装，它包括应用程序及其依赖项，以便在不同的计算环境中运行。简单来说他就是个集装箱，包含有应用程序及它运行所需的各种支持。</li><li>什么是镜像<br> 镜像是一个只读的文件系统快照，包含了一个应用程序及其所有依赖项的文件和设置。这个快照可以用于创建运行容器的实例。镜像包含了应用程序的二进制文件、库、环境变量、配置文件等，使得容器能够在隔离的环境中运行。</li><li>什么是容器化和容器化技术<br> 容器化是一种应用程序部署和交付的方法，它是一种理念，旨在将应用程序及其依赖项打包成一个可移植的容器，容器可以可以在不同的环境中运行。<br> 容器化技术是实现这一理念的一些工具和技术，包括容器运行时（docker，containd,podman），镜像（docker镜像，OCI镜像），容器编排工具（Kubernetes，docker compose等）等</li></ol><h2 id="二：Docker概述"><a href="#二：Docker概述" class="headerlink" title="二：Docker概述"></a>二：Docker概述</h2><p>Docker 是一种容器化平台，用于创建、部署和管理容器化应用程序。</p><h3 id="2-1-Docker-的主要功能"><a href="#2-1-Docker-的主要功能" class="headerlink" title="2.1 Docker 的主要功能"></a>2.1 Docker 的主要功能</h3><ol><li>容器化：Docker 允许开发人员将应用程序及其依赖项打包成容器，使应用程序具有独立性、可移植性和一致性，可以在不同环境中运行。</li><li>镜像管理：Docker 镜像是容器的基础，它们包含了应用程序和其依赖项的文件系统快照。Docker 提供了创建、管理和共享镜像的工具。</li><li>容器编排：Docker 提供了容器编排工具，如 Docker Compose 和 Docker Swarm，用于管理多个容器的部署，实现高可用性、负载均衡和伸缩性。</li><li>跨云部署：Docker 容器可以在不同的云提供商之间轻松迁移，支持多云部署策略。</li><li>快速启动和停止：Docker 容器可以在几秒内启动和停止，加速了应用程序的部署和扩展。</li></ol><h3 id="2-2-Docker的组件"><a href="#2-2-Docker的组件" class="headerlink" title="2.2 Docker的组件"></a>2.2 Docker的组件</h3><p>Docker 由以下主要组件组成：</p><ol><li>Docker Daemon（Docker 服务端）：后台运行的服务，负责管理容器的创建、启动、停止、删除等任务。</li><li>Docker 客户端：用户与 Docker 交互的命令行工具或 API 客户端，可发送指令给 Docker Daemon。</li><li>Docker 镜像：容器的基础，包含应用程序及其依赖项的文件系统快照。</li><li>Docker 镜像仓库：用于存储和共享 Docker 镜像的中央存储库，Docker Hub 是一个常见的公共仓库。</li><li>Dockerfile：文本文件，包含创建 Docker 镜像的指令和配置信息。</li><li>Docker 网络：用于容器之间通信以及与外部网络连接的网络配置。</li><li>Docker 数据卷：用于容器内外数据共享和持久性存储的机制。</li><li>Docker Compose：用于定义和运行多个 Docker 容器的应用程序的工具。</li></ol><h3 id="2-3-如何使用docker"><a href="#2-3-如何使用docker" class="headerlink" title="2.3 如何使用docker"></a>2.3 如何使用docker</h3><ol><li>创建dockerFile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用官方 Node.js 镜像作为基础镜像</span><br>FROM node:14<br><br><span class="hljs-comment"># 设置工作目录</span><br>WORKDIR /usr/src/app<br><br><span class="hljs-comment"># 复制项目文件到容器中</span><br>COPY package*.json ./<br>COPY . .<br><br><span class="hljs-comment"># 安装项目依赖</span><br>RUN npm install<br><br><span class="hljs-comment"># 暴露端口</span><br>EXPOSE 3000<br><br><span class="hljs-comment"># 启动应用程序</span><br>CMD [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]<br></code></pre></td></tr></table></figure></li><li>构建镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t my-node-app .<br></code></pre></td></tr></table></figure></li><li>运行Docker容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 3000:3000 -d my-node-app<br></code></pre></td></tr></table></figure></li></ol><h2 id="三：kubernetes概述"><a href="#三：kubernetes概述" class="headerlink" title="三：kubernetes概述"></a>三：kubernetes概述</h2><p>大服务集群上容器的部署，伸缩和管理的各种问题，衍生出来了容器编排引擎，比较著名的有 Mesos, DockerSwarm, Kubernetes。<br>Kubernetes名字太长了，叫起来有点麻烦，而Kubernetes首字母与结尾字母之间有8个字母，因此被称作K8S。</p><h3 id="3-1-kubernetes的相关概念"><a href="#3-1-kubernetes的相关概念" class="headerlink" title="3.1 kubernetes的相关概念"></a>3.1 kubernetes的相关概念</h3><p>k8s概念及架构</p><ol><li>cluster<br>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用</li><li>master<br>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master</li><li>node<br>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。Node运行在Linux操作系统上，可以是物理机或者是虚拟机。</li><li>pod<br>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。同一个pod管理的多个容器之间可以通信和资源共享。</li><li>controller<br>Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。Controller中定义了Pod的部署特性，比如有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等</li><li>service<br>Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。<br>Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。</li><li>namespace<br>Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的</li></ol><h3 id="3-2-kubernetes的架构"><a href="#3-2-kubernetes的架构" class="headerlink" title="3.2 kubernetes的架构"></a>3.2 kubernetes的架构</h3><h4 id="3-2-1：-master节点"><a href="#3-2-1：-master节点" class="headerlink" title="3.2.1： master节点"></a>3.2.1： master节点</h4><p><img src="/pic/kubernetes-master.jpg" alt="master"></p><p>master是kubernetes cluster的大脑</p><ul><li>API Server：提供HTTP&#x2F;HTTPS RESTful API，即Kubernetes API。API Server是Kubernetes Cluster的前端接口，各种客户端工具（CLI或UI）以及Kubernetes其他组件可以通过它管理Cluster的各种资源</li><li>Scheduler：负责决定将Pod放在哪个Node上运行。Scheduler在调度时会充分考虑Cluster的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</li><li>Controller Manager：负责管理Cluster各种资源，保证资源处于预期的状态。Controller Manager由多种controller组成，包括replicationcontroller、endpoints controller、namespace controller、serviceaccountscontroller等。不同的controller管理不同的资源。例如，replication controller管理Deployment、StatefulSet、DaemonSet的生命周期，namespacecontroller管理Namespace资源</li><li>etcd：负责保存Kubernetes Cluster的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速地通知Kubernetes相关组件</li><li>Pod网络：Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案</li><li>kubelet和kube-proxy见node节点的结构（master同时也是一个node，可以运行应用）</li></ul><h4 id="3-2-2：-node节点"><a href="#3-2-2：-node节点" class="headerlink" title="3.2.2： node节点"></a>3.2.2： node节点</h4><p>node是pod运行的地方。</p><p><img src="/pic/kubernetes-node.jpg" alt="node"></p><ul><li>kubelet：kubelet是Node的agent，当Scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息（image、volume等）发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。</li><li>kube-proxy：kube-proxy负责将访问service的TCP&#x2F;UPD数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡</li><li>pod网络：同上</li></ul><h4 id="3-2-3：单master架构"><a href="#3-2-3：单master架构" class="headerlink" title="3.2.3：单master架构"></a>3.2.3：单master架构</h4><p><img src="/pic/kubernetes-master-node.jpg" alt="gingle-master"></p><h3 id="3-3：组件间的协作"><a href="#3-3：组件间的协作" class="headerlink" title="3.3：组件间的协作"></a>3.3：组件间的协作</h3><p>kubectl run httpd-app –image&#x3D;httpd –replicas&#x3D;2 发生了什么？</p><p><img src="/pic/kubernetes-4.jpg" alt="image"></p><ol><li>kubectl发送部署请求到API Server</li><li>API Server通知Controller Manager创建一个deployment资源</li><li>Scheduler执行调度任务，将两个副本Pod分发到k8s-node1和k8s-node2</li><li>k8s-node1和k8s-node2上的kubectl在各自的节点上创建并运行Pod</li></ol><h3 id="3-4：kubectl命令"><a href="#3-4：kubectl命令" class="headerlink" title="3.4：kubectl命令"></a>3.4：kubectl命令</h3><p>kubectl的语法：kubectl [command] [TYPE] [NAME] [flags]</p><ul><li>command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete</li><li>type：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式</li><li>name：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息，如 kubectl get pods</li><li>flags：指定可选的参数。例如，可以使用 -s 或 -server 参数指定 Kubernetes API 服务器的地址和端口</li></ul><p>常用命令示例：</p><ul><li>kubectl get pods</li><li>kubectl get nodes</li><li>kubectl create -f nginx-deployment.yaml</li><li>kubectl delete po rc-nginx-btv4j</li><li>kubectl scale rc rc-nginx-3 —replicas&#x3D;4</li><li>kubectl logs mysql-478535978-1dnm2</li><li>kubectl expose rc nginx –port&#x3D;80 –target-port&#x3D;8000（为RC的nginx创建service，并通过Service的80端口转发至容器的8000端口上）</li><li>kubecl run xxxxx 创建并运行一个或多个容器镜像</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>《每天五分钟玩转Kubernetes》</li><li>《深入浅出Docker》</li><li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">kubernetes官方交互式教程</a>：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">kubectl命令文档</a>：<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create</a></li><li><a href="http://docs.kubernetes.org.cn/475.html">kubectl中文文档</a>：<a href="http://docs.kubernetes.org.cn/475.html">http://docs.kubernetes.org.cn/475.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英文字母起源</title>
    <link href="/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/"/>
    <url>/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>英语的26个字母最初起源于埃及象形文字，后由腓尼基人改进发明了腓尼基字母，希腊人对腓尼基字母加以改革后创造了希腊字母，古罗马人对希腊字母加以改革进而发明了拉丁字母，英文字母就属于拉丁字母。</p><h2 id="二：拉丁字母的起源，含义及引申含义"><a href="#二：拉丁字母的起源，含义及引申含义" class="headerlink" title="二：拉丁字母的起源，含义及引申含义"></a>二：拉丁字母的起源，含义及引申含义</h2><p>A 牛头 牛角；引申为牛角尖锐，针刺，酸痛，食物中最重要的部分<br>B 房屋；<br>C 骆驼；引申为运输，行走，携带，覆盖<br>D 门；引申为向下<br>E 窗户；引申为开关窗户的动作，向外伸延，引申，透过窗户可以看到外面<br>F 失败；引申为错误，失败；由附着引申为漂浮，表面，刀剑等含义<br>G 骆驼的头颈部；由C变化而来，引申为从深处出来，向深处拉<br>H 栅栏；人，围墙，连接，界限，高处；引申为相邻的房间<br>I 手指；人，树，水滴；引申为尖端，一点，火，目标，插，按，蜡烛，多代表与光明相关的东西<br>J 由I变化而来；表勾，挖，捏，握紧，夹紧等手指弯曲做出的动作；<br>K 手掌；张开，拖，压，推等手掌做的动作，引申为统治者，张开，裂开，开口，锋利，打架等<br>L 鞭子；引申含义：拉，抽，打，绕、绑东西的动作，长的，长远的，男性，驯服<br>M 海浪；山峰，引申含义： 男性 牢固 坚强 力量 多 咬合 匹配 合并 碰撞 记忆<br>N 鱼；引申：捞，收缩，摆动，跳跃，连接<br>O 眼睛；引申：转动 范围 开关 循环 观察 圆 女性<br>P 嘴唇；扁的，紧贴，吹，吐，含，吸，引申为向上，突出，顶端<br>Q 垂着尾巴的猴子；引申：收缩，汇集，挠，跳等猴子的动作；象征女性头部，表示女人， 问题<br>R 狗；代表生命力强的，侦查，看守，记忆，杂乱 引申：上司，高层，火苗，河流，招手，跑步<br>S 牙齿，沙丘；代表坚硬，相似，锋利，痕迹，咬，撕开等牙的特征和动作。引申为口舌，女人，流沙，蛇，音符，沙丘，弯腰动作，身体<br>T 叉号；引申为符号，字符，信息，识别，指示，启示，长久，不变，固定，神 工具<br>U 木栓孔; 由V延伸而来；引申含义有宽裕的 间距 容纳 器具 集中<br>V 木钉；引申为拉动，插动，活动，保卫，防护，固定，钉子，山谷，交叉，空，空虚<br>W 由V派生而来；double u,两个门栓，含义由保障，引申为女性 水 错误<br>X 问号；代表未知，无限，目标，希望，极致，顶峰，高贵，冷艳，完美，引申为交叉，四面八方，迷惑，错误<br>Y 早期将Y认为是上边的V和下面的I的组合; 引申：分支，道路，裂开，裂缝，岔生，产生，青年，年轻的，从前，确定<br>Z 宙斯；引申狂热，热情，速度，曲折的</p><h2 id="三：总结"><a href="#三：总结" class="headerlink" title="三：总结"></a>三：总结</h2><p>通过以上的统计，我们得出如下规律</p><h4 id="3-1-字形上，一些字母由其他字母演变而来"><a href="#3-1-字形上，一些字母由其他字母演变而来" class="headerlink" title="3.1 字形上，一些字母由其他字母演变而来"></a>3.1 字形上，一些字母由其他字母演变而来</h4><ol><li>G由C变化而来</li><li>J由I变化而来</li><li>U,W由V延伸而来</li><li>Y是一个意外，把上边的V和下边的I看成了一个字母</li></ol><h4 id="3-2-子母的含义，由几部分组成"><a href="#3-2-子母的含义，由几部分组成" class="headerlink" title="3.2 子母的含义，由几部分组成"></a>3.2 子母的含义，由几部分组成</h4><ol><li>基本含义</li><li>由基本含义引申出的含义</li><li>由字形特征引申出的含义</li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>generator函数与Async/await函数</title>
    <link href="/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>generator函数是一个迭代器</p><h2 id="二-详情"><a href="#二-详情" class="headerlink" title="二 详情"></a>二 详情</h2><p>Generator 函数是ECMAScript 6（ES6）中的一种特殊类型的函数，它能够产生迭代器（Iterator）。与普通的函数不同，Generator 函数可以暂停执行并随时恢复执行，而不会丢失函数的内部状态。这使得它们在处理异步操作、流控制和延迟执行方面非常有用。</p><p>Generator 函数通过使用特殊的关键字 function* 来声明，并在函数体内部使用 yield 表达式来暂停函数的执行并返回一个产生的值。每次调用 yield 都会暂停函数的执行，同时返回一个迭代器对象，您可以使用该迭代器对象来恢复函数的执行。调用生成器函数不会立即执行函数体，而是返回一个生成器对象，您需要显式地调用该生成器对象的 next() 方法来触发函数的执行。</p><p>简单来说：Generator函数是一个迭代器。</p><p>一个Generator函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-params">millionSeconds</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">res</span>(<span class="hljs-number">1</span>);<br>        &#125;, millionSeconds);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFunc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">generatorFunc</span>();<br>    <span class="hljs-keyword">let</span> a = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next a=`</span>, a);<br>    <span class="hljs-keyword">let</span> b = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-keyword">let</span> bResult = <span class="hljs-keyword">await</span> b.<span class="hljs-property">value</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next b=`</span>, b, <span class="hljs-string">`bResult = <span class="hljs-subst">$&#123;bResult&#125;</span>`</span>);<br>    <span class="hljs-keyword">let</span> c = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next c=`</span>, c);<br>    <span class="hljs-keyword">let</span> d = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next d=`</span>, d);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>());<br>&#125;<br><span class="hljs-title function_">test</span>();<br><br></code></pre></td></tr></table></figure><p>结合以上例子，我们来总结一下generator函数的用法：</p><ol><li>generator函数需要用“*”来声明</li><li>yield 后面需要跟的是可被迭代的东西 ，数值，表达式都行</li><li>如果yield后面跟一个promise，那么执行时迭代到这里，next中的value也是一个promise，需要自己手动去await执行</li><li>每次next，都会返回一个对象，该对象中的value表示被迭代的值，done表示是否完毕</li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从koa到koa2</title>
    <link href="/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/"/>
    <url>/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-Koa2简介及与Koa1的区别"><a href="#一：-Koa2简介及与Koa1的区别" class="headerlink" title="一： Koa2简介及与Koa1的区别"></a>一： Koa2简介及与Koa1的区别</h2><p>Koa2是Koa1框架的升级版本，目前已经是koa的默认版本；<br>相较于Koa1，Koa2引入了一些重要的变化和改进。以下是Koa2相对于Koa1的一些区别：</p><ol><li>Koa 1 使用 Generator 函数来处理中间件和异步操作，而 Koa 2 直接支持 async&#x2F;await，让中间件的编写和理解更加简洁明了</li></ol><p>下面我们从使用的角度分别分析：</p><h2 id="二：Koa2的Async-Await支持"><a href="#二：Koa2的Async-Await支持" class="headerlink" title="二：Koa2的Async&#x2F;Await支持"></a>二：Koa2的Async&#x2F;Await支持</h2><p>现在我们使用koa1来实现一个中间件，该如何做呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * (next) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">someAsyncFunction</span>(); <span class="hljs-comment">// Yielding async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> next;<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>koa2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">xxxx</span>(); <span class="hljs-comment">// Await async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>Koa2的中间件函数采用 async (ctx, next) &#x3D;&gt; {…}，而在 Koa1中是function * (next) {…}。Koa2直接支持Async&#x2F;Await，使得中间件的编写和理解更加简洁。</p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析koa的koa-compose</title>
    <link href="/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/"/>
    <url>/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa-compose 是koa用来合并中间件的工具，并且在中间件内部，原各个中间件的执行过程为洋葱式的。<br>本文我们从源码的角度，去看洋葱式是什么？它又是如何实现的？</p><h4 id="二：源码"><a href="#二：源码" class="headerlink" title="二：源码"></a>二：源码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middleware)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware stack must be an array!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码精简</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中的重要逻辑：</p><ul><li>返回值为一个中间件A</li><li>中间件数组的执行，是从第一个开始的</li><li>执行某中间件时，同时传入了下一个中间件（赋值为next），并通过调用next来执行该中间件</li><li>数组中中间件执行完毕后，执行A的下一个中间件</li></ul><h4 id="三：next与洋葱模型"><a href="#三：next与洋葱模型" class="headerlink" title="三：next与洋葱模型"></a>三：next与洋葱模型</h4><p>上回说到，next是用来执行下一个中间件的，那么在某中间件中，next的执行可能有以下情况</p><h5 id="3-1-在最开始调用"><a href="#3-1-在最开始调用" class="headerlink" title="3.1 在最开始调用"></a>3.1 在最开始调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-2-在中间调用"><a href="#3-2-在中间调用" class="headerlink" title="3.2 在中间调用"></a>3.2 在中间调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-3-在末尾调用"><a href="#3-3-在末尾调用" class="headerlink" title="3.3 在末尾调用"></a>3.3 在末尾调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h5><p>由于以下两条显而易见的规则：</p><ul><li>在某中间件内，next之前的代码先于next之后的代码执行</li><li>对某中间件来说，next执行完毕的标志，是其后所有的中间件均执行完毕</li></ul><p>故而中间件执行的过程有以下特征：</p><ul><li>先执行各个中间件next之前的代码，再执行各个中间件next之后的代码</li><li>各中间件next之前的代码，执行顺序为按照中间件顺序，从前向后</li><li>各中间件next之后的代码，执行顺序为按照中间件顺序，从后向前</li></ul><p>最后祭出那颗著名的葱：</p><p><img src="/pic/yangcong.jpg" alt="洋葱模型"></p><p>参考:<br><a href="https://github.com/koajs/compose.git">https://github.com/koajs/compose.git</a></p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koa源码学习及最简实现</title>
    <link href="/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa是基于nodejs平台的下一代web框架（官网描述）<br>官网地址：<a href="https://koa.bootcss.com/">https://koa.bootcss.com/</a><br>git地址：<a href="https://github.com/koajs/koa.git">https://github.com/koajs/koa.git</a><br>koa提供基于http服务的最简的框架模型，包括洋葱式的中间件处理逻辑、对请求和响应的封装等。</p><h4 id="二：使用"><a href="#二：使用" class="headerlink" title="二：使用"></a>二：使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><br><span class="hljs-keyword">let</span> koa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>koa.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);<br>    ctx.<span class="hljs-property">body</span> = &#123; <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> &#125;;<br>&#125;);<br><br>koa.<span class="hljs-title function_">listen</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server listen 5000&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="三：源码"><a href="#三：源码" class="headerlink" title="三：源码"></a>三：源码</h4><p>源码的lib下共四个文件：application.js，context.js，request.js，response.js</p><h5 id="3-1-application-js"><a href="#3-1-application-js" class="headerlink" title="3.1 application.js"></a>3.1 application.js</h5><p>application.js是暴露给外部的入口，关键代码：</p><h6 id="3-1-1-use"><a href="#3-1-1-use" class="headerlink" title="3.1.1 use"></a>3.1.1 use</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;middleware must be a function!&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isGeneratorFunction</span>(fn)) &#123;<br>    <span class="hljs-title function_">deprecate</span>(<span class="hljs-string">&#x27;Support for generators will be removed in v3. &#x27;</span> +<br>              <span class="hljs-string">&#x27;See the documentation for examples of how to convert old middleware &#x27;</span> +<br>              <span class="hljs-string">&#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;</span>);<br>    fn = <span class="hljs-title function_">convert</span>(fn);<br>  &#125;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;use %s&#x27;</span>, fn.<span class="hljs-property">_name</span> || fn.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;-&#x27;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>use方法接收中间件（即函数），并将其放入middleware数组中；<br>return this，用于支持use的链式调用；</p><h6 id="3-1-2-listen"><a href="#3-1-2-listen" class="headerlink" title="3.1.2 listen"></a>3.1.2 listen</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;listen&#x27;</span>);<br>  <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>  <span class="hljs-keyword">return</span> server.<span class="hljs-title function_">listen</span>(...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>koa提供的服务，本质上是nodejs的http模块提供的。koa定义了自己的callback函数用来接收请求和返回结果；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onerror</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createContext</span>(req, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> handleRequest;<br>&#125;<br></code></pre></td></tr></table></figure><p>compose函数是koa-compose提供的，其作用是将多个中间件整理成一个中间件，在此中间件内部，原来的多个中间件的执行过程是洋葱式的；<br>createContext的作用是封装req,res为一个context对象，该对象经handleRequest函数传入每一个中间件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = ctx.<span class="hljs-property">res</span>;<br>  res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onerror</span> = err =&gt; ctx.<span class="hljs-title function_">onerror</span>(err);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResponse</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">respond</span>(ctx);<br>  <span class="hljs-title function_">onFinished</span>(res, onerror); <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx).<span class="hljs-title function_">then</span>(handleResponse).<span class="hljs-title function_">catch</span>(onerror);<br>&#125;   <br></code></pre></td></tr></table></figure><p>当所有中间件执行完毕，调用handleResponse函数，来返回结果</p><h5 id="3-2-context-js"><a href="#3-2-context-js" class="headerlink" title="3.2 context.js"></a>3.2 context.js</h5><p>包含createContext的返回对象相关的一些方法</p><h5 id="3-3-request-js"><a href="#3-3-request-js" class="headerlink" title="3.3 request.js"></a>3.3 request.js</h5><p>基于http.createServer中callback内的参数 req，封装了一些方法</p><h5 id="3-4-response-js"><a href="#3-4-response-js" class="headerlink" title="3.4 response.js"></a>3.4 response.js</h5><p>基于http.createServer中callback内的参数 res，封装了一些方法</p><h4 id="四：最简实现"><a href="#四：最简实现" class="headerlink" title="四：最简实现"></a>四：最简实现</h4><p>假设不考虑参数验错，req和res封装等，最简的类koa模型应该具备以下特征</p><ul><li>支持增加中间件</li><li>中间件的执行流程为洋葱式</li><li>context传入每个中间件，以实现中间件间的数据共享</li><li>具备处理各种事件的能力，如error事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Emitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-compose&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleKoa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Emitter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>        server.<span class="hljs-title function_">listen</span>(...args);<br>    &#125;<br><br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenrCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br>        <span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> ctx = &#123;<br>                req,<br>                res<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handleRequest;<br>    &#125;<br><br>    <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
