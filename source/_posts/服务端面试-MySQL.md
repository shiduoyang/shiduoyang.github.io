---
title: 服务端面试一-MySQL
date: 2023-11-02 17:03:44
tags:
---

bin日志与redolog的区别：
1. bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志，而 redo log 只记 InnoDB 存储引擎的日志。
2. 记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。
3. 写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。
4. 写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。

更新sql的执行过程
1. 找到修改的行后，读到内存，修改内容并同步到内存。
2. innodb引擎写redolog，并将这行记录的状态改为prepare
3. server层记录binlog
4. 提交事务，并在redolog中将该行的状态改为commit

那为什么要两阶段提交呢？
为什么要两阶段提交呢？直接提交不行吗？

我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。


优化mysql慢查询
* 避免不必要的列
* 分页的优化：延迟关联，书签方式
* 索引优化：使用覆盖索引，联合索引时符合最左前缀匹配原则，避免用!= < >, 避免用函数运算，文本查询通配符尽量避免%xxx%
* join优化：尽量用join替代子查询，子查询会创建一张临时表；关联查询时用小表驱动大表，即小left join 大
* 排序优化：设计索引时候，尽量既能满足查询又能满足排序

explain的type字段
type 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。
性能从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

* system
system：当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘 IO，速度非常快
* const
const：表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。
* eq_ref
eq_ref：查询时命中主键primary key 或者 unique key索引， type 就是 eq_ref。
* ref_or_null
ref_or_null：这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行。
* index_merge
index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。
* unique_subquery
unique_subquery：替换下面的 IN子查询，子查询返回不重复的集合。
* index_subquery
index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。
* range
range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用 bettween...and、<、>、<=、in 等条件查询 type 都是 range。
* index
index：Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。
* ALL 全表扫描。


Extra 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：
Using index：表示 MySQL 将使用覆盖索引，以避免回表
Using where：表示会在存储引擎检索之后再进行过滤
Using temporary ：表示对查询结果排序时会使用一个临时表。

索引失效的场景：
1. 不满足最左前缀匹配原则
2. 查询条件用了><!=,函数计算
3. 隐式类型转换，如查询条件的值是个字符串，但没有用引号包裹
4. mysql优化器判断全表扫描比用索引还快

聚簇索引和非聚簇索引的区别
1. 聚簇索引叶子结点保存的是数据行，非聚簇索引叶子结点保存的不是数据行，而是主键的ID

回表查询
在辅助索引上查出来主键值后，在主键索引上再查一遍得到数据行的操作，叫回表

覆盖索引
在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。

最左前缀匹配：
用name,age建立联合索引，建立索引树时，当name 相等的时候，age才是有序的。
这个时候我们使用 where name= ‘张三‘ and age = ‘20 ‘去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较 age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的时候 name 是第一个比较因子，所以就没用上索引。

索引下推优化
联合索引遇到非等值查询时终止了，之前需要分别回表查询，但有了索引下推，可以在联合索引里判定。
如where a like 'a%' and b>0 and c >0,且建立了联合索引a,b,c
索引下推之前：引擎层like 'a%' and b>0 => 回表查询
索引下推之前：引擎层like 'a%' and b>0 and c >0 => 回表查询

锁的分类：
如果按锁粒度划分，有以下 3 种：
表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。
行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。
页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般
如果按照兼容性，有两种，
共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。
排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。

说说 InnoDB 里的行锁实现
Record Lock 记录锁
Gap Lock 间隙锁：间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个左开右开空间，如 1,6都有数据，那么(1,6)是间隙
Next-key Lock 临键锁：临键指的是间隙加上它右边的记录组成的左开右闭区间
Insert Intention Lock 插入意向锁，锁的是间隙。 一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap 锁 的那个事务提交。

当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。

那 ACID 靠什么保证的呢？
MySQL 通过事务管理和持久性存储机制来确保 ACID（原子性、一致性、隔离性和持久性）。
01、原子性（Atomicity），undo log 记录了事务发生之前的数据，如果事务失败，InnoDB 会根据 undo log 回滚数据。
02、一致性（Consistency）一致性是 ACID 的目的，也就是说，只要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。
03、隔离性 (Isolation) MVCC (多版本并发控制) 机制来处理并发事务，确保每个事务都有自己的数据版本。事务查看数据时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。
在 MVCC 中，每次更新记录时，都会生成记录的一个新版本，而不是覆盖老版本。每个版本都会有两个额外的属性：一个表示版本的创建时间（或事务ID），另一个表示版本的过期时间（或下一个版本的事务ID）。
当事务尝试读取记录时，它会看到该事务开始时有效的那个版本。
MVCC 通过提供数据版本来支持事务的隔离性。不同的事务会看到不同版本的数据行，这取决于事务的开始时间和它的隔离级别。
04、持久性 (Durability)，由 MySQL 的存储引擎（如InnoDB）通过写入磁盘来确保。即使在系统崩溃之后，已提交事务的更改也不会丢失。
InnoDB 使用“redo log”来记录数据的更改，在系统崩溃后，redo log 可用于恢复数据。
redo log 是一种物理日志，记录了对数据页的物理更改。当事务进行写操作时，InnoDB 首先会写入 redo log，并不会立即修改数据文件。这种写入方式被称为“write-ahead logging”（先写日志）。


高可用：

读写分离

那读写分离的分配怎么实现呢？
1. 程序代码封装
程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 "中间层封装" ） ，实现读写操作分离和数据库服务器连接的管理
如TDDL (Taobao Distributed Data Layer, 外号：头都大了）、基于 Hibernate 进行简单封装
2. 中间件封装
中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。
对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。

主从复制原理了解吗？
master 数据写入，更新 binlog
master 创建一个 dump 线程向 slave 推送 binlog
slave 连接到 master 的时候，会创建一个 IO 线程接收 binlog，并记录到 relay log 中继日志中
slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步
slave 记录自己的 binglog

主从同步延迟怎么处理
主从同步延迟的原因
一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致，主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。

解决：
1. 写操作后的读操作指定发给数据库主服务器
2. 读从机失败后再读一次主机
这就是通常所说的 "二次读取" ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。
3. 关键业务读写操作全部指向主机，非关键业务采用读写分离

你们一般是怎么分库的呢
1. 垂直分库：拆表，不同的表在不同库
2. 水平分库：拆记录，不同行分到不同的库中

那你们是怎么分表的？
1. 垂直：拆字段，不同字段分到不同的表中
2. 水平：拆行，不同行分到不同的表中
