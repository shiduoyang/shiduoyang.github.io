---
title: 服务端面试-Redis
date: 2023-11-09 18:15:13
tags:
---

1. redis是什么
一个高性能内存数据库，数据也可以写入磁盘中意保证数据的不丢失，而且redis的操作是原子性的
2. redis的优缺点
优点：
    1. 基于内存操作，速度快
    2. 支持多种数据类型
    3. 支持持久化 RDB 和 AOF
    4. 支持事务，其操作都是原子性的，同时redis还支持对几个操作合并之后的原子性执行
    5. 支持主从复制
缺点：
    1. 对结构化查询的支持比较差
    2. 数据库容量受内存容量的限制
    3. 很难支持在线扩容
3. redis为什么这么快
    1. 基于内存
    2. IO多路复用模型
    3. 高效的数据结构，对数据类型底层做了优化，目的是为了追求更快的速度
4. redis的线程模型
多个套接字、IO多路复用程序、文件事件分派器、事件处理器。
因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型
文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
当被监听的套接字准备好执行连接accept、read、write、close等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件
虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。
5. redis的应用场景
    1. 缓存热点数据
    2. 计数器
    3. 分布式锁
    4. 简单的消息队列，用redis自身的发布订阅模式或者list来实现简单的消息队列，实现一步操作
    5. 限速器，比方说限制某个用户访问某个接口的频率
    6. 好友关系：利用集合的一些命令，实现共同好友，共同爱好之类的功能
5. redis与memcached的区别
memcached数据结构单一，仅用来缓存数据，二reddis支持多种数据类型。
memcached不支持持久化，redis支持
Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。
Redis 的速度比 Memcached 快很多。Redis 使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞 IO 模型。（Redis6.0引入了多线程IO，用来处理网络数据的读写和协议解析，但是命令的执行仍然是单线程）
value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。

6.Redis 数据类型有哪些？
    基本数据类型：
    1、String：最常用的一种数据类型，String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。
    2、Hash：Hash 是一个键值对集合。
    3、Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。
    4、List：有序可重复的集合，底层是依赖双向链表实现的。
    5、SortedSet：有序Set。内部维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。
    特殊的数据类型：
    1、Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。Bitmap的长度与集合中元素个数无关，而是与基数的上限有关。
    2、Hyperloglog。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。
    3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。

7. Redis的内存用完了会怎样？如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回）。也可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。
8. Redis如何做内存优化？
可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。
9. keys命令存在的问题？
redis的单线程的。keys指令会导致线程阻塞一段时间，直到执行完毕，服务才能恢复。scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是O(1)，但是要真正实现keys的功能，需要执行多次scan。
scan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会有以下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键。
10. Redis事务事务的原理是将一个事务范围内的若干命令发送给Redis，然后再让Redis依次执行这些命令。


1. redis的数据结构有哪些
    * string
    * hash
    * set
    * zset
    * list
2. redis为什么这么快
    1. 基于内存
    2. I/O多路复用技术，支持并发的连接
    3. 且用一个线程处理所有的命令。
    **省去了山下文切换的时间，不用考虑锁的问题；且可处理并发的连接** 
            基于I/O多路复用机制的线程模型，可以处理并发的连接
            * 文件处理器包含四个部分（接收请求，放队列，每次拿一个，处理）
                1. 多个socket
                2. IO多路复用程序（用来接收各种请求）
                3. 文件事件分派器
                4. 事件处理器（命令请求处理器，命令回复处理器，命令应答处理器）
            * “多路”指的是多个网络连接；“复用”指的是复用同一个线程
            * 多路I/O复用模型是利用select，poll,epoll可以同时检查多个流的I/O的能力
    3. 在数据存储时会有选择的使用不同的底层数据结构
        1. list在容量较小时，存成zipList,否则linkedList
        2. hash在容量较小时，也会存成ziplist，否则存成hashtable
        3. zset在容量较小时，也会存成ziplist, 否则存成skipList, 同时保存在字典和跳跃表中
3. 为什么redis是单线程
    * 用一个线程来处理所有网络请求
4. redis是单线程，如何发挥多核CPU的优势
    * 在单机开多个redis实例
4. select poll epoll 了解吗
    他们都是IO多路复用的机制
    * select  事件驱动模型只用单线程执行，适合创建一个简单的事件驱动的服务器程序，它有最大连接数的限制
    * pool 原理与select相似，他没有最大连接数的限制
    * epoll 是一种I/O事件通知机制，是linux内核实现IO多路复用的一个实现。I/O多路复用是：在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，单后对其操作
    效率更高：select pool 都是用轮训的方式，epoll是事件通知的形式
5. skipList的结构了解吗？
    * skiplist的结构，是在有序的链表之上建立索引
    * 其查找的时间复杂度，是log2n
6. redis缓存穿透，击穿，雪崩是什么，该如何解决
    * 缓存穿透：找一个缓存中没有的数据，只能去DB查
        * 解决：缓存空对象
        * 解决2：布隆过滤器（用某比特位表示key是否存在，需要对某key进行hash计算得到一个位的位置）
    * 缓存击穿：缓存键过期时，大量的请求穿过缓存，进入DB
        * key永不过期
        * 分布式锁，同时只有一个请求重新加载热点数据到缓存中，其他的等待（同时只能有一个请求获取到该key的锁进行查询）
    * 缓存雪崩：大量的键过期
        * 将每个key的过期时间打散
7. redis的应用场景
    1. 做缓存
    2. 做排行榜
    3. 当锁
8. redis的持久化
    1. rdb 
    2. aof
9. redis的过期策略和淘汰策略
    1. 过期策略：处理键过期
        * 定时删除：设定过期时间时创建个定时器
        * 惰性删除：每次取key时检查该key是否过期
        * 定期删除：每隔一段时间删
    2. 淘汰策略：处理当内存满的时候，删除数据用
        * 默认策略：不删除，拒绝写入，并报错
        * allkeys-lru: 所有key用最近最少使用（LRU）淘汰
        * allkeys-lfu：所有key用最不常用算法淘汰
        * volatile-lru： 从设置了过期时间的 key 中使用 LRU 算法进行淘汰；
        * volatile-lfu： 从设置了过期时间的 key 中使用 LFU 算法进行淘汰；
        * allkeys-random： 从所有 key 中随机淘汰数据；
        * volatile-random： 从设置了过期时间的 key 中随机淘汰数据；
        * volatile-ttl： 在设置了过期时间的key中，淘汰过期时间剩余最短的。

10. 管道pipline
    1. 管道 从请求上或者响应上批量处理