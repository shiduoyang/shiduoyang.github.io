---
title: 容器和容器化技术概述
date: 2023-09-01 15:10:48
tags:
    - Docker
    - Kubernetes
categories: 
    - Docker
---

## 一：容器和容器化
1. 什么是容器
    容器是一种轻量级，可移植的封装，它包括应用程序及其依赖项，以便在不同的计算环境中运行。简单来说他就是个集装箱，包含有应用程序及它运行所需的各种支持。
2. 什么是镜像
    镜像是一个只读的文件系统快照，包含了一个应用程序及其所有依赖项的文件和设置。这个快照可以用于创建运行容器的实例。镜像包含了应用程序的二进制文件、库、环境变量、配置文件等，使得容器能够在隔离的环境中运行。
3. 什么是容器化和容器化技术
    容器化是一种应用程序部署和交付的方法，它是一种理念，旨在将应用程序及其依赖项打包成一个可移植的容器，容器可以可以在不同的环境中运行。
    容器化技术是实现这一理念的一些工具和技术，包括容器运行时（docker，containd,podman），镜像（docker镜像，OCI镜像），容器编排工具（Kubernetes，docker compose等）等

## 二：Docker概述
Docker 是一种容器化平台，用于创建、部署和管理容器化应用程序。
### 2.1 Docker 的主要功能

1. 容器化：Docker 允许开发人员将应用程序及其依赖项打包成容器，使应用程序具有独立性、可移植性和一致性，可以在不同环境中运行。
2. 镜像管理：Docker 镜像是容器的基础，它们包含了应用程序和其依赖项的文件系统快照。Docker 提供了创建、管理和共享镜像的工具。
3. 容器编排：Docker 提供了容器编排工具，如 Docker Compose 和 Docker Swarm，用于管理多个容器的部署，实现高可用性、负载均衡和伸缩性。
4. 跨云部署：Docker 容器可以在不同的云提供商之间轻松迁移，支持多云部署策略。
5. 快速启动和停止：Docker 容器可以在几秒内启动和停止，加速了应用程序的部署和扩展。

### 2.2 Docker的组件
Docker 由以下主要组件组成：
1. Docker Daemon（Docker 服务端）：后台运行的服务，负责管理容器的创建、启动、停止、删除等任务。
2. Docker 客户端：用户与 Docker 交互的命令行工具或 API 客户端，可发送指令给 Docker Daemon。
3. Docker 镜像：容器的基础，包含应用程序及其依赖项的文件系统快照。
4. Docker 镜像仓库：用于存储和共享 Docker 镜像的中央存储库，Docker Hub 是一个常见的公共仓库。
5. Dockerfile：文本文件，包含创建 Docker 镜像的指令和配置信息。
6. Docker 网络：用于容器之间通信以及与外部网络连接的网络配置。
7. Docker 数据卷：用于容器内外数据共享和持久性存储的机制。
8. Docker Compose：用于定义和运行多个 Docker 容器的应用程序的工具。

### 2.3 如何使用docker
1. 创建dockerFile
```bash 
# 使用官方 Node.js 镜像作为基础镜像
FROM node:14

# 设置工作目录
WORKDIR /usr/src/app

# 复制项目文件到容器中
COPY package*.json ./
COPY . .

# 安装项目依赖
RUN npm install

# 暴露端口
EXPOSE 3000

# 启动应用程序
CMD ["node", "app.js"]
```
2. 构建镜像
``` bash
docker build -t my-node-app .
```
3. 运行Docker容器
``` bash
docker run -p 3000:3000 -d my-node-app
```
## 三：kubernetes概述
大服务集群上容器的部署，伸缩和管理的各种问题，衍生出来了容器编排引擎，比较著名的有 Mesos, DockerSwarm, Kubernetes。
Kubernetes名字太长了，叫起来有点麻烦，而Kubernetes首字母与结尾字母之间有8个字母，因此被称作K8S。
### 3.1 kubernetes的相关概念
k8s概念及架构
1. cluster
Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用
2. master
Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master
3. node
Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。Node运行在Linux操作系统上，可以是物理机或者是虚拟机。
4. pod
Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。同一个pod管理的多个容器之间可以通信和资源共享。
5. controller
Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。Controller中定义了Pod的部署特性，比如有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等
6. service
Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。
Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。
7. namespace
Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的
### 3.2 kubernetes的架构
#### 3.2.1： master节点

![master](/pic/kubernetes-master.jpg)

master是kubernetes cluster的大脑

*   API Server：提供HTTP/HTTPS RESTful API，即Kubernetes API。API Server是Kubernetes Cluster的前端接口，各种客户端工具（CLI或UI）以及Kubernetes其他组件可以通过它管理Cluster的各种资源
*   Scheduler：负责决定将Pod放在哪个Node上运行。Scheduler在调度时会充分考虑Cluster的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。
*   Controller Manager：负责管理Cluster各种资源，保证资源处于预期的状态。Controller Manager由多种controller组成，包括replicationcontroller、endpoints controller、namespace controller、serviceaccountscontroller等。不同的controller管理不同的资源。例如，replication controller管理Deployment、StatefulSet、DaemonSet的生命周期，namespacecontroller管理Namespace资源
*   etcd：负责保存Kubernetes Cluster的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速地通知Kubernetes相关组件
*   Pod网络：Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案
*   kubelet和kube-proxy见node节点的结构（master同时也是一个node，可以运行应用）

#### 3.2.2： node节点

node是pod运行的地方。

![node](/pic/kubernetes-node.jpg)

*   kubelet：kubelet是Node的agent，当Scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息（image、volume等）发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。
*   kube-proxy：kube-proxy负责将访问service的TCP/UPD数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡
*   pod网络：同上

#### 3.2.3：单master架构

![gingle-master](/pic/kubernetes-master-node.jpg)

### 3.3：组件间的协作

kubectl run httpd-app --image=httpd --replicas=2 发生了什么？

![image](/pic/kubernetes-4.jpg)

1.  kubectl发送部署请求到API Server
2.  API Server通知Controller Manager创建一个deployment资源
3.  Scheduler执行调度任务，将两个副本Pod分发到k8s-node1和k8s-node2
4.  k8s-node1和k8s-node2上的kubectl在各自的节点上创建并运行Pod

### 3.4：kubectl命令

kubectl的语法：kubectl [command] [TYPE] [NAME] [flags]

*   command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete
*   type：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式
*   name：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息，如 kubectl get pods
*   flags：指定可选的参数。例如，可以使用 -s 或 -server 参数指定 Kubernetes API 服务器的地址和端口

常用命令示例：

*   kubectl get pods
*   kubectl get nodes
*   kubectl create -f nginx-deployment.yaml
*   kubectl delete po rc-nginx-btv4j
*   kubectl scale rc rc-nginx-3 —replicas=4
*   kubectl logs mysql-478535978-1dnm2
*   kubectl expose rc nginx --port=80 --target-port=8000（为RC的nginx创建service，并通过Service的80端口转发至容器的8000端口上）
*   kubecl run xxxxx 创建并运行一个或多个容器镜像

## 参考链接

*   《每天五分钟玩转Kubernetes》
*   《深入浅出Docker》
*   [kubernetes官方交互式教程](https://kubernetes.io/docs/tutorials/kubernetes-basics/)：[https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)
*   [kubectl命令文档](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create)：[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create)
*   [kubectl中文文档](http://docs.kubernetes.org.cn/475.html)：[http://docs.kubernetes.org.cn/475.html](http://docs.kubernetes.org.cn/475.html)
