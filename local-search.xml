<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>容器和容器化技术概述</title>
    <link href="/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：容器和容器化"><a href="#一：容器和容器化" class="headerlink" title="一：容器和容器化"></a>一：容器和容器化</h2><ol><li>什么是容器<br> 容器是一种轻量级，可移植的封装，它包括应用程序及其依赖项，以便在不同的计算环境中运行。简单来说他就是个集装箱，包含有应用程序及它运行所需的各种支持。</li><li>什么是镜像<br> 镜像是一个只读的文件系统快照，包含了一个应用程序及其所有依赖项的文件和设置。这个快照可以用于创建运行容器的实例。镜像包含了应用程序的二进制文件、库、环境变量、配置文件等，使得容器能够在隔离的环境中运行。</li><li>什么是容器化和容器化技术<br> 容器化是一种应用程序部署和交付的方法，它是一种理念，旨在将应用程序及其依赖项打包成一个可移植的容器，容器可以可以在不同的环境中运行。<br> 容器化技术是实现这一理念的一些工具和技术，包括容器运行时（docker，containd,podman），镜像（docker镜像，OCI镜像），容器编排工具（Kubernetes，docker compose等）等</li></ol><h2 id="二：Docker概述"><a href="#二：Docker概述" class="headerlink" title="二：Docker概述"></a>二：Docker概述</h2><p>Docker 是一种容器化平台，用于创建、部署和管理容器化应用程序。</p><h3 id="2-1-Docker-的主要功能"><a href="#2-1-Docker-的主要功能" class="headerlink" title="2.1 Docker 的主要功能"></a>2.1 Docker 的主要功能</h3><ol><li>容器化：Docker 允许开发人员将应用程序及其依赖项打包成容器，使应用程序具有独立性、可移植性和一致性，可以在不同环境中运行。</li><li>镜像管理：Docker 镜像是容器的基础，它们包含了应用程序和其依赖项的文件系统快照。Docker 提供了创建、管理和共享镜像的工具。</li><li>容器编排：Docker 提供了容器编排工具，如 Docker Compose 和 Docker Swarm，用于管理多个容器的部署，实现高可用性、负载均衡和伸缩性。</li><li>跨云部署：Docker 容器可以在不同的云提供商之间轻松迁移，支持多云部署策略。</li><li>快速启动和停止：Docker 容器可以在几秒内启动和停止，加速了应用程序的部署和扩展。</li></ol><h3 id="2-2-Docker的组件"><a href="#2-2-Docker的组件" class="headerlink" title="2.2 Docker的组件"></a>2.2 Docker的组件</h3><p>Docker 由以下主要组件组成：</p><ol><li>Docker Daemon（Docker 服务端）：后台运行的服务，负责管理容器的创建、启动、停止、删除等任务。</li><li>Docker 客户端：用户与 Docker 交互的命令行工具或 API 客户端，可发送指令给 Docker Daemon。</li><li>Docker 镜像：容器的基础，包含应用程序及其依赖项的文件系统快照。</li><li>Docker 镜像仓库：用于存储和共享 Docker 镜像的中央存储库，Docker Hub 是一个常见的公共仓库。</li><li>Dockerfile：文本文件，包含创建 Docker 镜像的指令和配置信息。</li><li>Docker 网络：用于容器之间通信以及与外部网络连接的网络配置。</li><li>Docker 数据卷：用于容器内外数据共享和持久性存储的机制。</li><li>Docker Compose：用于定义和运行多个 Docker 容器的应用程序的工具。</li></ol><h3 id="2-3-如何使用docker"><a href="#2-3-如何使用docker" class="headerlink" title="2.3 如何使用docker"></a>2.3 如何使用docker</h3><ol><li>创建dockerFile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用官方 Node.js 镜像作为基础镜像</span><br>FROM node:14<br><br><span class="hljs-comment"># 设置工作目录</span><br>WORKDIR /usr/src/app<br><br><span class="hljs-comment"># 复制项目文件到容器中</span><br>COPY package*.json ./<br>COPY . .<br><br><span class="hljs-comment"># 安装项目依赖</span><br>RUN npm install<br><br><span class="hljs-comment"># 暴露端口</span><br>EXPOSE 3000<br><br><span class="hljs-comment"># 启动应用程序</span><br>CMD [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]<br></code></pre></td></tr></table></figure></li><li>构建镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t my-node-app .<br></code></pre></td></tr></table></figure></li><li>运行Docker容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 3000:3000 -d my-node-app<br></code></pre></td></tr></table></figure></li></ol><h2 id="三：kubernetes概述"><a href="#三：kubernetes概述" class="headerlink" title="三：kubernetes概述"></a>三：kubernetes概述</h2><p>大服务集群上容器的部署，伸缩和管理的各种问题，衍生出来了容器编排引擎，比较著名的有 Mesos, DockerSwarm, Kubernetes。<br>Kubernetes名字太长了，叫起来有点麻烦，而Kubernetes首字母与结尾字母之间有8个字母，因此被称作K8S。</p><h3 id="3-1-kubernetes的相关概念"><a href="#3-1-kubernetes的相关概念" class="headerlink" title="3.1 kubernetes的相关概念"></a>3.1 kubernetes的相关概念</h3><p>k8s概念及架构</p><ol><li>cluster<br>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用</li><li>master<br>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master</li><li>node<br>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。Node运行在Linux操作系统上，可以是物理机或者是虚拟机。</li><li>pod<br>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。同一个pod管理的多个容器之间可以通信和资源共享。</li><li>controller<br>Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。Controller中定义了Pod的部署特性，比如有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等</li><li>service<br>Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。<br>Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。</li><li>namespace<br>Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的</li></ol><h3 id="3-2-kubernetes的架构"><a href="#3-2-kubernetes的架构" class="headerlink" title="3.2 kubernetes的架构"></a>3.2 kubernetes的架构</h3><h4 id="3-2-1：-master节点"><a href="#3-2-1：-master节点" class="headerlink" title="3.2.1： master节点"></a>3.2.1： master节点</h4><p><img src="/pic/kubernetes-master.jpg" alt="master"></p><p>master是kubernetes cluster的大脑</p><ul><li>API Server：提供HTTP&#x2F;HTTPS RESTful API，即Kubernetes API。API Server是Kubernetes Cluster的前端接口，各种客户端工具（CLI或UI）以及Kubernetes其他组件可以通过它管理Cluster的各种资源</li><li>Scheduler：负责决定将Pod放在哪个Node上运行。Scheduler在调度时会充分考虑Cluster的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</li><li>Controller Manager：负责管理Cluster各种资源，保证资源处于预期的状态。Controller Manager由多种controller组成，包括replicationcontroller、endpoints controller、namespace controller、serviceaccountscontroller等。不同的controller管理不同的资源。例如，replication controller管理Deployment、StatefulSet、DaemonSet的生命周期，namespacecontroller管理Namespace资源</li><li>etcd：负责保存Kubernetes Cluster的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速地通知Kubernetes相关组件</li><li>Pod网络：Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案</li><li>kubelet和kube-proxy见node节点的结构（master同时也是一个node，可以运行应用）</li></ul><h4 id="3-2-2：-node节点"><a href="#3-2-2：-node节点" class="headerlink" title="3.2.2： node节点"></a>3.2.2： node节点</h4><p>node是pod运行的地方。</p><p><img src="/pic/kubernetes-node.jpg" alt="node"></p><ul><li>kubelet：kubelet是Node的agent，当Scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息（image、volume等）发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。</li><li>kube-proxy：kube-proxy负责将访问service的TCP&#x2F;UPD数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡</li><li>pod网络：同上</li></ul><h4 id="3-2-3：单master架构"><a href="#3-2-3：单master架构" class="headerlink" title="3.2.3：单master架构"></a>3.2.3：单master架构</h4><p><img src="/pic/kubernetes-master-node.jpg" alt="gingle-master"></p><h3 id="3-3：组件间的协作"><a href="#3-3：组件间的协作" class="headerlink" title="3.3：组件间的协作"></a>3.3：组件间的协作</h3><p>kubectl run httpd-app –image&#x3D;httpd –replicas&#x3D;2 发生了什么？</p><p><img src="/pic/kubernetes-4.jpg" alt="image"></p><ol><li>kubectl发送部署请求到API Server</li><li>API Server通知Controller Manager创建一个deployment资源</li><li>Scheduler执行调度任务，将两个副本Pod分发到k8s-node1和k8s-node2</li><li>k8s-node1和k8s-node2上的kubectl在各自的节点上创建并运行Pod</li></ol><h3 id="3-4：kubectl命令"><a href="#3-4：kubectl命令" class="headerlink" title="3.4：kubectl命令"></a>3.4：kubectl命令</h3><p>kubectl的语法：kubectl [command] [TYPE] [NAME] [flags]</p><ul><li>command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete</li><li>type：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式</li><li>name：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息，如 kubectl get pods</li><li>flags：指定可选的参数。例如，可以使用 -s 或 -server 参数指定 Kubernetes API 服务器的地址和端口</li></ul><p>常用命令示例：</p><ul><li>kubectl get pods</li><li>kubectl get nodes</li><li>kubectl create -f nginx-deployment.yaml</li><li>kubectl delete po rc-nginx-btv4j</li><li>kubectl scale rc rc-nginx-3 —replicas&#x3D;4</li><li>kubectl logs mysql-478535978-1dnm2</li><li>kubectl expose rc nginx –port&#x3D;80 –target-port&#x3D;8000（为RC的nginx创建service，并通过Service的80端口转发至容器的8000端口上）</li><li>kubecl run xxxxx 创建并运行一个或多个容器镜像</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>《每天五分钟玩转Kubernetes》</li><li>《深入浅出Docker》</li><li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">kubernetes官方交互式教程</a>：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">kubectl命令文档</a>：<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create</a></li><li><a href="http://docs.kubernetes.org.cn/475.html">kubectl中文文档</a>：<a href="http://docs.kubernetes.org.cn/475.html">http://docs.kubernetes.org.cn/475.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英文字母起源</title>
    <link href="/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/"/>
    <url>/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>英语的26个字母最初起源于埃及象形文字，后由腓尼基人改进发明了腓尼基字母，希腊人对腓尼基字母加以改革后创造了希腊字母，古罗马人对希腊字母加以改革进而发明了拉丁字母，英文字母就属于拉丁字母。</p><h2 id="二：拉丁字母的起源，含义及引申含义"><a href="#二：拉丁字母的起源，含义及引申含义" class="headerlink" title="二：拉丁字母的起源，含义及引申含义"></a>二：拉丁字母的起源，含义及引申含义</h2><p>A 牛头 牛角；引申为牛角尖锐，针刺，酸痛，食物中最重要的部分<br>B 房屋；<br>C 骆驼；引申为运输，行走，携带，覆盖<br>D 门；引申为向下<br>E 窗户；引申为开关窗户的动作，向外伸延，引申，透过窗户可以看到外面<br>F 失败；引申为错误，失败；由附着引申为漂浮，表面，刀剑等含义<br>G 骆驼的头颈部；由C变化而来，引申为从深处出来，向深处拉<br>H 栅栏；人，围墙，连接，界限，高处；引申为相邻的房间<br>I 手指；人，树，水滴；引申为尖端，一点，火，目标，插，按，蜡烛，多代表与光明相关的东西<br>J 由I变化而来；表勾，挖，捏，握紧，夹紧等手指弯曲做出的动作；<br>K 手掌；张开，拖，压，推等手掌做的动作，引申为统治者，张开，裂开，开口，锋利，打架等<br>L 鞭子；引申含义：拉，抽，打，绕、绑东西的动作，长的，长远的，男性，驯服<br>M 海浪；山峰，引申含义： 男性 牢固 坚强 力量 多 咬合 匹配 合并 碰撞 记忆<br>N 鱼；引申：捞，收缩，摆动，跳跃，连接<br>O 眼睛；引申：转动 范围 开关 循环 观察 圆 女性<br>P 嘴唇；扁的，紧贴，吹，吐，含，吸，引申为向上，突出，顶端<br>Q 垂着尾巴的猴子；引申：收缩，汇集，挠，跳等猴子的动作；象征女性头部，表示女人， 问题<br>R 狗；代表生命力强的，侦查，看守，记忆，杂乱 引申：上司，高层，火苗，河流，招手，跑步<br>S 牙齿，沙丘；代表坚硬，相似，锋利，痕迹，咬，撕开等牙的特征和动作。引申为口舌，女人，流沙，蛇，音符，沙丘，弯腰动作，身体<br>T 叉号；引申为符号，字符，信息，识别，指示，启示，长久，不变，固定，神 工具<br>U 木栓孔; 由V延伸而来；引申含义有宽裕的 间距 容纳 器具 集中<br>V 木钉；引申为拉动，插动，活动，保卫，防护，固定，钉子，山谷，交叉，空，空虚<br>W 由V派生而来；double u,两个门栓，含义由保障，引申为女性 水 错误<br>X 问号；代表未知，无限，目标，希望，极致，顶峰，高贵，冷艳，完美，引申为交叉，四面八方，迷惑，错误<br>Y 早期将Y认为是上边的V和下面的I的组合; 引申：分支，道路，裂开，裂缝，岔生，产生，青年，年轻的，从前，确定<br>Z 宙斯；引申狂热，热情，速度，曲折的</p><h2 id="三：总结"><a href="#三：总结" class="headerlink" title="三：总结"></a>三：总结</h2><p>通过以上的统计，我们得出如下规律</p><h4 id="3-1-字形上，一些字母由其他字母演变而来"><a href="#3-1-字形上，一些字母由其他字母演变而来" class="headerlink" title="3.1 字形上，一些字母由其他字母演变而来"></a>3.1 字形上，一些字母由其他字母演变而来</h4><ol><li>G由C变化而来</li><li>J由I变化而来</li><li>U,W由V延伸而来</li><li>Y是一个意外，把上边的V和下边的I看成了一个字母</li></ol><h4 id="3-2-子母的含义，由几部分组成"><a href="#3-2-子母的含义，由几部分组成" class="headerlink" title="3.2 子母的含义，由几部分组成"></a>3.2 子母的含义，由几部分组成</h4><ol><li>基本含义</li><li>由基本含义引申出的含义</li><li>由字形特征引申出的含义</li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>generator函数与Async/await函数</title>
    <link href="/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>generator函数是一个迭代器</p><h2 id="二-详情"><a href="#二-详情" class="headerlink" title="二 详情"></a>二 详情</h2><p>Generator 函数是ECMAScript 6（ES6）中的一种特殊类型的函数，它能够产生迭代器（Iterator）。与普通的函数不同，Generator 函数可以暂停执行并随时恢复执行，而不会丢失函数的内部状态。这使得它们在处理异步操作、流控制和延迟执行方面非常有用。</p><p>Generator 函数通过使用特殊的关键字 function* 来声明，并在函数体内部使用 yield 表达式来暂停函数的执行并返回一个产生的值。每次调用 yield 都会暂停函数的执行，同时返回一个迭代器对象，您可以使用该迭代器对象来恢复函数的执行。调用生成器函数不会立即执行函数体，而是返回一个生成器对象，您需要显式地调用该生成器对象的 next() 方法来触发函数的执行。</p><p>简单来说：Generator函数是一个迭代器。</p><p>一个Generator函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-params">millionSeconds</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">res</span>(<span class="hljs-number">1</span>);<br>        &#125;, millionSeconds);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFunc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">generatorFunc</span>();<br>    <span class="hljs-keyword">let</span> a = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next a=`</span>, a);<br>    <span class="hljs-keyword">let</span> b = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-keyword">let</span> bResult = <span class="hljs-keyword">await</span> b.<span class="hljs-property">value</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next b=`</span>, b, <span class="hljs-string">`bResult = <span class="hljs-subst">$&#123;bResult&#125;</span>`</span>);<br>    <span class="hljs-keyword">let</span> c = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next c=`</span>, c);<br>    <span class="hljs-keyword">let</span> d = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next d=`</span>, d);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>());<br>&#125;<br><span class="hljs-title function_">test</span>();<br><br></code></pre></td></tr></table></figure><p>结合以上例子，我们来总结一下generator函数的用法：</p><ol><li>generator函数需要用“*”来声明</li><li>yield 后面需要跟的是可被迭代的东西 ，数值，表达式都行</li><li>如果yield后面跟一个promise，那么执行时迭代到这里，next中的value也是一个promise，需要自己手动去await执行</li><li>每次next，都会返回一个对象，该对象中的value表示被迭代的值，done表示是否完毕</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Koa</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从koa到koa2</title>
    <link href="/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/"/>
    <url>/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-Koa2简介及与Koa1的区别"><a href="#一：-Koa2简介及与Koa1的区别" class="headerlink" title="一： Koa2简介及与Koa1的区别"></a>一： Koa2简介及与Koa1的区别</h2><p>Koa2是Koa1框架的升级版本，目前已经是koa的默认版本；<br>相较于Koa1，Koa2引入了一些重要的变化和改进。以下是Koa2相对于Koa1的一些区别：</p><ol><li>Koa 1 使用 Generator 函数来处理中间件和异步操作，而 Koa 2 直接支持 async&#x2F;await，让中间件的编写和理解更加简洁明了</li></ol><p>下面我们从使用的角度分别分析：</p><h2 id="二：Koa2的Async-Await支持"><a href="#二：Koa2的Async-Await支持" class="headerlink" title="二：Koa2的Async&#x2F;Await支持"></a>二：Koa2的Async&#x2F;Await支持</h2><p>现在我们使用koa1来实现一个中间件，该如何做呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * (next) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">someAsyncFunction</span>(); <span class="hljs-comment">// Yielding async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> next;<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>koa2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">xxxx</span>(); <span class="hljs-comment">// Await async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>Koa2的中间件函数采用 async (ctx, next) &#x3D;&gt; {…}，而在 Koa1中是function * (next) {…}。Koa2直接支持Async&#x2F;Await，使得中间件的编写和理解更加简洁。</p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析koa的koa-compose</title>
    <link href="/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/"/>
    <url>/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa-compose 是koa用来合并中间件的工具，并且在中间件内部，原各个中间件的执行过程为洋葱式的。<br>本文我们从源码的角度，去看洋葱式是什么？它又是如何实现的？</p><h4 id="二：源码"><a href="#二：源码" class="headerlink" title="二：源码"></a>二：源码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middleware)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware stack must be an array!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码精简</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中的重要逻辑：</p><ul><li>返回值为一个中间件A</li><li>中间件数组的执行，是从第一个开始的</li><li>执行某中间件时，同时传入了下一个中间件（赋值为next），并通过调用next来执行该中间件</li><li>数组中中间件执行完毕后，执行A的下一个中间件</li></ul><h4 id="三：next与洋葱模型"><a href="#三：next与洋葱模型" class="headerlink" title="三：next与洋葱模型"></a>三：next与洋葱模型</h4><p>上回说到，next是用来执行下一个中间件的，那么在某中间件中，next的执行可能有以下情况</p><h5 id="3-1-在最开始调用"><a href="#3-1-在最开始调用" class="headerlink" title="3.1 在最开始调用"></a>3.1 在最开始调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-2-在中间调用"><a href="#3-2-在中间调用" class="headerlink" title="3.2 在中间调用"></a>3.2 在中间调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-3-在末尾调用"><a href="#3-3-在末尾调用" class="headerlink" title="3.3 在末尾调用"></a>3.3 在末尾调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h5><p>由于以下两条显而易见的规则：</p><ul><li>在某中间件内，next之前的代码先于next之后的代码执行</li><li>对某中间件来说，next执行完毕的标志，是其后所有的中间件均执行完毕</li></ul><p>故而中间件执行的过程有以下特征：</p><ul><li>先执行各个中间件next之前的代码，再执行各个中间件next之后的代码</li><li>各中间件next之前的代码，执行顺序为按照中间件顺序，从前向后</li><li>各中间件next之后的代码，执行顺序为按照中间件顺序，从后向前</li></ul><p>最后祭出那颗著名的葱：</p><p><img src="/pic/yangcong.jpg" alt="洋葱模型"></p><p>参考:<br><a href="https://github.com/koajs/compose.git">https://github.com/koajs/compose.git</a></p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koa源码学习及最简实现</title>
    <link href="/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa是基于nodejs平台的下一代web框架（官网描述）<br>官网地址：<a href="https://koa.bootcss.com/">https://koa.bootcss.com/</a><br>git地址：<a href="https://github.com/koajs/koa.git">https://github.com/koajs/koa.git</a><br>koa提供基于http服务的最简的框架模型，包括洋葱式的中间件处理逻辑、对请求和响应的封装等。</p><h4 id="二：使用"><a href="#二：使用" class="headerlink" title="二：使用"></a>二：使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><br><span class="hljs-keyword">let</span> koa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>koa.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);<br>    ctx.<span class="hljs-property">body</span> = &#123; <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> &#125;;<br>&#125;);<br><br>koa.<span class="hljs-title function_">listen</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server listen 5000&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="三：源码"><a href="#三：源码" class="headerlink" title="三：源码"></a>三：源码</h4><p>源码的lib下共四个文件：application.js，context.js，request.js，response.js</p><h5 id="3-1-application-js"><a href="#3-1-application-js" class="headerlink" title="3.1 application.js"></a>3.1 application.js</h5><p>application.js是暴露给外部的入口，关键代码：</p><h6 id="3-1-1-use"><a href="#3-1-1-use" class="headerlink" title="3.1.1 use"></a>3.1.1 use</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;middleware must be a function!&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isGeneratorFunction</span>(fn)) &#123;<br>    <span class="hljs-title function_">deprecate</span>(<span class="hljs-string">&#x27;Support for generators will be removed in v3. &#x27;</span> +<br>              <span class="hljs-string">&#x27;See the documentation for examples of how to convert old middleware &#x27;</span> +<br>              <span class="hljs-string">&#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;</span>);<br>    fn = <span class="hljs-title function_">convert</span>(fn);<br>  &#125;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;use %s&#x27;</span>, fn.<span class="hljs-property">_name</span> || fn.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;-&#x27;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>use方法接收中间件（即函数），并将其放入middleware数组中；<br>return this，用于支持use的链式调用；</p><h6 id="3-1-2-listen"><a href="#3-1-2-listen" class="headerlink" title="3.1.2 listen"></a>3.1.2 listen</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;listen&#x27;</span>);<br>  <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>  <span class="hljs-keyword">return</span> server.<span class="hljs-title function_">listen</span>(...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>koa提供的服务，本质上是nodejs的http模块提供的。koa定义了自己的callback函数用来接收请求和返回结果；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onerror</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createContext</span>(req, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> handleRequest;<br>&#125;<br></code></pre></td></tr></table></figure><p>compose函数是koa-compose提供的，其作用是将多个中间件整理成一个中间件，在此中间件内部，原来的多个中间件的执行过程是洋葱式的；<br>createContext的作用是封装req,res为一个context对象，该对象经handleRequest函数传入每一个中间件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = ctx.<span class="hljs-property">res</span>;<br>  res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onerror</span> = err =&gt; ctx.<span class="hljs-title function_">onerror</span>(err);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResponse</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">respond</span>(ctx);<br>  <span class="hljs-title function_">onFinished</span>(res, onerror); <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx).<span class="hljs-title function_">then</span>(handleResponse).<span class="hljs-title function_">catch</span>(onerror);<br>&#125;   <br></code></pre></td></tr></table></figure><p>当所有中间件执行完毕，调用handleResponse函数，来返回结果</p><h5 id="3-2-context-js"><a href="#3-2-context-js" class="headerlink" title="3.2 context.js"></a>3.2 context.js</h5><p>包含createContext的返回对象相关的一些方法</p><h5 id="3-3-request-js"><a href="#3-3-request-js" class="headerlink" title="3.3 request.js"></a>3.3 request.js</h5><p>基于http.createServer中callback内的参数 req，封装了一些方法</p><h5 id="3-4-response-js"><a href="#3-4-response-js" class="headerlink" title="3.4 response.js"></a>3.4 response.js</h5><p>基于http.createServer中callback内的参数 res，封装了一些方法</p><h4 id="四：最简实现"><a href="#四：最简实现" class="headerlink" title="四：最简实现"></a>四：最简实现</h4><p>假设不考虑参数验错，req和res封装等，最简的类koa模型应该具备以下特征</p><ul><li>支持增加中间件</li><li>中间件的执行流程为洋葱式</li><li>context传入每个中间件，以实现中间件间的数据共享</li><li>具备处理各种事件的能力，如error事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Emitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-compose&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleKoa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Emitter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>        server.<span class="hljs-title function_">listen</span>(...args);<br>    &#125;<br><br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenrCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br>        <span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> ctx = &#123;<br>                req,<br>                res<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handleRequest;<br>    &#125;<br><br>    <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
