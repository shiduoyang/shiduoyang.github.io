<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>node.js发散问题:进程,线程与协程的区别</title>
    <link href="/2023/09/11/node-js%E5%8F%91%E6%95%A3%E9%97%AE%E9%A2%98-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/09/11/node-js%E5%8F%91%E6%95%A3%E9%97%AE%E9%A2%98-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ol><li>进程（Process）：</li></ol><ul><li>进程是计算机中的一个独立执行单位，它有自己的独立内存空间和资源。</li><li>每个进程都有一个独立的地址空间，不同进程之间的数据不能直接共享，通信需要特定的机制（如进程间通信IPC）。</li><li>进程之间的切换开销相对较高，因为需要保存和恢复进程的状态。</li><li>进程是多任务处理的基本单位，通常代表一个运行的程序。</li></ul><ol start="2"><li>线程（Thread）：</li></ol><ul><li>线程是进程内的一个执行单元，多个线程可以共享同一进程的内存和资源。</li><li>线程之间可以更方便地进行通信，因为它们共享相同的内存空间。</li><li>线程之间的切换开销较小，因为它们共享相同的地址空间。</li><li>线程用于提高程序的并发性和性能，例如，一个多线程程序可以在一个线程执行计算任务的同时，在另一个线程执行I&#x2F;O任务。</li></ul><ol start="3"><li>协程（Coroutine）：</li></ol><ul><li>协程是一种轻量级的线程，也称为用户态线程。它们是由程序员控制的，而不是由操作系统控制。</li><li>协程可以在同一线程内并发执行，但它们不会并行执行。程序员可以显式地控制协程的调度。</li><li>协程通常用于编写高效的异步和非阻塞代码，例如，在网络编程中，可以使用协程来处理大量并发连接。</li><li>协程的切换开销非常小，因为它们是由程序员控制的，不涉及操作系统的上下文切换。</li></ul><p>总结：</p><ol><li>进程是操作系统中的独立执行单位，线程是进程内的执行单位，而协程是程序员控制的轻量级执行单位。</li><li>进程之间的通信较为复杂，线程共享同一进程的内存，通信较为容易，而协程通常是在同一线程内执行，通信也相对容易。</li><li>进程和线程通常用于多核处理器上的并行计算，而协程用于编写高效的异步代码。选择哪种技术取决于具体的应用场景和需求。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>node.js子线程</title>
    <link href="/2023/09/11/node-js%E5%AD%90%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/09/11/node-js%E5%AD%90%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>在Node.js中，子线程（Child Threads）通常是指通过worker_threads模块创建的独立线程。这些子线程允许你在Node.js应用程序中执行并行计算任务，从而充分利用多核处理器，并提高性能。</p><p>相关概念：</p><ol><li>worker_threads 模块： Node.js的核心模块中包含了worker_threads，该模块允许你创建和管理子线程。通过这个模块，你可以在独立的线程中运行JavaScript代码。</li><li>线程与进程的区别： 子线程是运行在主Node.js进程内部的额外线程，与主进程共享内存空间。与子进程不同，子线程不是独立的操作系统进程。这意味着<strong>子线程之间可以共享数据和资源</strong>，但也需要谨慎处理共享数据以避免竞态条件等问题。</li><li>多核处理器利用： 子线程适用于需要执行计算密集型任务的场景，例如图像处理、数据分析、加密等。通过将这些任务分配给子线程，可以充分利用多核处理器的性能。</li><li>通信和同步： 主线程和子线程之间可以通过消息传递进行通信，就像主进程和子进程之间的通信一样。worker_threads模块提供了postMessage和on(‘message’)等方法来实现消息传递。</li></ol><h2 id="二：示例"><a href="#二：示例" class="headerlink" title="二：示例"></a>二：示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Worker</span>, isMainThread, parentPort &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;worker_threads&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (isMainThread) &#123;<br>  <span class="hljs-comment">// 主线程代码</span><br>  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);<br><br>  <span class="hljs-comment">// 监听子线程的消息</span><br>  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`主线程收到计算结果：<span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// 向子线程发送消息，触发计算</span><br>  worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">num1</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">num2</span>: <span class="hljs-number">10</span> &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 子线程代码</span><br>  parentPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; num1, num2 &#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子线程收到任务：计算 <span class="hljs-subst">$&#123;num1&#125;</span> * <span class="hljs-subst">$&#123;num2&#125;</span>`</span>);<br><br>    <span class="hljs-comment">// 执行复杂计算</span><br>    <span class="hljs-keyword">const</span> result = num1 * num2;<br><br>    <span class="hljs-comment">// 向主线程发送计算结果</span><br>    parentPort.<span class="hljs-title function_">postMessage</span>(result);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js子进程</title>
    <link href="/2023/09/11/node-js%E5%AD%90%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/09/11/node-js%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-子进程概述"><a href="#一：-子进程概述" class="headerlink" title="一： 子进程概述"></a>一： 子进程概述</h2><p>在Node.js中，子进程是指由主Node.js进程启动的独立的操作系统进程。这些子进程可以执行独立的任务、脚本或外部命令，与主进程并行运行，从而充分利用多核处理器和执行并发任务。<br>Node.js提供了child_process模块，其中包含多种方法来创建、控制和与子进程进行交互。以下是一些常见的用例：</p><ul><li>执行外部命令： child_process.spawn或child_process.exec</li><li>运行独立脚本： child_process.fork创建一个新的Node.js进程，该进程可以运行独立的JavaScript脚本文件。这通常用于创建并发的Node.js进程来处理不同的任务。</li><li>进程间通信： child_process.send和process.on(‘message’)等方法在父子进程之间传递消息和数据。</li><li>并行处理： 通过创建多个子进程，你可以并行处理任务，提高程序性能。这对于处理大量请求或计算密集型任务非常有用。</li></ul><h2 id="二：如何创建子进程"><a href="#二：如何创建子进程" class="headerlink" title="二：如何创建子进程"></a>二：如何创建子进程</h2><h3 id="2-1-spawn-用来执行外部命令"><a href="#2-1-spawn-用来执行外部命令" class="headerlink" title="2.1 spawn 用来执行外部命令"></a>2.1 spawn 用来执行外部命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 执行 ls 命令</span><br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-l&#x27;</span>]);<br><br><span class="hljs-comment">// 处理子进程的输出</span><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程输出：<span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 处理子进程的错误</span><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`子进程错误：<span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 子进程退出时触发</span><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出，退出码 <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="2-2-fork-用来创建子进程并执行node-js文件"><a href="#2-2-fork-用来创建子进程并执行node-js文件" class="headerlink" title="2.2 fork 用来创建子进程并执行node.js文件"></a>2.2 fork 用来创建子进程并执行node.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fork &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 在子进程中执行 child.js 文件</span><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;child.js&#x27;</span>);<br><br><span class="hljs-comment">// 父进程发送消息给子进程</span><br>child.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello from parent&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 处理子进程发送的消息</span><br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`父进程接收到消息：<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(message)&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 子进程退出时触发</span><br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出，退出码 <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-3-exec-来执行外币命令，与spawn不同的是它传输整个的命令字符串"><a href="#2-3-exec-来执行外币命令，与spawn不同的是它传输整个的命令字符串" class="headerlink" title="2.3 exec 来执行外币命令，与spawn不同的是它传输整个的命令字符串"></a>2.3 exec 来执行外币命令，与spawn不同的是它传输整个的命令字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 执行 ls 命令</span><br><span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ls -l&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行错误：<span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程输出：<span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`子进程错误：<span class="hljs-subst">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="三：主进程与子进程之间如何通讯"><a href="#三：主进程与子进程之间如何通讯" class="headerlink" title="三：主进程与子进程之间如何通讯"></a>三：主进程与子进程之间如何通讯</h2><ol><li>主进程与子进程之间通过child_process模块提供的函数来通讯</li><li>通过网络请求来通讯，如TCP，具体用法是在子进程创建一个tcp客户端，连接到主进程的tcp服务器上。</li><li>一些共享内存的模块如shared-memory</li><li>通过文件来交换数据</li></ol><p>以下是child_process来实现父子进程通讯的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fork &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-comment">// 创建子进程</span><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;child.js&#x27;</span>);<br><br><span class="hljs-comment">// 向子进程发送消息</span><br>child.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello from the main process&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 监听来自子进程的消息</span><br>child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`主进程收到消息：<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(message)&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用child_process的相关方法，进程之间通讯的方法</p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js模块</title>
    <link href="/2023/09/11/node-js%E6%A8%A1%E5%9D%97/"/>
    <url>/2023/09/11/node-js%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>本文介绍node.js的常见模块</p><h2 id="二：核心模块列表"><a href="#二：核心模块列表" class="headerlink" title="二：核心模块列表"></a>二：核心模块列表</h2><ol><li>events</li></ol><ul><li>http：用于创建HTTP服务器和处理HTTP请求和响应的模块。</li><li>https：与http模块类似，但用于创建HTTPS服务器和处理HTTPS请求和响应。</li><li>fs：用于文件系统操作，包括读取文件、写入文件、创建文件夹等。</li><li>path：提供与文件路径和目录路径相关的实用功能，用于处理文件路径的构造和解析。</li><li>os：用于访问操作系统的信息，如操作系统平台、CPU架构等。</li><li>events：用于实现事件驱动编程，可用于创建自定义事件和处理事件。</li><li>util：包含一些实用工具函数，如继承、格式化、调试等。</li><li>crypto：提供了加密和解密等密码学功能的模块。</li><li>stream：用于处理流数据的模块，支持可读流和可写流。</li><li>buffer：用于处理二进制数据的模块，提供了缓冲区操作和数据转换功能。</li><li>querystring：用于解析和格式化URL查询字符串的模块。</li><li>url：用于解析和构建URL的模块。</li><li>child_process：用于创建和管理子进程的模块，允许Node.js应用程序与其他进程进行交互。</li><li>net：用于创建TCP服务器和客户端的模块。</li><li>http2：用于创建HTTP&#x2F;2服务器和客户端的模块。</li></ul><h2 id="三：node-js的模块化"><a href="#三：node-js的模块化" class="headerlink" title="三：node.js的模块化"></a>三：node.js的模块化</h2><p>Node.js的模块化是一种组织和封装代码的方法，旨在提高代码的可维护性、可重用性和可扩展性。Node.js支持CommonJS模块系统，这是一种模块化的规范，允许开发者将代码划分为小的、独立的模块，每个模块都可以独立开发、测试和维护。</p><p>相关概念：</p><ul><li>模块（Module）：一个模块就是一个独立的JavaScript文件，它可以包含函数、变量、类等等。每个模块都有自己的作用域，因此模块中的代码不会污染全局作用域。</li><li>导出（Export）：通过module.exports或exports对象，一个模块可以将其内部的函数、变量等暴露给其他模块使用。这些导出的内容可以在其他模块中引入并使用。</li><li>导入（Import）：要在一个模块中使用其他模块导出的内容，可以使用require函数来导入它们。导入的内容会被包含在一个对象中，可以通过该对象来访问导入的函数和变量。</li><li>模块路径（Module Path）：在require函数中，你需要指定要导入的模块的路径。路径可以是相对路径（相对于当前模块）或绝对路径，也可以是模块名，Node.js会根据模块名来查找对应的模块文件。</li><li>核心模块（Core Modules）：Node.js提供了一些内置的核心模块，如http、fs、os等，它们可以直接通过require来使用，无需额外安装。</li><li>第三方模块（Third-party Modules）：除了核心模块，Node.js社区还维护了大量的第三方模块，可以通过npm安装和使用。这些模块可以用于各种用途，从Web框架和数据库驱动到数据处理和工具库等等。</li></ul><h2 id="四：导入模块的过程"><a href="#四：导入模块的过程" class="headerlink" title="四：导入模块的过程"></a>四：导入模块的过程</h2><p>模块导入，是一个同步的过程。</p><ol><li>模块路径解析：当调用require函数时，Node.js首先解析要导入的模块的路径。路径可以是相对路径（相对于当前模块）或绝对路径，也可以是模块名。如果路径是一个模块名，Node.js会尝试查找该模块名对应的模块文件。</li><li>模块缓存：Node.js会检查模块是否已经被加载过。如果模块已经加载并缓存了，Node.js会直接返回缓存的模块，而不会重新加载。这是为了提高性能并避免重复加载。</li><li>模块加载：如果模块没有被缓存，Node.js会根据路径查找对应的模块文件。Node.js支持多种文件扩展名，如.js、.json和.node等。根据路径找到文件后，Node.js会读取文件内容，并将其包装在一个模块封装器函数中。</li><li>模块编译：模块封装器函数会被传递给Node.js的模块编译器，该编译器将JavaScript代码转换为可执行的函数。这个过程包括了词法分析、语法分析和代码生成。</li><li>导出对象：模块中的内容（变量、函数、类等）被包含在一个对象中，这个对象可以通过module.exports或exports来暴露给其他模块。模块的导出对象成为其他模块可以访问的接口。</li><li>返回导出对象：一旦模块加载和编译完成，并且导出对象已经构建，Node.js会将导出对象缓存起来，并将其返回给调用require函数的模块。这样，调用require的模块就可以使用被导出的功能了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http状态码记录</title>
    <link href="/2023/09/11/http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/11/http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。<br>响应分为五类：<br>信息响应(100–199)<br>成功响应(200–299)<br>重定向(300–399)<br>客户端错误(400–499)<br>服务器错误 (500–599)</p><h2 id="二：详解"><a href="#二：详解" class="headerlink" title="二：详解"></a>二：详解</h2><h4 id="2-1-100-199信息相应"><a href="#2-1-100-199信息相应" class="headerlink" title="2.1 100-199信息相应"></a>2.1 100-199信息相应</h4><ul><li>100Continue继续。客户端应继续其请求</li><li>101Switching Protocols切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li></ul><h4 id="2-2-200-299成功相应"><a href="#2-2-200-299成功相应" class="headerlink" title="2.2 200-299成功相应"></a>2.2 200-299成功相应</h4><ul><li>200OK请求成功。一般用于GET与POST请求</li><li>201Created已创建。成功请求并创建了新的资源</li><li>202Accepted已接受。已经接受请求，但未处理完成</li><li>203Non-Authoritative Information非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li><li>204No Content无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205Reset Content重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206Partial Content部分内容。服务器成功处理了部分GET请求</li></ul><h4 id="2-3-300-399重定向"><a href="#2-3-300-399重定向" class="headerlink" title="2.3 300-399重定向"></a>2.3 300-399重定向</h4><ul><li>300Multiple Choices多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301Moved Permanently永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302Found临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303See Other查看其它地址。与301类似。使用GET和POST请求查看</li><li>304Not Modified未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>305Use Proxy使用代理。所请求的资源必须通过代理访问</li><li>306Unused已经被废弃的HTTP状态码</li><li>307Temporary Redirect临时重定向。与302类似。使用GET请求重定向</li></ul><h4 id="2-4-400-499客户端错误"><a href="#2-4-400-499客户端错误" class="headerlink" title="2.4 400-499客户端错误"></a>2.4 400-499客户端错误</h4><ul><li>400Bad Request客户端请求的语法错误，服务器无法理解</li><li>401Unauthorized请求要求用户的身份认证</li><li>402Payment Required保留，将来使用</li><li>403Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404Not Found服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>405Method Not Allowed客户端请求中的方法被禁止</li><li>406Not Acceptable服务器无法根据客户端请求的内容特性完成请求</li><li>407Proxy Authentication Required请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li><li>408Request Time-out服务器等待客户端发送的请求时间过长，超时</li><li>409Conflict服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</li><li>410Gone客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</li><li>411Length Required服务器无法处理客户端发送的不带Content-Length的请求信息</li><li>412Precondition Failed客户端请求信息的先决条件错误</li><li>413Request Entity Too Large由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li><li>414Request-URI Too Large请求的URI过长（URI通常为网址），服务器无法处理</li><li>415Unsupported Media Type服务器无法处理请求附带的媒体格式</li><li>416Requested range not satisfiable客户端请求的范围无效</li><li>417Expectation Failed服务器无法满足Expect的请求头信息</li></ul><h4 id="2-5-500-599服务端错误"><a href="#2-5-500-599服务端错误" class="headerlink" title="2.5 500-599服务端错误"></a>2.5 500-599服务端错误</h4><ul><li>500Internal Server Error服务器内部错误，无法完成请求</li><li>501Not Implemented服务器不支持请求的功能，无法完成请求</li><li>502Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503Service Unavailable由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li><li>504Gateway Time-out充当网关或代理的服务器，未及时从远端服务器获取请求</li><li>505HTTP Version not supported服务器不支持请求的HTTP协议的版本，无法完成处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js事件循环</title>
    <link href="/2023/09/09/node-js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2023/09/09/node-js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>node.js的事件循环，是node.js非阻塞IO的原因，因为非阻塞IO，node.js获得了高性能。</p><h2 id="二：事件循环的阶段"><a href="#二：事件循环的阶段" class="headerlink" title="二：事件循环的阶段"></a>二：事件循环的阶段</h2><p>事件循环的每一个阶段，都有一个队列来执行回调。</p><p>process.nextTick队列：执行process.nextTick回调<br>微任务队列：执行微任务回调，如promise</p><ul><li>timer ： 处理 setTimeout 和setInterval 回调</li><li>pending callback：系统级回调函数</li><li>idle prepare：与node.js核心和性能优化有关</li><li>poll: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的几乎任何回调（如网络请求，数据库查询，文件读取）;在适当的时机在此处暂停</li><li>check 处理setImmediately回调</li><li>close：处理一些关闭回调，如socket.on(‘close’)回调</li></ul><p>源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs javascript">int <span class="hljs-title function_">uv_run</span>(<span class="hljs-params">uv_loop_t* loop, uv_run_mode mode</span>) &#123;<br>  int timeout;<br>  int r;<br>  int can_sleep;<br><br>  r = <span class="hljs-title function_">uv__loop_alive</span>(loop);<br>  <span class="hljs-keyword">if</span> (!r)<br>    <span class="hljs-title function_">uv__update_time</span>(loop);<br><br>  <span class="hljs-comment">/* Maintain backwards compatibility by processing timers before entering the</span><br><span class="hljs-comment">   * while loop for UV_RUN_DEFAULT. Otherwise timers only need to be executed</span><br><span class="hljs-comment">   * once, which should be done after polling in order to maintain proper</span><br><span class="hljs-comment">   * execution order of the conceptual event loop. */</span><br>  <span class="hljs-keyword">if</span> (mode == <span class="hljs-variable constant_">UV_RUN_DEFAULT</span> &amp;&amp; r != <span class="hljs-number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">uv__update_time</span>(loop);<br>    <span class="hljs-title function_">uv__run_timers</span>(loop);<span class="hljs-comment">//是一个最小堆</span><br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (r != <span class="hljs-number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="hljs-number">0</span>) &#123;<br>    can_sleep =<br>        <span class="hljs-title function_">uv__queue_empty</span>(&amp;loop-&gt;pending_queue) &amp;&amp;<br>        <span class="hljs-title function_">uv__queue_empty</span>(&amp;loop-&gt;idle_handles);<br><br>    <span class="hljs-title function_">uv__run_pending</span>(loop);<span class="hljs-comment">// pending</span><br>    <span class="hljs-title function_">uv__run_idle</span>(loop);<span class="hljs-comment">// idle</span><br>    <span class="hljs-title function_">uv__run_prepare</span>(loop);<span class="hljs-comment">// prepare</span><br><br>    timeout = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ((mode == <span class="hljs-variable constant_">UV_RUN_ONCE</span> &amp;&amp; can_sleep) || mode == <span class="hljs-variable constant_">UV_RUN_DEFAULT</span>)<br>      timeout = <span class="hljs-title function_">uv__backend_timeout</span>(loop);<br><br>    <span class="hljs-title function_">uv__metrics_inc_loop_count</span>(loop);<br><br>    <span class="hljs-title function_">uv__io_poll</span>(loop, timeout);<span class="hljs-comment">// poll io</span><br><br>    <span class="hljs-comment">/* Process immediate callbacks (e.g. write_cb) a small fixed number of</span><br><span class="hljs-comment">     * times to avoid loop starvation.*/</span><br>    <span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r &lt; <span class="hljs-number">8</span> &amp;&amp; !<span class="hljs-title function_">uv__queue_empty</span>(&amp;loop-&gt;pending_queue); r++)<br>      <span class="hljs-title function_">uv__run_pending</span>(loop);<br><br>    <span class="hljs-comment">/* Run one final update on the provider_idle_time in case uv__io_poll</span><br><span class="hljs-comment">     * returned because the timeout expired, but no events were received. This</span><br><span class="hljs-comment">     * call will be ignored if the provider_entry_time was either never set (if</span><br><span class="hljs-comment">     * the timeout == 0) or was already updated b/c an event was received.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">uv__metrics_update_idle_time</span>(loop);<br><br>    <span class="hljs-title function_">uv__run_check</span>(loop);<br>    <span class="hljs-title function_">uv__run_closing_handles</span>(loop);<br><br>    <span class="hljs-title function_">uv__update_time</span>(loop);<br>    <span class="hljs-title function_">uv__run_timers</span>(loop);<br><br>    r = <span class="hljs-title function_">uv__loop_alive</span>(loop);<br>    <span class="hljs-keyword">if</span> (mode == <span class="hljs-variable constant_">UV_RUN_ONCE</span> || mode == <span class="hljs-variable constant_">UV_RUN_NOWAIT</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span><br><span class="hljs-comment">   * dirtying a cache line.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (loop-&gt;stop_flag != <span class="hljs-number">0</span>)<br>    loop-&gt;stop_flag = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-3-微任务与宏任务"><a href="#2-3-微任务与宏任务" class="headerlink" title="2.3 微任务与宏任务"></a>2.3 微任务与宏任务</h3><p>宏任务：</p><ul><li>setTimeout</li><li>setInterval</li><li>I&#x2F;O<br>微任务:</li><li>promises</li><li>process.nextTick</li><li>Object.observe</li></ul><p>每个事件循环迭代包括以下步骤：<br>执行当前事件循环迭代中的<strong>所有微任务（Micro Task）</strong>。<br>检查是否有宏任务需要执行。如果有，<strong>执行一个宏任务</strong>，然后返回步骤1。<br>如果没有待执行的宏任务，事件循环迭代结束。</p><h3 id="2-2-事件循环源码解析"><a href="#2-2-事件循环源码解析" class="headerlink" title="2.2 事件循环源码解析"></a>2.2 事件循环源码解析</h3><p>参考：<br><a href="https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/">https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/</a><br><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick">https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick</a><br><a href="http://docs.libuv.org/en/v1.x/poll.html">http://docs.libuv.org/en/v1.x/poll.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react概述</title>
    <link href="/2023/09/08/react%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/08/react%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>react哲学：页面由组件整合而来</p><h2 id="二：相关概念"><a href="#二：相关概念" class="headerlink" title="二：相关概念"></a>二：相关概念</h2><ol><li>如何创建和嵌套组件：<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>I&#x27;m a button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to my app<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何添加标签和样式<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;img className=<span class="hljs-string">&quot;avatar&quot;</span> /&gt;<br><span class="hljs-comment">/* In your CSS */</span><br>.<span class="hljs-property">avatar</span> &#123;<br>  border-<span class="hljs-attr">radius</span>: <span class="hljs-number">50</span>%;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何显示数据<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hedy Lamarr&#x27;</span>,<br>  <span class="hljs-attr">imageUrl</span>: <span class="hljs-string">&#x27;https://i.imgur.com/yXOvdOSs.jpg&#x27;</span>,<br>  <span class="hljs-attr">imageSize</span>: <span class="hljs-number">90</span>,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.imageUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">Photo</span> <span class="hljs-attr">of</span> &#x27; + <span class="hljs-attr">user.name</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">width:</span> <span class="hljs-attr">user.imageSize</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">height:</span> <span class="hljs-attr">user.imageSize</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何渲染条件和列表<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>  &#123;isLoggedIn ? (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminPanel</span> /&gt;</span></span><br>  ) : (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginForm</span> /&gt;</span></span><br>  )&#125;<br>&lt;/div&gt;<br><br><span class="hljs-keyword">const</span> listItems = products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.id&#125;</span>&gt;</span></span><br><span class="language-xml">    &#123;product.title&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>);<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li><li>如何对事件做出响应并更新界面<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;You clicked me!&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Click me</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">// 更新界面</span><br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Clicked &#123;count&#125; times</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如何在组件间共享数据<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params">&#123; count, onClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span></span><br><span class="language-xml">      Clicked &#123;count&#125; times</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Counters that update together<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="三：生产级的react框架"><a href="#三：生产级的react框架" class="headerlink" title="三：生产级的react框架"></a>三：生产级的react框架</h2><ol><li>next.js是一个全栈式的 React 框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-next-app<br></code></pre></td></tr></table></figure></li><li>remix是一个具有嵌套路由的全栈式 React 框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-remix<br></code></pre></td></tr></table></figure></li><li>Gatsby是一个快速的支持 CMS（内容管理系统） 的网站的 React 框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-gatsby<br></code></pre></td></tr></table></figure></li><li>expo 用于原生应用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-expo-app<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>react官网：<a href="https://zh-hans.react.dev/learn">https://zh-hans.react.dev/learn</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通用型支付服务设计概述</title>
    <link href="/2023/09/08/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/08/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>日前应公司业务发展的要求，对支付逻辑进行了拆分，形成了独立支付服务。本文基于服务拆分的实践，探讨建立独立支付服务的思路。<br>文末的关键编码，为处理后的伪代码，与实际项目无关，特此声明。</p><h4 id="一：什么是独立支付服务"><a href="#一：什么是独立支付服务" class="headerlink" title="一：什么是独立支付服务"></a>一：什么是独立支付服务</h4><p>假设有三个不同的项目A,B,C，都需要接入支付宝H5支付功能。按照以往的开发模式，这三个项目需要分别开发一套与支付宝的对话逻辑，包括下单、支付回调、订单支付状态查询等。<br>假设这三个项目，现在要接入微信H5支付和微信JSAPI支付，那么同理，他们需要分别开发一套与微信方的对话逻辑。<br>如果还需要接入其他的支付方式呢？<br>独立支付服务可以理解为这些支付方式的代理，A,B,C在独立支付服务中注册它们的关键支付参数及商品，独立支付服务提供支付流程的保证和在关键的时间节点（订单创建、订单支付成功等）的通知。<br>有了独立支付服务，不管有多少个项目，大家都不需要关注与微信方等的对话逻辑，只需要关注必要的配置及少数几个通知就可以了。</p><h4 id="二：支付服务应包含哪些功能"><a href="#二：支付服务应包含哪些功能" class="headerlink" title="二：支付服务应包含哪些功能"></a>二：支付服务应包含哪些功能</h4><ul><li>客户管理。提供客户的注册、鉴权、关键支付信息（如微信appid）等的存储。</li><li>商品管理。客户创建商品、修改商品价格、设置各种通知接口。</li><li>支付服务。封装与实际支付服务提供者（微信、支付宝）的交互，提供统一的预下单接口，并在关键的时间节点通知客户。</li><li>查询服务。客户主动查询某订单的支付状态。</li></ul><h4 id="三：支付的整体流程是什么"><a href="#三：支付的整体流程是什么" class="headerlink" title="三：支付的整体流程是什么"></a>三：支付的整体流程是什么</h4><p>假设支付平台的服务器为S，客户的服务器为s，客户的前端（支付按钮所在的地方）为c。<br>假设客户A已经在支付平台注册了商品a，并设置当a创建订单和支付成功的时候，都要通知给s。<br>以支付宝H5支付为例。</p><h5 id="当用户点击支付按钮之后，支付流程应该是这样的："><a href="#当用户点击支付按钮之后，支付流程应该是这样的：" class="headerlink" title="当用户点击支付按钮之后，支付流程应该是这样的："></a>当用户点击支付按钮之后，支付流程应该是这样的：</h5><ul><li>c-&gt;S：用户要支付啦，选的是支付宝H5支付，商品是a，数量是1，用户的唯一标识是“15705420001” ，需要带给s那货的信息是”xxxxxx”;</li><li>S-&gt;c：我和支付宝方沟通过了，订单已创建，你的支付参数是*****，订单标识为12345;</li><li>S-&gt;s：有用户创建订单啦，用户是“15705420001”，商品是a，数量是1，你的客户端托我给你带的话是‘xxxxxx’，订单标识是12345；</li><li>c ：用支付参数一顿操作，唤起了支付，用户付款;</li><li>支付宝-&gt;S：订单12345支付成功啦；</li><li>S-&gt;s:  有用户支付订单啦，用户是“15705420001”，商品是a，数量是1，你的客户端托我给你带的话是‘xxxxxx’，订单标识是12345；</li><li>s：记录用户15705420001，买了1个商品a；</li></ul><h6 id="如果s不相信支付成功的通知呢？"><a href="#如果s不相信支付成功的通知呢？" class="headerlink" title="如果s不相信支付成功的通知呢？"></a>如果s不相信支付成功的通知呢？</h6><ul><li>s-&gt;S： 这个订单12345的，确实支付了吗？你去支付宝问问；</li><li>S-&gt;s：问过支付宝了，支付了；</li><li>s：记录用户15705420001，买了1个商品a；</li></ul><h5 id="c从支付宝的支付页面返回之后"><a href="#c从支付宝的支付页面返回之后" class="headerlink" title="c从支付宝的支付页面返回之后"></a>c从支付宝的支付页面返回之后</h5><ul><li>c-&gt;S：麻烦看下12345支付成功了吗；</li><li>S-&gt;c：问过支付宝了，支付了；</li><li>c：跳转支付成功页面；</li></ul><h4 id="四：关键编码"><a href="#四：关键编码" class="headerlink" title="四：关键编码"></a>四：关键编码</h4><p>笔者实践采用的是koa+mysql+redis技术栈，关键编码依然以支付宝h5支付为例。</p><h6 id="4-1：支付宝h5支付"><a href="#4-1：支付宝h5支付" class="headerlink" title="4.1：支付宝h5支付"></a>4.1：支付宝h5支付</h6><ul><li>获取支付参数时<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">const</span> info = <span class="hljs-keyword">await</span> aliH5PayChannel.<span class="hljs-title function_">unifiedOrder</span>(goodsInfo);<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">notifyOrderCreated</span>(goodsInfo, info);<br></code></pre></td></tr></table></figure></li><li>用户支付成功后</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//支付结果通知逻辑</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">notifyPaySuccess</span>(payOrder);<br></code></pre></td></tr></table></figure><ul><li>查询订单</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (orderType == <span class="hljs-variable constant_">ORDERTYPE</span>.<span class="hljs-property">ALIH5PAY</span>) &#123;<br><span class="hljs-keyword">let</span> queryResult = <span class="hljs-keyword">await</span> aliH5PayChannel.<span class="hljs-title function_">queryOrder</span>(orderNo);<br>       <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑陋的中国人</title>
    <link href="/2023/09/08/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/"/>
    <url>/2023/09/08/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>我们常常颂扬中国人的美好品德，但人无完人，民族也是如此。这本书就列举出了中国人的一些不足，读完之后我感觉振聋发聩，暗自告诫自己，在以后的生活中，需要常常自省。</p><h2 id="二：笔记"><a href="#二：笔记" class="headerlink" title="二：笔记"></a>二：笔记</h2><h3 id="2-1-极端自傲与自卑，但缺乏自尊"><a href="#2-1-极端自傲与自卑，但缺乏自尊" class="headerlink" title="2.1 极端自傲与自卑，但缺乏自尊"></a>2.1 极端自傲与自卑，但缺乏自尊</h3><p>造成中国人两个极端，不够平衡。 一方面是绝对的自卑，一方面是绝对的自傲。自卑的时候成了奴才，自傲的时候成了主人，却独独没有自尊。<br>这以至于中国人很难有平等观念，你不是我的主人，我就得是你的主人。这种情景影响到个人心态的封闭。死不认错，但又不断有错，以致使中国人产生一种神经质的恐惧。</p><h3 id="2-2-保护自己为第一，明哲保身"><a href="#2-2-保护自己为第一，明哲保身" class="headerlink" title="2.2 保护自己为第一，明哲保身"></a>2.2 保护自己为第一，明哲保身</h3><p>盖儒家在原则上只提倡个人主义而非集体主义。明哲保身，不入危墙。曰：危邦不入，乱邦不居，天下有道，则见，无道，则隐。邦有道，贫且贱，耻也；邦无道，富且贵焉，耻也。<br>都保护自己畏第一，明哲保身，也就有了：</p><ul><li>不敢想也不敢讲；</li><li>混日子；</li><li>拳头大了就是对；不论对错，以拳头大小论对错</li><li>出个冒尖的因为与自己的做法不符，会说他爱管闲事</li><li>有敬有畏，但缺乏爱；对上敬畏，对下严厉，但缺乏平等的爱</li><li>不太为别人着想；臭鞋扔门口，公共区域乱占，等等</li></ul><h3 id="2-3-合作精神不足"><a href="#2-3-合作精神不足" class="headerlink" title="2.3 合作精神不足"></a>2.3 合作精神不足</h3><p>三个人合作能有八个心眼</p><h3 id="2-4-凡事我例外"><a href="#2-4-凡事我例外" class="headerlink" title="2.4 凡事我例外"></a>2.4 凡事我例外</h3><p>随地吐痰是不对的，看到了我就会上去批评，但我自己是可以吐一吐。<br>闯红灯是不对的，看到了我就会上去批评，但我自己是可以闯一闯。<br>诸如此类</p><h3 id="2-5-崇洋媚外分不清"><a href="#2-5-崇洋媚外分不清" class="headerlink" title="2.5 崇洋媚外分不清"></a>2.5 崇洋媚外分不清</h3><p>崇洋经常被认为是媚外。把西方好的东西拿来，这叫崇洋；向外国人谄媚，巴结讨好，这叫媚外。媚外着实是该批评，但崇洋是为了中华民族的伟大复兴。</p><h3 id="2-6-讲礼但不讲理"><a href="#2-6-讲礼但不讲理" class="headerlink" title="2.6 讲礼但不讲理"></a>2.6 讲礼但不讲理</h3><p>讲理会感觉丢面子，因此往往用逃避讨论的方式来对待，这样有了面子，但拒绝了讲理的过程。</p><h2 id="三：读后心得"><a href="#三：读后心得" class="headerlink" title="三：读后心得"></a>三：读后心得</h2><p>书中林林总总说了许多内容，我细细体会与总结，认为造成中国人不足之处的有以下原因：</p><ol><li>2000年的封建帝制与动荡，造成了中国人自尊的缺失，也使得中国人更多关注家而非国</li><li>儒家明哲保身的思想，禁锢了中国人的血性与灵性</li></ol><h2 id="三：何以促进中华民族的伟大复兴"><a href="#三：何以促进中华民族的伟大复兴" class="headerlink" title="三：何以促进中华民族的伟大复兴"></a>三：何以促进中华民族的伟大复兴</h2><ol><li>虚心而非骄傲，骄傲使人自满，民族亦是如此。一个虚心的民族，一个具有包容性的民族，才能永葆青春与活力</li><li>奋勇争先而非明哲保身。当今世界变化太快，逆水行舟，不进则退。唯有勇于进取，大胆创新，才能不被淘汰。</li><li>合作共赢而非窝里斗。人力有时穷，国家也如此。一个人再厉害，凭他自己也仅能完成有限的工作。唯有习惯合作，善于合作，劲往一处使，才能完成更大的事业</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>曾国藩-又笨又慢平天下</title>
    <link href="/2023/09/08/%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B/"/>
    <url>/2023/09/08/%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>一：概述</p><p>曾国藩，是近代儒家文化的集大成者。</p><p>二：读后感</p><ol><li>勤奋，极度的勤奋是成功的基石</li><li>贵人的赏识是一生中难得的机遇</li><li>纵有万千才华，也要与同僚打成一片</li><li>失败，连续的失败是对心灵考验，通过了能获得极大的提升，通不过有可能因此丧命</li><li>舍小义成全大义</li><li>稳，稳扎稳打，稳中求胜，稳到没有破绽</li></ol><p>笨而极致的勤奋；慢却稳定的前进，是这本书对我最重要的教育。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-ES13</title>
    <link href="/2023/09/07/ES6-ES13/"/>
    <url>/2023/09/07/ES6-ES13/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>ES6 ES7 ES8的名称由来是啥？</p><ul><li>ES6 就是 ES2015</li><li>ES7 就是 ES2016</li><li>ES8 就是 ES2017<br>。。。</li></ul><h2 id="二：各版本的特性"><a href="#二：各版本的特性" class="headerlink" title="二：各版本的特性"></a>二：各版本的特性</h2><ol><li>ES6的新特性<ul><li>let const 块作用域</li><li>箭头函数</li><li>for of </li><li>Map 和 Set</li><li>class</li><li>Promise</li><li>函数参数默认值</li><li>…</li><li>String.includes startsWith endsWith</li><li>Array.find findIndex</li><li>解构赋值</li></ul></li><li>ES7的新特性<ul><li>2 ** 3 &lt;&#x3D;&gt; Math.pow(2,3)</li><li>Array.includes</li></ul></li><li>ES8的新特性  ES2017<ul><li>String 的 padStart  padEnd 长度补全  如：‘5’.padStart(4,0)&#x3D;&gt; ‘0005’</li><li>Object.entries 来遍历对象 for(let [k,v] of Object.entries(obj))</li><li>Object.values</li><li>async await 函数</li></ul></li><li>ES9的新特性<ul><li>在循环中使用await for(){await xxxxx}</li><li>Promise.finally</li><li>对象剩余属性 允许把除了解构出的属性之外的剩余属性，放到一个新的对象中<br>  obj &#x3D; {a:1,b:2,c:3}; let {a,bc}&#x3D;obj &#x3D;&gt; a&#x3D;1 bc &#x3D;{b:2,c:3}</li><li>对象扩展属性 允许把对象的所有属性拷贝到另一个对象中<br>  let c &#x3D; {…obj}</li></ul></li><li>ES10的新特性<ul><li>String.trimStart trimEnd ‘    123’.trimStart &#x3D; ‘123‘</li><li>Object fromEntries     通过一个entries来创建对象</li><li>catch(e){} 如无需访问e，可以改成 catch{…}</li><li>Array flat 数组展平（降N维），默认降1维</li><li>Array flatMap 数组展平 + map</li><li>Array sort</li></ul></li><li>ES11的新特性<ul><li>BigInt</li><li>String matchAll</li><li>x &amp;&amp;&#x3D; y  当x 为真时，把Y赋给X</li><li>x ||&#x3D; y  当x 为假时，把Y赋给X</li><li>x ??&#x3D; y  当x 不存在时，把Y赋给X</li><li>?? 空值运算符,前边为空的时候设置成后边的默认值  x&#x3D; a ?? 0 &lt;&#x3D;&gt; if(a!&#x3D;undefined){x&#x3D;a}else{x&#x3D;0} </li><li>?.xxx   a.x  a存在时取值, 不存在时返回undefined</li></ul></li><li>ES12的新特性<ul><li>Promise.any</li><li>String replaceAll</li><li>Numeric Separators</li><li>数字分割符  1_0000_0000 &#x3D; 100000000</li></ul></li><li>ES13的新特性 即 ES2012<ul><li>Array at</li><li>String at</li><li>await import<br> 等等</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql innodb支持的隔离级别与mvcc</title>
    <link href="/2023/09/06/mysql-innodb%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8Emvcc/"/>
    <url>/2023/09/06/mysql-innodb%E6%94%AF%E6%8C%81%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8Emvcc/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-概述"><a href="#一：-概述" class="headerlink" title="一： 概述"></a>一： 概述</h2><p>我们都知道，mysql的默认引擎是innodb引擎，之前也提到过了innodb的数据组织方式（聚集索引）与查询过程。<br>本文我们讨论另外一个问题：即innodb的事务</p><h2 id="二：事务及事务的隔离级别"><a href="#二：事务及事务的隔离级别" class="headerlink" title="二：事务及事务的隔离级别"></a>二：事务及事务的隔离级别</h2><h3 id="2-1-什么是事务"><a href="#2-1-什么是事务" class="headerlink" title="2.1 什么是事务"></a>2.1 什么是事务</h3><p>想象你去银行给老王转账1000，那么银行会怎么操作呢？简单来说第一步扣你的钱，第二步给老王加钱。<br>如果第一步扣完你的钱，第二步执行失败了怎么办？如果没有任何后续处理，你可能会骂娘。<br>那应该怎么整呢？如果失败，把你的钱得加回来，并告知你转账操作失败。<br>转账这件事，不管它有多少个步骤，我们把它作为一个整体来看待，要么整体都成功，要么整体都失败，不存在一部分成功，一部分失败。<br>这就叫事务。</p><h3 id="2-2-事务的特征"><a href="#2-2-事务的特征" class="headerlink" title="2.2 事务的特征"></a>2.2 事务的特征</h3><p>事务有什么特征呢?</p><ol><li>原子性：要么都成功，要么都失败</li><li>一致性：事务开始前，事务结束后，数据库的一致性不能被破坏。</li><li>隔离性：多个事务并发进行时，事务之间是隔离的，一个事务不能影响其他事务</li><li>持久性：改完了应该落盘，持久化保存</li></ol><h3 id="2-3-事物的隔离级别及"><a href="#2-3-事物的隔离级别及" class="headerlink" title="2.3 事物的隔离级别及"></a>2.3 事物的隔离级别及</h3><p>啥叫事务的隔离级别？通俗来说就是并发进行的事务，对彼此的影响程度，影响程度越大，隔离级别越低，反之越高；</p><ol><li>read uncommited 即读未提交，能读到其他事物未提交的数据</li><li>read commited 即读已提交，能读到其他事物已提交的数据</li><li>repeatable read 即可重复度，对于之前读到的数据，后续的每次读，这些数据的值都相同，但可能会读到新的行。</li><li>serializable 串行化，并行的其他事物对本事务完全没影响</li></ol><h3 id="三：innodb支持的事务隔离级别"><a href="#三：innodb支持的事务隔离级别" class="headerlink" title="三：innodb支持的事务隔离级别"></a>三：innodb支持的事务隔离级别</h3><p>innodb支持的隔离级别，来到了serializable<br>怎么做到的呢?</p><ol><li>MVCC：多版本并发控制，行数据有多个版本（快照），每个事务只能读取到事务创建之前的数据快照，并且仅本事务可见，对数据的操作保存在事务缓冲区中，提交以后落到磁盘上。</li><li>锁管理：innodb实现了表级锁，和行级锁。<ul><li>共享&#x2F;排他锁(Shared and Exclusive locks)，是行级锁</li><li>意向锁（Intent locks），是表级锁，意向锁有共享意向锁（IS锁）和排他意向锁（IX锁）</li><li>记录锁（Record locks）</li><li>间隙锁（Gap locks）：锁定一个记录之间的区间，以防止幻读和脏读的发生</li><li>临建锁（Next-key locks）：结合了记录锁和间隙锁的锁，锁定一个记录及其区间，以防止幻读和脏读的发生</li></ul></li><li>redolog：记录了每个事务读对数据库的修改操作，用于数据恢复</li><li>undolog：innodb通过回滚日志来回滚事务，回滚时逆序执行从而保证数据的一致性<br> 如操作时增加一行，那回滚日志中记录的应该是删除该行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引建立指导规则及慢查询分析</title>
    <link href="/2023/09/05/mysql%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E5%AF%BC%E8%A7%84%E5%88%99%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/05/mysql%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E5%AF%BC%E8%A7%84%E5%88%99%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>之前的文章中提到过mysql innodb的索引结构，这篇文章探讨mysql的索引建立规则，即慢查询。</p><h2 id="二：索引建立规则"><a href="#二：索引建立规则" class="headerlink" title="二：索引建立规则"></a>二：索引建立规则</h2><ol><li>满足最左前缀匹配原则。在建立索引时需考虑将来的应用场景，及可能的需求变化。</li><li>尽量选择区分度高的列作为索引。区分度 &#x3D; count(distinct col)  &#x2F; count(col) ，通俗来说就是相同的值比较少的列</li><li>尽量的扩展索引而非新建索引</li><li>索引尽量建立在小字段上，一些长的文本字段，不要建立索引</li></ol><h2 id="三：慢查询如何分析"><a href="#三：慢查询如何分析" class="headerlink" title="三：慢查询如何分析"></a>三：慢查询如何分析</h2><ol><li><p>explain 查看执行计划</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">explain <span class="hljs-keyword">select</span> * from xxx <span class="hljs-built_in">where</span> xxxx;<br></code></pre></td></tr></table></figure></li><li><p>开启慢查询日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> global show_query_log = on; <span class="hljs-comment"># 这种是在交互式命令中的方式，如果数据库重启，这些就会失效，如果需要长期有效，需要修改mysql的配置文件</span><br>show variables like <span class="hljs-string">&#x27;%long%&#x27;</span>; <br><span class="hljs-built_in">set</span> long_query_time=0.02;// <span class="hljs-comment"># long_query_time是慢查询的临界值单位秒</span><br></code></pre></td></tr></table></figure><p> 慢查询日志的样子：<br> <img src="/pic/manchaxunrizhi.jpg" alt="慢查询日志"></p></li><li><p>开启性能详情</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show variables like <span class="hljs-string">&#x27;%profiling%&#x27;</span><br><span class="hljs-built_in">set</span> profiling = on<br></code></pre></td></tr></table></figure></li></ol><h2 id="四：慢查询的常见原因"><a href="#四：慢查询的常见原因" class="headerlink" title="四：慢查询的常见原因"></a>四：慢查询的常见原因</h2><ol><li>没加索引&#x2F;没用索引导致全表扫描</li><li>单标数据量太大。这种情况看下索引设置的到底对不对，要么考虑分表</li><li>limit 深分页。比方说每页10条，去获取第十万页的数据。 如 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> click <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure> 即使click加了索引，但因为二级索引的叶子结点保存的是主键的值，每条记录还需要回表查询才能知道是否需要丢弃，在该例子中，需要回表100010次，因此会很慢。<br> 这种情况下，需要考虑先查出主键ID，再根据主键查出所有字段 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br>xxx t1,<br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">where</span> click <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10000</span>,<span class="hljs-number">10</span>) t2<br><span class="hljs-keyword">where</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure></li><li>排序不当，导致使用filesort查询<br> 如果  order by xxx 这个xxx不能由查询此sql使用的索引直接完成，mysql就有可能会进行filewort<ul><li>如查询的数量较少，没有超过系统变量sort_buffer_size的大小，会进行内存排序（快排）</li><li>如查询的数量较多，超过了该系统变量，会使用文件进行排序（归并）<br> 会使用filesort查询的场景</li></ul><ol><li>order by 用的字段，不是查询该sql使用到的索引。解决方案：排序字段加索引</li><li>俩排序字段，一个正序，一个倒序，解决方案：可分析需求，然后比方说加个字段，在新的字段上排序，</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引结构及失效情景汇总</title>
    <link href="/2023/09/04/mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%A4%B1%E6%95%88%E6%83%85%E6%99%AF%E6%B1%87%E6%80%BB/"/>
    <url>/2023/09/04/mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%A4%B1%E6%95%88%E6%83%85%E6%99%AF%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一：mysql的索引结构"><a href="#一：mysql的索引结构" class="headerlink" title="一：mysql的索引结构"></a>一：mysql的索引结构</h2><p>mysql是一个关系型数据库；<br>mysql的存储引擎最主要的有两个，一个是myisam，一个是innodb，下面我们分别来说明二者的索引结构</p><ol><li><p>myisam</p><ul><li>myisam的索引，结构是B+树，叶子节点保存的是数据记录的地址，也就是说它的索引和数据是分开的，叫非聚簇索引。</li><li>myisam的主键索引和非主键索引本质上没有区别，叶子节点都保存的是数据记录的地址</li></ul></li><li><p>innodb</p><ul><li>innodb的索引，结构是带有数据访问指针的B+树</li><li>主键索引的叶子结点，保存的是数据记录本身；非主键索引的叶子节点，保存的是主键值</li><li>由于innodb的索引，其索引和数据是在一起的，因此被称为聚簇索引</li><li>为提升读取性能，innodb的各节点在磁盘中是一个数据页<ol><li>每个节点是一个磁盘页，这样方便读入内存</li><li>每当访问某磁盘页，将读取其相邻的磁盘页，这个操作叫做磁盘预读，因此其相邻的磁盘页也能很快的被访问到；</li></ol></li><li>由于非叶子结点不存数据，所以这颗B+树的阶非常高（即非叶子结点可以储存非常多的数据项），故数高很小，一个近百万数据的表，可能其数高只有3.</li></ul><p> 一个直观的innodb索引例子：<br> <img src="/pic/innocbbjiatree.jpg" alt="innodbB+树索引"><br> 其中，一个浅蓝色的区域是一个磁盘页，深蓝色的是数据项，P1 P2 P3 是指针</p></li></ol><p>由于mysql的默认引擎是innodb，所以接下来我们的讨论都基于innodb引擎。</p><h2 id="二：B-树的增删改查"><a href="#二：B-树的增删改查" class="headerlink" title="二：B+树的增删改查"></a>二：B+树的增删改查</h2><p>B+树从B树演变而来，与B树的区别是B+树的非叶子节点只保存导航信息，所有数据都保存在叶子结点；<br>下面是一颗深度为4的三阶B+树</p><p><img src="/pic/bjiatree.jpg" alt="b+tree"></p><p>解释:</p><ul><li>每个节点最多有3个子节点，因此叫做3阶</li><li>根节点+非叶节点+叶节点，共4层，因此深度为4</li><li>每个非叶子节点，其节点上都存有</li></ul><p>增删改查要点</p><ul><li>B+树的增，需保持B+树的阶，一旦某节点的子节点数量超过3，需要分裂该节点，并查看父节点是否也有相同的问题。</li><li>B+树的删，同样需保持B+树的阶，B+树的子节点，不得小于m&#x2F;2，小于之后需要合并节点</li><li>B+树的改，不存在节点结构的变化</li><li>B+树的查，时间复杂度为log(n)，具体过程是每次取出一个节点（即读入一个数据页），比较，确定下一步的查询指针，然后继续这个过程。</li></ul><h2 id="三：innodb的查找策略"><a href="#三：innodb的查找策略" class="headerlink" title="三：innodb的查找策略"></a>三：innodb的查找策略</h2><ol><li>主键查询, 查询主键索引即可</li><li>查询用到了非主键索引（也叫辅助索引，二级索引），且所需返回的字段在索引中就有，这时只需要查找辅助索引</li><li>查询用到了非主键索引，如联合索引，所需返回的字段在索引中不全，这时候需要查询主键索引（也叫回表查询）</li><li>如压根没用到索引，需要全表扫描</li></ol><h2 id="四：innodb的索引失效场景"><a href="#四：innodb的索引失效场景" class="headerlink" title="四：innodb的索引失效场景"></a>四：innodb的索引失效场景</h2><ol><li>联合索引不满足最左前缀匹配原则</li><li>索引列参与计算，包括使用了一些函数</li><li>like %在最左边</li><li>类型隐式转换，如在varchar类型的字段上，查找时写int型的值</li><li>使用or操作</li><li>一些比较  &lt;  &gt; !&#x3D; ; isnot null ;not in ; not exists</li></ol><h2 id="五：优化项"><a href="#五：优化项" class="headerlink" title="五：优化项"></a>五：优化项</h2><ol><li>尽量避免使用select * ,而使用select 具体的字段，以期望走覆盖索引</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IM服务器设计与进化</title>
    <link href="/2023/09/03/IM%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%9B%E5%8C%96/"/>
    <url>/2023/09/03/IM%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%9B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>IM：instant messaging ，中文翻译”即时通讯“，干啥的呢？就是我发个消息，你即时的就能看见。<br>那么IM消息的整个系统都有哪些东西呢？</p><ol><li>客户端。用来发送玩家的消息给服务器，接收并显示群内玩家的消息；</li><li>服务端。用来接收并处理玩家的消息，以及给某玩家推送消息<br>有人问客户端自己能不能干这事？不能，因为我想给老王发个消息，但老王在哪我是不知道的，因为老王和我没有连接，所以只好找个中间商，中间商就固定在某个位置，我俩分别于中间商连接，那我俩也就可以连接了。</li></ol><h2 id="二：仅支持单聊的IM消息服务器，IM服务器1-0版"><a href="#二：仅支持单聊的IM消息服务器，IM服务器1-0版" class="headerlink" title="二：仅支持单聊的IM消息服务器，IM服务器1.0版"></a>二：仅支持单聊的IM消息服务器，IM服务器1.0版</h2><p>还是我和老王，我俩都连接了服务器这个中间商，我俩想通个话，怎么整呢？</p><ol><li>首先，我与服务器建立了连接，这个连接有一个唯一的标识，</li><li>然后，老王也与服务器建立了连接，这个连接也有一个唯一的标识</li><li>我想向老王发送一条消息：“吃了吗？”</li><li>那么我先向IM消息服务器发一条消息，说我想向老王发条消息。</li><li>IM服务器接收到了这条消息，它看看在线的人里面有没有老王，发现有，然后把消息发送给老王，然后告诉我发送成功。</li><li>老王接收到这条消息，我本地在服务器告诉我成功之后，也显示了这条消息。</li></ol><p>上边是通俗的讲法，下面是技术的讲法</p><ol><li>我与im服务器建立长连接，如通过socketio建立了长连接 s1，登录信息与长连接的关系保存到服务器，如&lt;playerId1: s1&gt;</li><li>老王与im服务器建立长连接，如通过socketio建立了长连接 s2，登录信息与长连接的关系保存到服务器，如&lt;playerId2: s2&gt;</li><li>我发言，本质上是客户端通过s1，向服务器发送消息：<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">sendMessage:</span> &#123;playerId = playerId2, message = <span class="hljs-string">&quot;吃了吗&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li>IM服务器接收到之后，在缓存中找有没有playerId2，如有，通过playerId2找到s2, 然后通过s2将message发送给playerId2, 同时将此信息发送给playerId1一份。</li><li>双方收到服务器推送的消息，分别展示这条消息</li></ol><p>如此设计，一个简单的单聊IM服务器，就成型了。</p><p>那么它有什么问题？</p><ol><li>只能单聊，群聊暂不支持。我想8个人一起聊，不能实现。</li><li>如果有人掉线了，发向此人的消息他接收不到，那人重新上线，也无法看到，简单来说这条消息丢了。</li></ol><h2 id="三：支持群聊和消息历史的IM服务器，IM消息服务器2-0版"><a href="#三：支持群聊和消息历史的IM服务器，IM消息服务器2-0版" class="headerlink" title="三：支持群聊和消息历史的IM服务器，IM消息服务器2.0版"></a>三：支持群聊和消息历史的IM服务器，IM消息服务器2.0版</h2><p>1.0版本解决只能单聊和消息丢失的问题，那么如何解决？</p><p>通俗来讲：</p><ol><li>通过发言前建立群组，把想群聊的这些人的信息归于一处，来支持群聊，这样就能知道你的发言应该发给谁谁谁</li><li>通过把发言备份到一个可靠的地方，作为历史发言记录，解决消息丢失的问题</li></ol><p>下面是技术的讲法</p><ol><li>playerId1,playerId2,playerId3分别于im服务器通过socketio建立了长连接 s1,s2,s3</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，创建个群组的数据group: {playerIds:[playerId1,playerId2,playerId3]},然后告知playerId1成功，并且通知到playerId2和playerId3这个组建群聊成功</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM收到该请求，查找到该群聊，查找到群聊中的playerid1,2,3，然后分别向playerId1,2,3发送此条消息，并且存储此条群聊的消息到数据库（如redis,mongodb）</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>如果playerId3 断线之后，playerId2说了句“去吃饭”呢？</p><ol><li>客户端保存有群聊最大的消息序号x，与im服务器建立长连接后，先问IM服务器询问目前最新的消息序号y，如x&lt;y，说明客户端存着的消息是滞后的，因此通过请求IM服务器的方式拿到x之后的群聊消息，并及时更新自己的最大消息序号到y</li></ol><p>看起来目前的版本已经支持了群聊，也解决了消息丢失问题。那么它还有什么问题？</p><ol><li>当同时发言的人数多的时候，这台服务器会处理不过来，表现为消息发出去以后老半天不见动静</li></ol><h2 id="四，理论上支持无限人聊天的IM服务器，IM服务器3-0版"><a href="#四，理论上支持无限人聊天的IM服务器，IM服务器3-0版" class="headerlink" title="四，理论上支持无限人聊天的IM服务器，IM服务器3.0版"></a>四，理论上支持无限人聊天的IM服务器，IM服务器3.0版</h2><p>2.0版本的单台服务器在人多时的性能问题，该如何解决？<br>答曰，分布式。分布式也就是多服务的意思，这些服务可能在一个服务器，也可能在多个服务器，这种方式理论上能近乎无限的提升服务的性能，但他会带来一些挑战：</p><ol><li>群聊里的人可能来自不同的服务器，因此消息发送将更复杂</li><li>当多人近乎同时发送消息时，需要保证群聊里的所有人完整，准确，顺序相同的拿到这些人的发言。不能顺序不一样，更不能缺失。</li></ol><p>那么服务器该如何设计呢？<br>通俗来讲：</p><ol><li>客户端创建的群组信息，要所有服务器都能看到，且都能获取，并且群组信息里除了要有用户的ID之外，还得有他在哪台服务器，这样才能找到这个用户在哪</li><li>用户上线时，需要更新一下群组信息，说明我目前连的是这台服务器</li><li>对于来自同一个群组内同时发言的这些请求，不管它有多少，整个服务器部分同时只处理一个</li></ol><p>下面是技术的讲法</p><ol><li>playerId1,playerId2,playerId3分别于im服务器A,B,C 通过socketio建立了长连接 s1,s2,s3</li><li>playerId1,2,3,分别更新自己在数据库中的数据，使server&#x3D;A&#x2F;B&#x2F;C</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，查找数据库，找到playerId1,2,3的数据，拿到各自的server，并创建群组的数据<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">group: &#123;players:[<br>  &#123;id:playerId1,server:A,socket:s1&#125;,<br>  &#123;id:playerId2,server:B,socket:s2&#125;,<br>  &#123;id:playerId3,server:C,socket:s3&#125;,<br>]&#125;,<br></code></pre></td></tr></table></figure>然后告知playerId1成功，并且通知发送消息给B和C，中的playerId2和playerId3这个组建群聊成功</li><li>IM的全局kafka消费者实例，订阅群聊的topic : “群聊ID”，xxxxx.subscribe(‘xxxx’);</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM接收到kafka的消息后，取出群聊消息，查找到该群聊，查找到群聊中的playerid1,2,3，拿到各自的server，然后向playerId1,2,3发送此条消息，并且存储此条群聊的消息到数据库（如redis,mongodb）</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>对于多个服务来说，各服务的在线状态需要同步，如果当前的流量较大，还需要动态的新增服务，简单来说服务需要管理。kubernetes集群是个可行的方案。</p><p>看起来目前的版本已经支持了分布式的服务，那么它还有什么问题？</p><ol><li>逻辑更复杂，客户端连接与消息处理的逻辑耦合在一起，IM服务器的代码将更加复杂，系统的可维护性降低</li><li>可测试性下降，单元测试和集成测试可能需要启动整个im服务器来进行</li><li>耦合性强，难以将消息的处理部分抽离出来，用于其他功能或服务</li><li>代码维护困难，很好理解，越复杂，就越难维护。</li></ol><h2 id="五，架构更优的IM服务器，IM服务器4-0版"><a href="#五，架构更优的IM服务器，IM服务器4-0版" class="headerlink" title="五，架构更优的IM服务器，IM服务器4.0版"></a>五，架构更优的IM服务器，IM服务器4.0版</h2><p>3.0版本的高耦合问题，该如何解决？</p><p>通俗来讲：</p><ol><li>将IM服务器的管理客户端连接，群组管理，发送消息的功能；与对消息的处理功能，分开，各自干各自的事情</li></ol><p>下面是技术的讲法：</p><ol><li>新建若干消息消费者服务器，这些服务器用于消息处理</li><li>IM服务器只负责管理与客户端的连接，群组管理，向客户端发送消息，以及接收来自消费者服务器的消息</li></ol><p>当玩家创建群组时：</p><ol><li>playerId1,playerId2,playerId3分别于im服务器A,B,C 通过socketio建立了长连接 s1,s2,s3</li><li>playerId1,2,3,分别更新自己在全局redis集群中的数据，即playerId1的server&#x3D;A，</li><li>playerid1想组建个群聊，成员分别是playerid1,playerId2,playerId3，因此向IM服务器发送组建群聊请求</li><li>IM收到该请求，查找数据库（redis），找到playerId1,2,3的server，并创建群组的数据，并保存到数据库（如redis）<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-attribute">group</span>: &#123;<span class="hljs-attribute">players</span>:[<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId1</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId2</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">playerId3</span>&#125;,<br>]&#125;,<br></code></pre></td></tr></table></figure>然后告知playerId1成功，并且通知发送消息给B和C，中的playerId2和playerId3这个组建群聊成功</li><li>IM通知消息服务，消息服务接到通知后开始subscribe 此topic, topic名字是群组的ID</li><li>playerId1,2,3接收到组建群聊成功消息后，在UI界面展示群组信息</li></ol><p>当玩家发言时：</p><ol><li>playerId1发言：”干啥去”，playerId 向IM发送向某群聊发送消息请求</li><li>IM接收到请求，验证playerId1的身份，将消息存入数据库，并向kafka发送一条消息。topic为群聊ID<br>3.消息消费者拿到来自kafka的消息后，取出群聊的消息，在redis中找到该群聊，取出其中的playerId, 然后从全局redis中找到playerId对应的server，然后给对应的IM服务器发送消息，类似如{server:A,playerId:’playerId1’,”message”:”干啥去”}</li><li>IM服务器接收到来自消息消费者的消息后，验证是否连接有playerId, 如果有，通过socketio向该用户发消息</li><li>playerId1,2,3接收到IM的消息推送后，在各自的UI中展示这条消息</li></ol><p>目前的架构，有如下特征：</p><ol><li>IM服务可以是任意多个，负责处理连接，管理群组，发送消息</li><li>消息消费者服务可以是任意多个，负责处理消息，形成明确的消息发送指令，并给到IM服务</li><li>kafka作为中间件存在，负责异步转同步，流量削峰</li><li>IM和消息消费者服务职责明确，有利于维护</li></ol><p>看起来似乎不错了，那么它还有哪些问题？</p><ol><li>鉴权，不是什么人都能发消息，因此需要增加鉴权</li><li>全局的redis来储存用户所在的server信息，一旦redis挂了，所有人都不能聊天了，因此可以考虑redis与mongodb结合，缓存+DB的形式，这将增加开发的复杂度</li><li>消息发从到kafka这段如果失败，就会消息丢失，需要设计个类似接收回执的逻辑</li></ol><p>但主体的架构已经完成，总体来说是个还不错的IM服务器架构。</p><p>这里先空着，我将给出架构图：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> empty <br></code></pre></td></tr></table></figure><h2 id="六：下一代IM服务器的方向在哪里"><a href="#六：下一代IM服务器的方向在哪里" class="headerlink" title="六：下一代IM服务器的方向在哪里"></a>六：下一代IM服务器的方向在哪里</h2><p>本着大胆想象的原则，让我们畅想一下下一代的IM服务器。<br>但我这里还没有具体的答案，但大概有一些关键词，如AI，去中心化和边缘计算，有待思考和讨论</p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器和容器化技术概述</title>
    <link href="/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/01/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一：容器和容器化"><a href="#一：容器和容器化" class="headerlink" title="一：容器和容器化"></a>一：容器和容器化</h2><ol><li>什么是容器<br> 容器是一种轻量级，可移植的封装，它包括应用程序及其依赖项，以便在不同的计算环境中运行。简单来说他就是个集装箱，包含有应用程序及它运行所需的各种支持。</li><li>什么是镜像<br> 镜像是一个只读的文件系统快照，包含了一个应用程序及其所有依赖项的文件和设置。这个快照可以用于创建运行容器的实例。镜像包含了应用程序的二进制文件、库、环境变量、配置文件等，使得容器能够在隔离的环境中运行。</li><li>什么是容器化和容器化技术<br> 容器化是一种应用程序部署和交付的方法，它是一种理念，旨在将应用程序及其依赖项打包成一个可移植的容器，容器可以可以在不同的环境中运行。<br> 容器化技术是实现这一理念的一些工具和技术，包括容器运行时（docker，containd,podman），镜像（docker镜像，OCI镜像），容器编排工具（Kubernetes，docker compose等）等</li></ol><h2 id="二：Docker概述"><a href="#二：Docker概述" class="headerlink" title="二：Docker概述"></a>二：Docker概述</h2><p>Docker 是一种容器化平台，用于创建、部署和管理容器化应用程序。</p><h3 id="2-1-Docker-的主要功能"><a href="#2-1-Docker-的主要功能" class="headerlink" title="2.1 Docker 的主要功能"></a>2.1 Docker 的主要功能</h3><ol><li>容器化：Docker 允许开发人员将应用程序及其依赖项打包成容器，使应用程序具有独立性、可移植性和一致性，可以在不同环境中运行。</li><li>镜像管理：Docker 镜像是容器的基础，它们包含了应用程序和其依赖项的文件系统快照。Docker 提供了创建、管理和共享镜像的工具。</li><li>容器编排：Docker 提供了容器编排工具，如 Docker Compose 和 Docker Swarm，用于管理多个容器的部署，实现高可用性、负载均衡和伸缩性。</li><li>跨云部署：Docker 容器可以在不同的云提供商之间轻松迁移，支持多云部署策略。</li><li>快速启动和停止：Docker 容器可以在几秒内启动和停止，加速了应用程序的部署和扩展。</li></ol><h3 id="2-2-Docker的组件"><a href="#2-2-Docker的组件" class="headerlink" title="2.2 Docker的组件"></a>2.2 Docker的组件</h3><p>Docker 由以下主要组件组成：</p><ol><li>Docker Daemon（Docker 服务端）：后台运行的服务，负责管理容器的创建、启动、停止、删除等任务。</li><li>Docker 客户端：用户与 Docker 交互的命令行工具或 API 客户端，可发送指令给 Docker Daemon。</li><li>Docker 镜像：容器的基础，包含应用程序及其依赖项的文件系统快照。</li><li>Docker 镜像仓库：用于存储和共享 Docker 镜像的中央存储库，Docker Hub 是一个常见的公共仓库。</li><li>Dockerfile：文本文件，包含创建 Docker 镜像的指令和配置信息。</li><li>Docker 网络：用于容器之间通信以及与外部网络连接的网络配置。</li><li>Docker 数据卷：用于容器内外数据共享和持久性存储的机制。</li><li>Docker Compose：用于定义和运行多个 Docker 容器的应用程序的工具。</li></ol><h3 id="2-3-如何使用docker"><a href="#2-3-如何使用docker" class="headerlink" title="2.3 如何使用docker"></a>2.3 如何使用docker</h3><ol><li>创建dockerFile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用官方 Node.js 镜像作为基础镜像</span><br>FROM node:14<br><br><span class="hljs-comment"># 设置工作目录</span><br>WORKDIR /usr/src/app<br><br><span class="hljs-comment"># 复制项目文件到容器中</span><br>COPY package*.json ./<br>COPY . .<br><br><span class="hljs-comment"># 安装项目依赖</span><br>RUN npm install<br><br><span class="hljs-comment"># 暴露端口</span><br>EXPOSE 3000<br><br><span class="hljs-comment"># 启动应用程序</span><br>CMD [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]<br></code></pre></td></tr></table></figure></li><li>构建镜像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t my-node-app .<br></code></pre></td></tr></table></figure></li><li>运行Docker容器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 3000:3000 -d my-node-app<br></code></pre></td></tr></table></figure></li></ol><h2 id="三：kubernetes概述"><a href="#三：kubernetes概述" class="headerlink" title="三：kubernetes概述"></a>三：kubernetes概述</h2><p>大服务集群上容器的部署，伸缩和管理的各种问题，衍生出来了容器编排引擎，比较著名的有 Mesos, DockerSwarm, Kubernetes。<br>Kubernetes名字太长了，叫起来有点麻烦，而Kubernetes首字母与结尾字母之间有8个字母，因此被称作K8S。</p><h3 id="3-1-kubernetes的相关概念"><a href="#3-1-kubernetes的相关概念" class="headerlink" title="3.1 kubernetes的相关概念"></a>3.1 kubernetes的相关概念</h3><p>k8s概念及架构</p><ol><li>cluster<br>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用</li><li>master<br>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master</li><li>node<br>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。Node运行在Linux操作系统上，可以是物理机或者是虚拟机。</li><li>pod<br>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。同一个pod管理的多个容器之间可以通信和资源共享。</li><li>controller<br>Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。Controller中定义了Pod的部署特性，比如有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等</li><li>service<br>Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。<br>Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。</li><li>namespace<br>Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的</li></ol><h3 id="3-2-kubernetes的架构"><a href="#3-2-kubernetes的架构" class="headerlink" title="3.2 kubernetes的架构"></a>3.2 kubernetes的架构</h3><h4 id="3-2-1：-master节点"><a href="#3-2-1：-master节点" class="headerlink" title="3.2.1： master节点"></a>3.2.1： master节点</h4><p><img src="/pic/kubernetes-master.jpg" alt="master"></p><p>master是kubernetes cluster的大脑</p><ul><li>API Server：提供HTTP&#x2F;HTTPS RESTful API，即Kubernetes API。API Server是Kubernetes Cluster的前端接口，各种客户端工具（CLI或UI）以及Kubernetes其他组件可以通过它管理Cluster的各种资源</li><li>Scheduler：负责决定将Pod放在哪个Node上运行。Scheduler在调度时会充分考虑Cluster的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</li><li>Controller Manager：负责管理Cluster各种资源，保证资源处于预期的状态。Controller Manager由多种controller组成，包括replicationcontroller、endpoints controller、namespace controller、serviceaccountscontroller等。不同的controller管理不同的资源。例如，replication controller管理Deployment、StatefulSet、DaemonSet的生命周期，namespacecontroller管理Namespace资源</li><li>etcd：负责保存Kubernetes Cluster的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速地通知Kubernetes相关组件</li><li>Pod网络：Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案</li><li>kubelet和kube-proxy见node节点的结构（master同时也是一个node，可以运行应用）</li></ul><h4 id="3-2-2：-node节点"><a href="#3-2-2：-node节点" class="headerlink" title="3.2.2： node节点"></a>3.2.2： node节点</h4><p>node是pod运行的地方。</p><p><img src="/pic/kubernetes-node.jpg" alt="node"></p><ul><li>kubelet：kubelet是Node的agent，当Scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息（image、volume等）发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。</li><li>kube-proxy：kube-proxy负责将访问service的TCP&#x2F;UPD数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡</li><li>pod网络：同上</li></ul><h4 id="3-2-3：单master架构"><a href="#3-2-3：单master架构" class="headerlink" title="3.2.3：单master架构"></a>3.2.3：单master架构</h4><p><img src="/pic/kubernetes-master-node.jpg" alt="gingle-master"></p><h3 id="3-3：组件间的协作"><a href="#3-3：组件间的协作" class="headerlink" title="3.3：组件间的协作"></a>3.3：组件间的协作</h3><p>kubectl run httpd-app –image&#x3D;httpd –replicas&#x3D;2 发生了什么？</p><p><img src="/pic/kubernetes-4.jpg" alt="image"></p><ol><li>kubectl发送部署请求到API Server</li><li>API Server通知Controller Manager创建一个deployment资源</li><li>Scheduler执行调度任务，将两个副本Pod分发到k8s-node1和k8s-node2</li><li>k8s-node1和k8s-node2上的kubectl在各自的节点上创建并运行Pod</li></ol><h3 id="3-4：kubectl命令"><a href="#3-4：kubectl命令" class="headerlink" title="3.4：kubectl命令"></a>3.4：kubectl命令</h3><p>kubectl的语法：kubectl [command] [TYPE] [NAME] [flags]</p><ul><li>command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete</li><li>type：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式</li><li>name：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息，如 kubectl get pods</li><li>flags：指定可选的参数。例如，可以使用 -s 或 -server 参数指定 Kubernetes API 服务器的地址和端口</li></ul><p>常用命令示例：</p><ul><li>kubectl get pods</li><li>kubectl get nodes</li><li>kubectl create -f nginx-deployment.yaml</li><li>kubectl delete po rc-nginx-btv4j</li><li>kubectl scale rc rc-nginx-3 —replicas&#x3D;4</li><li>kubectl logs mysql-478535978-1dnm2</li><li>kubectl expose rc nginx –port&#x3D;80 –target-port&#x3D;8000（为RC的nginx创建service，并通过Service的80端口转发至容器的8000端口上）</li><li>kubecl run xxxxx 创建并运行一个或多个容器镜像</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>《每天五分钟玩转Kubernetes》</li><li>《深入浅出Docker》</li><li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">kubernetes官方交互式教程</a>：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">kubectl命令文档</a>：<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create</a></li><li><a href="http://docs.kubernetes.org.cn/475.html">kubectl中文文档</a>：<a href="http://docs.kubernetes.org.cn/475.html">http://docs.kubernetes.org.cn/475.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英文字母起源</title>
    <link href="/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/"/>
    <url>/2023/09/01/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E8%B5%B7%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h2><p>英语的26个字母最初起源于埃及象形文字，后由腓尼基人改进发明了腓尼基字母，希腊人对腓尼基字母加以改革后创造了希腊字母，古罗马人对希腊字母加以改革进而发明了拉丁字母，英文字母就属于拉丁字母。</p><h2 id="二：拉丁字母的起源，含义及引申含义"><a href="#二：拉丁字母的起源，含义及引申含义" class="headerlink" title="二：拉丁字母的起源，含义及引申含义"></a>二：拉丁字母的起源，含义及引申含义</h2><p>A 牛头 牛角；引申为牛角尖锐，针刺，酸痛，食物中最重要的部分<br>B 房屋；<br>C 骆驼；引申为运输，行走，携带，覆盖<br>D 门；引申为向下<br>E 窗户；引申为开关窗户的动作，向外伸延，引申，透过窗户可以看到外面<br>F 失败；引申为错误，失败；由附着引申为漂浮，表面，刀剑等含义<br>G 骆驼的头颈部；由C变化而来，引申为从深处出来，向深处拉<br>H 栅栏；人，围墙，连接，界限，高处；引申为相邻的房间<br>I 手指；人，树，水滴；引申为尖端，一点，火，目标，插，按，蜡烛，多代表与光明相关的东西<br>J 由I变化而来；表勾，挖，捏，握紧，夹紧等手指弯曲做出的动作；<br>K 手掌；张开，拖，压，推等手掌做的动作，引申为统治者，张开，裂开，开口，锋利，打架等<br>L 鞭子；引申含义：拉，抽，打，绕、绑东西的动作，长的，长远的，男性，驯服<br>M 海浪；山峰，引申含义： 男性 牢固 坚强 力量 多 咬合 匹配 合并 碰撞 记忆<br>N 鱼；引申：捞，收缩，摆动，跳跃，连接<br>O 眼睛；引申：转动 范围 开关 循环 观察 圆 女性<br>P 嘴唇；扁的，紧贴，吹，吐，含，吸，引申为向上，突出，顶端<br>Q 垂着尾巴的猴子；引申：收缩，汇集，挠，跳等猴子的动作；象征女性头部，表示女人， 问题<br>R 狗；代表生命力强的，侦查，看守，记忆，杂乱 引申：上司，高层，火苗，河流，招手，跑步<br>S 牙齿，沙丘；代表坚硬，相似，锋利，痕迹，咬，撕开等牙的特征和动作。引申为口舌，女人，流沙，蛇，音符，沙丘，弯腰动作，身体<br>T 叉号；引申为符号，字符，信息，识别，指示，启示，长久，不变，固定，神 工具<br>U 木栓孔; 由V延伸而来；引申含义有宽裕的 间距 容纳 器具 集中<br>V 木钉；引申为拉动，插动，活动，保卫，防护，固定，钉子，山谷，交叉，空，空虚<br>W 由V派生而来；double u,两个门栓，含义由保障，引申为女性 水 错误<br>X 问号；代表未知，无限，目标，希望，极致，顶峰，高贵，冷艳，完美，引申为交叉，四面八方，迷惑，错误<br>Y 早期将Y认为是上边的V和下面的I的组合; 引申：分支，道路，裂开，裂缝，岔生，产生，青年，年轻的，从前，确定<br>Z 宙斯；引申狂热，热情，速度，曲折的</p><h2 id="三：总结"><a href="#三：总结" class="headerlink" title="三：总结"></a>三：总结</h2><p>通过以上的统计，我们得出如下规律</p><h4 id="3-1-字形上，一些字母由其他字母演变而来"><a href="#3-1-字形上，一些字母由其他字母演变而来" class="headerlink" title="3.1 字形上，一些字母由其他字母演变而来"></a>3.1 字形上，一些字母由其他字母演变而来</h4><ol><li>G由C变化而来</li><li>J由I变化而来</li><li>U,W由V延伸而来</li><li>Y是一个意外，把上边的V和下边的I看成了一个字母</li></ol><h4 id="3-2-子母的含义，由几部分组成"><a href="#3-2-子母的含义，由几部分组成" class="headerlink" title="3.2 子母的含义，由几部分组成"></a>3.2 子母的含义，由几部分组成</h4><ol><li>基本含义</li><li>由基本含义引申出的含义</li><li>由字形特征引申出的含义</li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>generator函数与Async/await函数</title>
    <link href="/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/09/01/generator%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>generator函数是一个迭代器</p><h2 id="二-详情"><a href="#二-详情" class="headerlink" title="二 详情"></a>二 详情</h2><p>Generator 函数是ECMAScript 6（ES6）中的一种特殊类型的函数，它能够产生迭代器（Iterator）。与普通的函数不同，Generator 函数可以暂停执行并随时恢复执行，而不会丢失函数的内部状态。这使得它们在处理异步操作、流控制和延迟执行方面非常有用。</p><p>Generator 函数通过使用特殊的关键字 function* 来声明，并在函数体内部使用 yield 表达式来暂停函数的执行并返回一个产生的值。每次调用 yield 都会暂停函数的执行，同时返回一个迭代器对象，您可以使用该迭代器对象来恢复函数的执行。调用生成器函数不会立即执行函数体，而是返回一个生成器对象，您需要显式地调用该生成器对象的 next() 方法来触发函数的执行。</p><p>简单来说：Generator函数是一个迭代器。</p><p>一个Generator函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-params">millionSeconds</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">res</span>(<span class="hljs-number">1</span>);<br>        &#125;, millionSeconds);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFunc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timeoutAsync</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">generatorFunc</span>();<br>    <span class="hljs-keyword">let</span> a = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next a=`</span>, a);<br>    <span class="hljs-keyword">let</span> b = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-keyword">let</span> bResult = <span class="hljs-keyword">await</span> b.<span class="hljs-property">value</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next b=`</span>, b, <span class="hljs-string">`bResult = <span class="hljs-subst">$&#123;bResult&#125;</span>`</span>);<br>    <span class="hljs-keyword">let</span> c = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next c=`</span>, c);<br>    <span class="hljs-keyword">let</span> d = gen.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`gen.next d=`</span>, d);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>());<br>&#125;<br><span class="hljs-title function_">test</span>();<br><br></code></pre></td></tr></table></figure><p>结合以上例子，我们来总结一下generator函数的用法：</p><ol><li>generator函数需要用“*”来声明</li><li>yield 后面需要跟的是可被迭代的东西 ，数值，表达式都行</li><li>如果yield后面跟一个promise，那么执行时迭代到这里，next中的value也是一个promise，需要自己手动去await执行</li><li>每次next，都会返回一个对象，该对象中的value表示被迭代的值，done表示是否完毕</li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从koa到koa2</title>
    <link href="/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/"/>
    <url>/2023/08/31/%E4%BB%8Ekoa%E5%88%B0koa2/</url>
    
    <content type="html"><![CDATA[<h2 id="一：-Koa2简介及与Koa1的区别"><a href="#一：-Koa2简介及与Koa1的区别" class="headerlink" title="一： Koa2简介及与Koa1的区别"></a>一： Koa2简介及与Koa1的区别</h2><p>Koa2是Koa1框架的升级版本，目前已经是koa的默认版本；<br>相较于Koa1，Koa2引入了一些重要的变化和改进。以下是Koa2相对于Koa1的一些区别：</p><ol><li>Koa 1 使用 Generator 函数来处理中间件和异步操作，而 Koa 2 直接支持 async&#x2F;await，让中间件的编写和理解更加简洁明了</li></ol><p>下面我们从使用的角度分别分析：</p><h2 id="二：Koa2的Async-Await支持"><a href="#二：Koa2的Async-Await支持" class="headerlink" title="二：Koa2的Async&#x2F;Await支持"></a>二：Koa2的Async&#x2F;Await支持</h2><p>现在我们使用koa1来实现一个中间件，该如何做呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * (next) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">someAsyncFunction</span>(); <span class="hljs-comment">// Yielding async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> next;<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> * () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>koa2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: Before async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">xxxx</span>(); <span class="hljs-comment">// Await async operation</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1: After async operation&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>Koa2的中间件函数采用 async (ctx, next) &#x3D;&gt; {…}，而在 Koa1中是function * (next) {…}。Koa2直接支持Async&#x2F;Await，使得中间件的编写和理解更加简洁。</p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析koa的koa-compose</title>
    <link href="/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/"/>
    <url>/2023/08/31/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90koa%E7%9A%84koa-compose/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa-compose 是koa用来合并中间件的工具，并且在中间件内部，原各个中间件的执行过程为洋葱式的。<br>本文我们从源码的角度，去看洋葱式是什么？它又是如何实现的？</p><h4 id="二：源码"><a href="#二：源码" class="headerlink" title="二：源码"></a>二：源码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middleware)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware stack must be an array!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码精简</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span> (i) &#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中的重要逻辑：</p><ul><li>返回值为一个中间件A</li><li>中间件数组的执行，是从第一个开始的</li><li>执行某中间件时，同时传入了下一个中间件（赋值为next），并通过调用next来执行该中间件</li><li>数组中中间件执行完毕后，执行A的下一个中间件</li></ul><h4 id="三：next与洋葱模型"><a href="#三：next与洋葱模型" class="headerlink" title="三：next与洋葱模型"></a>三：next与洋葱模型</h4><p>上回说到，next是用来执行下一个中间件的，那么在某中间件中，next的执行可能有以下情况</p><h5 id="3-1-在最开始调用"><a href="#3-1-在最开始调用" class="headerlink" title="3.1 在最开始调用"></a>3.1 在最开始调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-2-在中间调用"><a href="#3-2-在中间调用" class="headerlink" title="3.2 在中间调用"></a>3.2 在中间调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">2</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-3-在末尾调用"><a href="#3-3-在末尾调用" class="headerlink" title="3.3 在末尾调用"></a>3.3 在末尾调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> md1 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> md2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> mds = <span class="hljs-title function_">compose</span>([md1, md2]);<br><span class="hljs-title function_">mds</span>(&#123;&#125;, <span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;all finished&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-keyword">all</span> finished<br></code></pre></td></tr></table></figure><h5 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h5><p>由于以下两条显而易见的规则：</p><ul><li>在某中间件内，next之前的代码先于next之后的代码执行</li><li>对某中间件来说，next执行完毕的标志，是其后所有的中间件均执行完毕</li></ul><p>故而中间件执行的过程有以下特征：</p><ul><li>先执行各个中间件next之前的代码，再执行各个中间件next之后的代码</li><li>各中间件next之前的代码，执行顺序为按照中间件顺序，从前向后</li><li>各中间件next之后的代码，执行顺序为按照中间件顺序，从后向前</li></ul><p>最后祭出那颗著名的葱：</p><p><img src="/pic/yangcong.jpg" alt="洋葱模型"></p><p>参考:<br><a href="https://github.com/koajs/compose.git">https://github.com/koajs/compose.git</a></p>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koa源码学习及最简实现</title>
    <link href="/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/31/koa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9C%80%E7%AE%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h4><p>koa是基于nodejs平台的下一代web框架（官网描述）<br>官网地址：<a href="https://koa.bootcss.com/">https://koa.bootcss.com/</a><br>git地址：<a href="https://github.com/koajs/koa.git">https://github.com/koajs/koa.git</a><br>koa提供基于http服务的最简的框架模型，包括洋葱式的中间件处理逻辑、对请求和响应的封装等。</p><h4 id="二：使用"><a href="#二：使用" class="headerlink" title="二：使用"></a>二：使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><br><span class="hljs-keyword">let</span> koa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>koa.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);<br>    ctx.<span class="hljs-property">body</span> = &#123; <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> &#125;;<br>&#125;);<br><br>koa.<span class="hljs-title function_">listen</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server listen 5000&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="三：源码"><a href="#三：源码" class="headerlink" title="三：源码"></a>三：源码</h4><p>源码的lib下共四个文件：application.js，context.js，request.js，response.js</p><h5 id="3-1-application-js"><a href="#3-1-application-js" class="headerlink" title="3.1 application.js"></a>3.1 application.js</h5><p>application.js是暴露给外部的入口，关键代码：</p><h6 id="3-1-1-use"><a href="#3-1-1-use" class="headerlink" title="3.1.1 use"></a>3.1.1 use</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;middleware must be a function!&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isGeneratorFunction</span>(fn)) &#123;<br>    <span class="hljs-title function_">deprecate</span>(<span class="hljs-string">&#x27;Support for generators will be removed in v3. &#x27;</span> +<br>              <span class="hljs-string">&#x27;See the documentation for examples of how to convert old middleware &#x27;</span> +<br>              <span class="hljs-string">&#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;</span>);<br>    fn = <span class="hljs-title function_">convert</span>(fn);<br>  &#125;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;use %s&#x27;</span>, fn.<span class="hljs-property">_name</span> || fn.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;-&#x27;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>use方法接收中间件（即函数），并将其放入middleware数组中；<br>return this，用于支持use的链式调用；</p><h6 id="3-1-2-listen"><a href="#3-1-2-listen" class="headerlink" title="3.1.2 listen"></a>3.1.2 listen</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;listen&#x27;</span>);<br>  <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>  <span class="hljs-keyword">return</span> server.<span class="hljs-title function_">listen</span>(...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>koa提供的服务，本质上是nodejs的http模块提供的。koa定义了自己的callback函数用来接收请求和返回结果；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onerror</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createContext</span>(req, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> handleRequest;<br>&#125;<br></code></pre></td></tr></table></figure><p>compose函数是koa-compose提供的，其作用是将多个中间件整理成一个中间件，在此中间件内部，原来的多个中间件的执行过程是洋葱式的；<br>createContext的作用是封装req,res为一个context对象，该对象经handleRequest函数传入每一个中间件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = ctx.<span class="hljs-property">res</span>;<br>  res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onerror</span> = err =&gt; ctx.<span class="hljs-title function_">onerror</span>(err);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResponse</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">respond</span>(ctx);<br>  <span class="hljs-title function_">onFinished</span>(res, onerror); <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx).<span class="hljs-title function_">then</span>(handleResponse).<span class="hljs-title function_">catch</span>(onerror);<br>&#125;   <br></code></pre></td></tr></table></figure><p>当所有中间件执行完毕，调用handleResponse函数，来返回结果</p><h5 id="3-2-context-js"><a href="#3-2-context-js" class="headerlink" title="3.2 context.js"></a>3.2 context.js</h5><p>包含createContext的返回对象相关的一些方法</p><h5 id="3-3-request-js"><a href="#3-3-request-js" class="headerlink" title="3.3 request.js"></a>3.3 request.js</h5><p>基于http.createServer中callback内的参数 req，封装了一些方法</p><h5 id="3-4-response-js"><a href="#3-4-response-js" class="headerlink" title="3.4 response.js"></a>3.4 response.js</h5><p>基于http.createServer中callback内的参数 res，封装了一些方法</p><h4 id="四：最简实现"><a href="#四：最简实现" class="headerlink" title="四：最简实现"></a>四：最简实现</h4><p>假设不考虑参数验错，req和res封装等，最简的类koa模型应该具备以下特征</p><ul><li>支持增加中间件</li><li>中间件的执行流程为洋葱式</li><li>context传入每个中间件，以实现中间件间的数据共享</li><li>具备处理各种事件的能力，如error事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Emitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);<br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-compose&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleKoa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Emitter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>());<br>        server.<span class="hljs-title function_">listen</span>(...args);<br>    &#125;<br><br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenrCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br>        <span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> ctx = &#123;<br>                req,<br>                res<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handleRequest;<br>    &#125;<br><br>    <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">ctx, fnMiddleware</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fnMiddleware</span>(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
